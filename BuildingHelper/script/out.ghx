<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<Archive name="Root">
  <!--Grasshopper archive-->
  <!--Grasshopper and GH_IO.dll are copyrighted by Robert McNeel & Associates-->
  <!--Archive generated by GH_IO.dll file utility library {0.2.0002}-->
  <items count="1">
    <item name="ArchiveVersion" type_name="gh_version" type_code="80">
      <Major>0</Major>
      <Minor>2</Minor>
      <Revision>2</Revision>
    </item>
  </items>
  <chunks count="2">
    <chunk name="Definition">
      <items count="1">
        <item name="plugin_version" type_name="gh_version" type_code="80">
          <Major>0</Major>
          <Minor>9</Minor>
          <Revision>76</Revision>
        </item>
      </items>
      <chunks count="5">
        <chunk name="DocumentHeader">
          <items count="5">
            <item name="DocumentID" type_name="gh_guid" type_code="9">69d9911e-a464-4365-bb27-73977a7052fc</item>
            <item name="Preview" type_name="gh_string" type_code="10">Shaded</item>
            <item name="PreviewMeshType" type_name="gh_int32" type_code="3">1</item>
            <item name="PreviewNormal" type_name="gh_drawing_color" type_code="36">
              <ARGB>100;150;0;0</ARGB>
            </item>
            <item name="PreviewSelected" type_name="gh_drawing_color" type_code="36">
              <ARGB>100;0;150;0</ARGB>
            </item>
          </items>
        </chunk>
        <chunk name="DefinitionProperties">
          <items count="3">
            <item name="Date" type_name="gh_date" type_code="8">636140903519571247</item>
            <item name="Description" type_name="gh_string" type_code="10"></item>
            <item name="Name" type_name="gh_string" type_code="10">base.ghx</item>
          </items>
          <chunks count="3">
            <chunk name="Revisions">
              <items count="1">
                <item name="RevisionCount" type_name="gh_int32" type_code="3">0</item>
              </items>
            </chunk>
            <chunk name="Projection">
              <items count="2">
                <item name="Target" type_name="gh_drawing_point" type_code="30">
                  <X>442</X>
                  <Y>90</Y>
                </item>
                <item name="Zoom" type_name="gh_single" type_code="5">3.39298749</item>
              </items>
            </chunk>
            <chunk name="Views">
              <items count="1">
                <item name="ViewCount" type_name="gh_int32" type_code="3">0</item>
              </items>
            </chunk>
          </chunks>
        </chunk>
        <chunk name="RcpLayout">
          <items count="1">
            <item name="GroupCount" type_name="gh_int32" type_code="3">0</item>
          </items>
        </chunk>
        <chunk name="GHALibraries">
          <items count="1">
            <item name="Count" type_name="gh_int32" type_code="3">0</item>
          </items>
        </chunk>
        <chunk name="DefinitionObjects">
          <items count="1">
            <item name="ObjectCount" type_name="gh_int32" type_code="3">1</item>
          </items>
          <chunks count="1">
            <chunk name="Object" index="0">
              <items count="2">
                <item name="GUID" type_name="gh_guid" type_code="9">a9a8ebd2-fff5-4c44-a8f5-739736d129ba</item>
                <item name="Name" type_name="gh_string" type_code="10">C# Script</item>
              </items>
              <chunks count="1">
                <chunk name="Container">
                  <items count="9">
                    <item name="AdditionalSource" type_name="gh_string" type_code="10">#region ..\BuildingObject.cs

    /// &lt;summary&gt;
    /// 建築を示すオブジェクト等を含みます。
    /// &lt;/summary&gt;
    public class BuildingObject
    {
        /// &lt;summary&gt;
        /// 3Dモデルを生成可能です。
        /// &lt;/summary&gt;
        public interface BuildingObjectProvider
        {
            /// &lt;summary&gt;
            /// 建築の3Dモデルを取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築の3Dモデル&lt;/returns&gt;
            RealObject.Building GetBuilding();
        }

        /// &lt;summary&gt;
        /// 3Dモデルと平面図を生成可能です。
        /// &lt;/summary&gt;
        public interface Building : BuildingObjectProvider
        {
            /// &lt;summary&gt;
            /// 建築の平面図全体を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築の平面図全体&lt;/returns&gt;
            PlanObject.Building GetPlan();
        }

        /// &lt;summary&gt;
        /// 複数階層を保持している建築を示します。
        /// 比較的単純な建築に向きます。スキップフロアなどには向きません。
        /// &lt;/summary&gt;
        public class BuildingMultipleFloor : Building
        {
            /// &lt;summary&gt;
            /// 建築に含まれる階層の集合を示します。
            /// 要素の番号が0から始まる事に注意してください。
            /// 地階を含む場合など注意が必要です。
            /// &lt;/summary&gt;
            public List&lt;FloorGeneral&gt; Content = new List&lt;FloorGeneral&gt;();
            /// &lt;summary&gt;
            /// 建築の名前です。レイヤーの設定などに利用されます。
            /// &lt;/summary&gt;
            public string Name = &quot;Building&quot;;

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを指定した名前で設定します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Name&quot;&gt;建築の名前&lt;/param&gt;
            public BuildingMultipleFloor(string Name)
            {
                this.Name = Name;
            }

            /// &lt;summary&gt;
            /// 建築全体の3Dモデルを取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築全体の3Dモデル&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(this.Name);
                double Height = 0;
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    FloorGeneral item = Content[i];

                    RealObject.Building Body = item.GetBuilding();
                    Body.Transform(Transform.Translation(0, 0, Height));
                    Result.Add(Body);

                    RealObject.Member Floor = item.GetFloor();
                    Floor.Transform(Transform.Translation(0, 0, Height));
                    Result.Add(Floor);

                    RealObject.Member Ceiling = item.GetCeiling();
                    Ceiling.Transform(Transform.Translation(0, 0, Height));
                    Result.Add(Ceiling);

                    RealObject.Member Loof = item.GetLoof();
                    Loof.Transform(Transform.Translation(0, 0, Height));
                    Result.Add(Loof);

                    Height += item.Height;
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 建築全体の軽量な3Dモデルを取得します。遠景用など。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築全体の3Dモデル&lt;/returns&gt;
            public RealObject.Building GetBuildingLight()
            {
                RealObject.Building Result = new RealObject.Building(this.Name);
                double Height = 0;
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    FloorGeneral item = Content[i];


                    List&lt;Brep&gt; Exts = new List&lt;Brep&gt;();
                    Curve[] Cvs = item.GetOuterLine();
                    foreach (Curve Cv in Cvs)
                    {
                        Exts.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Cv, Vector3d.ZAxis * item.Height)));
                    }
                    RealObject.Member Wall = new RealObject.Member(&quot;Wall&quot;, Exts.ToArray());
                    Wall.Transform(Transform.Translation(0, 0, Height));
                    Result.Add(Wall);


                    RealObject.Member Loof = item.GetLoof();
                    Loof.Transform(Transform.Translation(0, 0, Height));
                    Result.Add(Loof);

                    Height += item.Height;

                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 断面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;l&quot;&gt;切断線&lt;/param&gt;
            /// &lt;returns&gt;断面図&lt;/returns&gt;
            public PlanObject.Floor GetSection(Line l)
            {
                Curve IntersectLine = l.ToNurbsCurve();
                Point3d Start = l.From;
                PlanObject.Floor Result = new PlanObject.Floor(&quot;Section&quot;);
                double CurrentHeight = 0;

                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    FloorGeneral item = Content[i];
                    double FloorHeight = item.Height;
                    List&lt;Point3d&gt; TPoints = new List&lt;Point3d&gt;();

                    Curve[] OCurves = item.GetOuterLine();

                    foreach (Curve Curve in OCurves)
                    {
                        var intersects = Rhino.Geometry.Intersect.Intersection.CurveCurve(Curve, IntersectLine, 100, 100);
                        foreach (var intersect in intersects)
                        {
                            TPoints.Add(intersect.PointA);
                        }
                    }

                    List&lt;double&gt; Distances = new List&lt;double&gt;();
                    foreach (Point3d TPoint in TPoints)
                    {
                        Distances.Add(Start.DistanceTo(TPoint));
                    }
                    Distances.Sort();

                    PlanObject.Member Wall = new PlanObject.Member(&quot;Wall&quot;);
                    PlanObject.Member Loof = new PlanObject.Member(&quot;Loof&quot;);
                    PlanObject.Member Floor = new PlanObject.Member(&quot;Floor&quot;);
                    for (int j = 0; j &lt; Distances.Count() - 1; j += 2)
                    {
                        Wall.Content.Add(new Line(Distances[j], CurrentHeight, 0, Distances[j], CurrentHeight + FloorHeight, 0).ToNurbsCurve());
                        Wall.Content.Add(new Line(Distances[j + 1], CurrentHeight, 0, Distances[j + 1], CurrentHeight + FloorHeight, 0).ToNurbsCurve());

                        Floor.Content.Add(new Line(Distances[j], CurrentHeight, 0, Distances[j + 1], CurrentHeight, 0).ToNurbsCurve());
                        Loof.Content.Add(new Line(Distances[j], CurrentHeight + FloorHeight, 0, Distances[j + 1], CurrentHeight + FloorHeight, 0).ToNurbsCurve());
                    }
                    Result.Content.Add(Wall);
                    Result.Content.Add(Loof);
                    Result.Content.Add(Floor);

                    CurrentHeight += FloorHeight;
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Building GetPlan()
            {
                PlanObject.Building Result = new PlanObject.Building(this.Name);
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    FloorGeneral item = Content[i];

                    Result.Content.Add(item.GetPlan());
                }
                return Result;
            }
        }

        /// &lt;summary&gt;
        /// 比較的単純な建築の一階層を保持します。
        /// &lt;/summary&gt;
        public class FloorGeneral : BuildingObjectProvider
        {
            /// &lt;summary&gt;
            /// 階層に含まれる壁面の集合を示します。
            /// &lt;/summary&gt;
            public List&lt;Wall&gt; Walls = new List&lt;Wall&gt;();
            /// &lt;summary&gt;
            /// 階層に含まれる壁面以外の3Dオブジェクトを示します。
            /// &lt;/summary&gt;
            public List&lt;RealObject.Building&gt; Objects = new List&lt;RealObject.Building&gt;();
            /// &lt;summary&gt;
            /// 階層の高さを示します。
            /// &lt;/summary&gt;
            public double Height = 0;
            /// &lt;summary&gt;
            /// 階層名です。
            /// &lt;/summary&gt;
            public string Name = &quot;Floor&quot;;
            /// &lt;summary&gt;
            /// 天井の厚さを示します。
            /// &lt;/summary&gt;
            public double CeilingThick = 300;
            /// &lt;summary&gt;
            /// 床の地表面からの高さを示します。
            /// &lt;/summary&gt;
            public double GroundOffset = 200;

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを指定した名前で生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Name&quot;&gt;階層の名前&lt;/param&gt;
            public FloorGeneral(string Name)
            {
                this.Name = Name;
            }

            /// &lt;summary&gt;
            /// 階層の3Dモデルを取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;階層の3Dモデル&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(this.Name);
                foreach (Wall w in Walls)
                {
                    Result.Add(w.GetBuilding());
                }
                Result.Add(Objects.ToArray());
                return Result;
            }

            /// &lt;summary&gt;
            /// 階層の輪郭線から天井を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;天井&lt;/returns&gt;
            public RealObject.Member GetCeiling()
            {
                Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
                return new RealObject.Member(&quot;Ceiling&quot;, GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height - CeilingThick)));
            }
            /// &lt;summary&gt;
            /// 階層の輪郭線から床を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;床&lt;/returns&gt;
            public RealObject.Member GetFloor()
            {
                Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
                return new RealObject.Member(&quot;Floor&quot;, GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, 1)));
            }
            /// &lt;summary&gt;
            /// 階層の輪郭線から屋根を取得します。
            /// 階層が最上階の場合に利用するのが望ましいです。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;屋根&lt;/returns&gt;
            public RealObject.Member GetLoof()
            {
                Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
                return new RealObject.Member(&quot;Loof&quot;, GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height)));
            }

            /// &lt;summary&gt;
            /// 階層の輪郭線を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;輪郭線&lt;/returns&gt;
            public Curve[] GetOuterLine()
            {
                List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
                foreach (Wall w in Walls)
                {
                    Curve cv = w.GetLineOut();
                    if (cv != null) { cvs.Add(cv); }
                }
                return Curve.JoinCurves(cvs);
            }

            /// &lt;summary&gt;
            /// 階層の平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Floor GetPlan()
            {
                PlanObject.Floor Result = new PlanObject.Floor(&quot;Floor&quot;);
                foreach (Wall w in this.Walls)
                {
                    Result.Content.AddRange(w.GetPlan());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 階層に壁を追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;壁&lt;/param&gt;
            public void Add(params Wall[] item)
            {
                Walls.AddRange(item);
            }

            /// &lt;summary&gt;
            /// 階層に3Dオブジェクトを追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;3Dオブジェクト&lt;/param&gt;
            public void Add(params RealObject.Building[] item)
            {
                Objects.AddRange(item);
            }
        }

        /// &lt;summary&gt;
        /// 同種の階層のみからなる建築を示します。
        /// &lt;/summary&gt;
        public class BuildingSingleFloor : Building
        {
            /// &lt;summary&gt;
            /// 全階層に含まれる壁の集合です。
            /// &lt;/summary&gt;
            public List&lt;Wall&gt; Walls = new List&lt;Wall&gt;();
            /// &lt;summary&gt;
            /// 全階層に含まれる3Dオブジェクトを示します。
            /// &lt;/summary&gt;
            public List&lt;RealObject.Building&gt; Objects = new List&lt;RealObject.Building&gt;();
            /// &lt;summary&gt;
            /// 建築の階数です。
            /// &lt;/summary&gt;
            public int Floor = 1;
            /// &lt;summary&gt;
            /// 一階層当たりの高さを示します。
            /// &lt;/summary&gt;
            public double Height;
            /// &lt;summary&gt;
            /// 建築の名前を示します。
            /// &lt;/summary&gt;
            public string Name = &quot;Building&quot;;
            /// &lt;summary&gt;
            /// 天井の厚さを示します。
            /// &lt;/summary&gt;
            public double CeilingThick = 300;
            /// &lt;summary&gt;
            /// 建築の設置高さを示します。
            /// &lt;/summary&gt;
            public double GroundOffset = 200;

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを指定した名前で生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Name&quot;&gt;建築の名前&lt;/param&gt;
            public BuildingSingleFloor(string Name)
            {
                this.Name = Name;
            }
            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを生成します。
            /// &lt;/summary&gt;
            public BuildingSingleFloor()
            {
            }

            /// &lt;summary&gt;
            /// 建築全体の3Dモデルを取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;3Dモデル&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                List&lt;RealObject.Building&gt; BldBase = new List&lt;RealObject.Building&gt;();
                List&lt;RealObject.Building&gt; BldBaseTop = new List&lt;RealObject.Building&gt;();
                foreach (Wall w in Walls)
                {
                    BldBase.Add(w.GetBuilding());
                    BldBaseTop.Add(w.GetBuildingTop());
                }
                RealObject.Building Ceiling = new RealObject.Building(&quot;Ceiling&quot;);
                Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
                Ceiling.Add(&quot;Ceiling&quot;, GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height - CeilingThick)));
                BldBase.Add(Ceiling);

                BldBase.AddRange(Objects);

                RealObject.Member Loof = new RealObject.Member(&quot;Floor&quot;, GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height)));

                RealObject.Building Result = new RealObject.Building(Name);
                for (int i = 0; i &lt; Floor; i++)
                {
                    foreach (RealObject.Building bld in BldBase)
                    {
                        foreach (RealObject.Member mb in bld.Content)
                        {
                            RealObject.Member newMem = mb.Duplicate();
                            newMem.Transform(Transform.Translation(0, 0, GroundOffset + Height * i));
                            Result.Add(newMem);
                        }
                    }

                    RealObject.Member newLoof = Loof.Duplicate();
                    newLoof.Transform(Transform.Translation(0, 0, GroundOffset + Height * i));
                    if (i + 1 == Floor)
                    {
                        newLoof.SetName(&quot;Loof&quot;);
                    }
                    Result.Add(newLoof);
                }
                {
                    RealObject.Member newLoof = Loof.Duplicate();
                    newLoof.Transform(Transform.Translation(0, 0, GroundOffset - Height));
                    Result.Add(newLoof);
                }
                if (GroundOffset != 0)
                {
                    Curve[] cvs = GetOuterLine();
                    foreach (Curve cv in cvs)
                    {
                        Result.Add(&quot;Basement&quot;, Brep.CreateFromSurface(Surface.CreateExtrusion(cv, Vector3d.ZAxis * GroundOffset)));
                    }
                }
                foreach (RealObject.Building bld in BldBaseTop)
                {
                    foreach (RealObject.Member mb in bld.Content)
                    {
                        RealObject.Member newMem = mb.Duplicate();
                        newMem.Transform(Transform.Translation(0, 0, GroundOffset + Height * (Floor - 1)));
                        Result.Add(newMem);
                    }
                }

                return Result;
            }

            /// &lt;summary&gt;
            /// 建築全体の平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Building GetPlan()
            {
                PlanObject.Floor ResultF = new PlanObject.Floor(&quot;Floor&quot;);
                foreach (Wall w in this.Walls)
                {
                    ResultF.Content.AddRange(w.GetPlan());
                }

                PlanObject.Building ResultB = new PlanObject.Building(&quot;Building&quot;);
                for (int i = 0; i &lt; this.Floor; i++)
                {
                    ResultB.Content.Add(ResultF);
                }
                return ResultB;
            }

            /// &lt;summary&gt;
            /// 各階に壁面を追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;壁&lt;/param&gt;
            public void Add(params Wall[] item)
            {
                Walls.AddRange(item);
            }

            /// &lt;summary&gt;
            /// 各階に3Dオブジェクトを追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;3Dオブジェクト&lt;/param&gt;
            public void Add(params RealObject.Building[] item)
            {
                Objects.AddRange(item);
            }

            /// &lt;summary&gt;
            /// 各階の輪郭線を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;輪郭線&lt;/returns&gt;
            public Curve[] GetOuterLine()
            {
                List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
                foreach (Wall w in Walls)
                {
                    Curve cv = w.GetLineOut();
                    if (cv != null) { cvs.Add(cv); }
                }
                return Curve.JoinCurves(cvs);
            }
        }

        /// &lt;summary&gt;
        /// 定義済みの建築作成クラスを提供します。
        /// &lt;/summary&gt;
        public static class BuildingProvider
        {
            /// &lt;summary&gt;
            /// 適当なアパートメントを提供します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;UnitX&quot;&gt;ユニットのX方向の大きさ&lt;/param&gt;
            /// &lt;param name=&quot;UnitY&quot;&gt;ユニットのY方向の大きさ&lt;/param&gt;
            /// &lt;param name=&quot;UnitZ&quot;&gt;ユニットのZ方向の大きさ&lt;/param&gt;
            /// &lt;param name=&quot;UnitCountX&quot;&gt;X方向の個数&lt;/param&gt;
            /// &lt;param name=&quot;UnitCountZ&quot;&gt;Z方向の個数(階数)&lt;/param&gt;
            /// &lt;param name=&quot;CeilingThick&quot;&gt;天井の高さ&lt;/param&gt;
            /// &lt;param name=&quot;WallThick&quot;&gt;壁の厚さ&lt;/param&gt;
            /// &lt;returns&gt;建築&lt;/returns&gt;
            public static BuildingObject.Building GetApartment(double UnitX, double UnitY, double UnitZ, int UnitCountX, int UnitCountZ, double CeilingThick = 300, double WallThick = 0)
            {
                BuildingObject.BuildingSingleFloor Result = new BuildingObject.BuildingSingleFloor();
                Result.Height = UnitZ;
                Result.Name = &quot;Apartment&quot;;
                Result.CeilingThick = CeilingThick;
                Result.Floor = UnitCountZ;

                WallGeneral WallSouth = new WallGeneral(Point3d.Origin, new Vector2d(UnitX, 0), UnitZ, WallThick);
                WallSouth.Add(new VerandaSimple(new Interval(0, UnitX), 100, 2000, 100, 1000, 150) { SideHeight1 = UnitZ, SideHeight2 = UnitZ });
                WallSouth.AttachmentsTop.Add(new Eaves(new Interval(0, UnitX), 2000, 300, UnitZ));
                for (double WindowX = 1000; WindowX + 2000 + 500 &lt; UnitX; WindowX += 3000)
                {
                    WallSouth.Add(new BuildingObject.WindowGlassSimpleDouble(new Point2d(WindowX, 0), 2000, 2500));
                }
                Result.Add(new WallRepeat(WallSouth, UnitCountX));

                Result.Add(new WallGeneral(new Point3d(0, UnitY, 0), new Vector2d(0, -UnitY), UnitZ, WallThick));
                for (int i = 1; i &lt; UnitCountX; i++)
                {
                    Result.Add(new WallGeneral(new Point3d(UnitX * i, 0, 0), new Vector2d(0, UnitY), UnitZ, WallThick));
                }
                Result.Add(new WallGeneral(new Point3d(UnitX * UnitCountX, 0, 0), new Vector2d(0, UnitY), UnitZ, WallThick));


                WallGeneral WallNorth = new WallGeneral(new Point3d(UnitX * UnitCountX, UnitY, 0), new Vector2d(-UnitX * UnitCountX, 0), UnitZ, WallThick);
                WallNorth.Add(new VerandaSimple(new Interval(0, UnitX * UnitCountX), 100, 2000, 100, 1000, 100));
                for (int i = 0; i &lt; UnitCountX; i++)
                {
                    WallNorth.Add(new DoorSimple(new Point2d(UnitX * i + 500, 0), 1000, 2500, DoorSimple.Side.FrontRight));
                }
                Result.Add(WallNorth);

                return Result;
            }
        }

        /// &lt;summary&gt;
        /// 階段を識別するためのインターフェースです。
        /// &lt;/summary&gt;
        public interface Stair : BuildingObjectProvider
        {
        }

        /// &lt;summary&gt;
        /// 壁を示します。
        /// &lt;/summary&gt;
        public interface Wall : BuildingObjectProvider
        {
            /// &lt;summary&gt;
            /// 最上階における建築の3Dモデルを取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築の3Dモデル&lt;/returns&gt;
            RealObject.Building GetBuildingTop();
            /// &lt;summary&gt;
            /// 壁を指定された方向に移動します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;v3d&quot;&gt;移動方向&lt;/param&gt;
            void Translate(Vector3d v3d);
            /// &lt;summary&gt;
            /// 壁を指定された角度回転します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;angle&quot;&gt;角度&lt;/param&gt;
            void Rotate(double angle);
            /// &lt;summary&gt;
            /// 平面図で壁面を示す形状を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            Curve[] GetCurves();
            /// &lt;summary&gt;
            /// 壁の内側を示す線です。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;線&lt;/returns&gt;
            Curve GetLineIn();
            /// &lt;summary&gt;
            /// 壁の外側を示す線です。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;線&lt;/returns&gt;
            Curve GetLineOut();
            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            Wall Duplicate();
            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            PlanObject.Member[] GetPlan();
        }

        /// &lt;summary&gt;
        /// 連続した壁です。
        /// &lt;/summary&gt;
        public class WallRepeat : Wall
        {
            /// &lt;summary&gt;
            /// 基本となる壁です。
            /// &lt;/summary&gt;
            public Wall Content;
            /// &lt;summary&gt;
            /// 繰り返し回数です。
            /// &lt;/summary&gt;
            public int Count;
            /// &lt;summary&gt;
            /// 繰り返される向きです。
            /// &lt;/summary&gt;
            public Vector3d Direction { get { if (Content is WallGeneral) { Vector2d v2d = ((WallGeneral)Content).Direction; return new Vector3d(v2d.X, v2d.Y, 0); } else { return _Direction; } } set { if (!(Content is WallGeneral)) { _Direction = value; } } }
            private Vector3d _Direction;

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを基本となる壁と長さから生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Content&quot;&gt;基本となる壁&lt;/param&gt;
            /// &lt;param name=&quot;Count&quot;&gt;繰り返し回数&lt;/param&gt;
            public WallRepeat(WallGeneral Content, int Count)
            {
                this.Content = Content;
                this.Count = Count;
            }

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを基本となる壁と長さと方向から生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Content&quot;&gt;基本となる壁&lt;/param&gt;
            /// &lt;param name=&quot;Count&quot;&gt;長さ&lt;/param&gt;
            /// &lt;param name=&quot;Direction&quot;&gt;繰り返し方向&lt;/param&gt;
            public WallRepeat(Wall Content, int Count, Vector3d Direction)
            {
                this.Content = Content;
                this.Count = Count;
                this.Direction = Direction;
            }

            /// &lt;summary&gt;
            /// 構成する壁を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;壁の集合&lt;/returns&gt;
            public Wall[] GetWalls()
            {
                List&lt;Wall&gt; w = new List&lt;Wall&gt;();
                for (int i = 0; i &lt; Count; i++)
                {
                    Wall tmpw = Content.Duplicate();
                    tmpw.Translate(Direction * i);
                    w.Add(tmpw);
                }
                return w.ToArray();
            }

            /// &lt;summary&gt;
            /// 壁面を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                Wall[] ws = GetWalls();
                RealObject.Building Result = new RealObject.Building(&quot;WallRepeat&quot;);
                foreach (Wall w in ws)
                {
                    Result.Add(w.GetBuilding());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 最上階の場合の壁面を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築&lt;/returns&gt;
            public RealObject.Building GetBuildingTop()
            {
                Wall[] ws = GetWalls();
                RealObject.Building Result = new RealObject.Building(&quot;WallRepeat&quot;);
                foreach (Wall w in ws)
                {
                    Result.Add(w.GetBuildingTop());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 壁を指定された方向に移動します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;v3d&quot;&gt;移動方向&lt;/param&gt;
            public void Translate(Vector3d v3d)
            {
                Content.Translate(v3d);
            }

            /// &lt;summary&gt;
            /// 壁を指定された角度回転します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;angle&quot;&gt;角度&lt;/param&gt;
            public void Rotate(double angle)
            {
                Content.Rotate(angle);
            }

            /// &lt;summary&gt;
            /// 平面図で壁面を示す形状を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public Curve[] GetCurves()
            {
                Wall[] ws = GetWalls();
                List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
                foreach (Wall w in ws)
                {
                    cvs.AddRange(w.GetCurves());
                }
                return cvs.ToArray();
            }

            /// &lt;summary&gt;
            /// 壁の内側を示す線です。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;線&lt;/returns&gt;
            public Curve GetLineIn()
            {
                Wall[] ws = GetWalls();
                List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
                foreach (Wall w in ws)
                {
                    cvs.Add(w.GetLineIn());
                }
                return Curve.JoinCurves(cvs.ToArray())[0];
            }

            /// &lt;summary&gt;
            /// 壁の外側を示す線です。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;線&lt;/returns&gt;
            public Curve GetLineOut()
            {
                Wall[] ws = GetWalls();
                List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
                foreach (Wall w in ws)
                {
                    cvs.Add(w.GetLineOut());
                }
                return Curve.JoinCurves(cvs.ToArray())[0];
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Wall Duplicate()
            {
                return new WallRepeat(this.Content, this.Count, this.Direction);
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                Wall[] ws = GetWalls();
                List&lt;PlanObject.Member&gt; Result = new List&lt;PlanObject.Member&gt;();
                foreach (Wall w in ws)
                {
                    Result.AddRange(w.GetPlan());
                }
                return Result.ToArray();
            }
        }

        /// &lt;summary&gt;
        /// 基本的な直方体の壁を示します。
        /// &lt;/summary&gt;
        public class WallGeneral : Wall
        {
            /// &lt;summary&gt;
            /// 壁の始点です。
            /// &lt;/summary&gt;
            public Point3d StartPoint;
            /// &lt;summary&gt;
            /// 壁の方向です。
            /// &lt;/summary&gt;
            public Vector2d Direction;
            /// &lt;summary&gt;
            /// 壁の高さです。
            /// &lt;/summary&gt;
            public double Height;
            /// &lt;summary&gt;
            /// 壁の厚さです。
            /// 厚さは壁の方向を90°回転させた向きを正とします。
            /// &lt;/summary&gt;
            public double Thickness;
            /// &lt;summary&gt;
            /// 壁の終点です。
            /// &lt;/summary&gt;
            public Point3d EndPoint { get { return StartPoint + new Vector3d(Direction.X, Direction.Y, Height); } set { Vector3d v3d = value - StartPoint; Direction = new Vector2d(v3d.X, v3d.Y); Height = v3d.Z; } }
            /// &lt;summary&gt;
            /// trueの場合、3Dモデルを生成する際に、壁の厚さを0とみなします。
            /// &lt;/summary&gt;
            public bool ApplyZeroThicknessToBrep = false;
            /// &lt;summary&gt;
            /// trueの場合、平面図では表示しません。
            /// &lt;/summary&gt;
            public bool OmitFromFloorLine = false;

            /// &lt;summary&gt;
            /// 壁面に含まれる窓の集合です。
            /// &lt;/summary&gt;
            public List&lt;BuildingObject.Window&gt; Windows = new List&lt;BuildingObject.Window&gt;();
            /// &lt;summary&gt;
            /// 壁面を構成するその他の添加物の集合です。
            /// &lt;/summary&gt;
            public List&lt;BuildingObject.WallAttachment&gt; Attachments = new List&lt;BuildingObject.WallAttachment&gt;();
            /// &lt;summary&gt;
            /// 最上階の場合、壁面を構成するその他の添加物の集合です。
            /// &lt;/summary&gt;
            public List&lt;BuildingObject.WallAttachment&gt; AttachmentsTop = new List&lt;BuildingObject.WallAttachment&gt;();

            /// &lt;summary&gt;
            /// 壁面を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;Wall&quot;);
                if (Thickness == 0 || ApplyZeroThicknessToBrep)
                {
                    Result.Add(&quot;Wall&quot;, Brep.CreatePlanarBreps(GetCurves()));
                }
                else
                {
                    Result.Add(&quot;Wall&quot;, GeneralHelper.CreateExtrusionCaped(GetCurves(), Vector3d.YAxis * Thickness));
                }

                foreach (BuildingObject.Window w in Windows)
                {
                    Result.Add(w.GetBuilding());
                }
                foreach (BuildingObject.WallAttachment at in Attachments)
                {
                    Result.Add(at.GetBuilding());
                }
                Result.Transform(GeneralHelper.FitTwoPoint(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)));
                return Result;
            }

            /// &lt;summary&gt;
            /// 最上階の場合の壁面を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;建築&lt;/returns&gt;
            public RealObject.Building GetBuildingTop()
            {
                RealObject.Building Result = new RealObject.Building(&quot;Wall.AttachmentTop&quot;);

                foreach (BuildingObject.WallAttachment at in AttachmentsTop)
                {
                    Result.Add(at.GetBuilding());
                }
                Result.Transform(GeneralHelper.FitTwoPoint(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)));
                return Result;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Wall Duplicate()
            {
                WallGeneral Result = new WallGeneral(this.StartPoint, this.Direction, this.Height, this.Thickness);

                foreach (BuildingObject.Window item in Windows)
                {
                    Result.Add(item.Duplicate());
                }
                foreach (BuildingObject.WallAttachment item in Attachments)
                {
                    Result.Add(item.Duplicate());
                }
                foreach (BuildingObject.WallAttachment item in AttachmentsTop)
                {
                    Result.AttachmentsTop.Add(item.Duplicate());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 壁の外側を示す線です。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;線&lt;/returns&gt;
            public Curve GetLineOut()
            {
                if (OmitFromFloorLine)
                {
                    return null;
                }
                else
                {
                    return new Line(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)).ToNurbsCurve();
                }
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;壁&lt;/returns&gt;
            public Curve GetLineIn()
            {
                Vector3d V3dNormal = new Vector3d(-Direction.Y, Direction.X, 0);
                V3dNormal.Unitize();

                Vector3d V3dBase = new Vector3d(Direction.X, Direction.Y, 0);
                double BaseLen = V3dBase.Length;
                V3dBase.Unitize();

                return new Line(StartPoint + V3dNormal * Thickness, StartPoint + V3dNormal * Thickness + V3dBase * BaseLen).ToNurbsCurve();
            }

            /// &lt;summary&gt;
            /// 平面図で壁面を示す四角形を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public Curve[] GetCurves()
            {
                List&lt;Curve&gt; Result = new List&lt;Curve&gt;();

                Result.Add(new Rectangle3d(Plane.WorldZX, Point3d.Origin, new Point3d(Direction.Length, 0, Height)).ToNurbsCurve());

                foreach (BuildingObject.Window w in Windows)
                {
                    Result.Add(new Rectangle3d(new Plane(new Point3d(w.StartPoint.X, 0, w.StartPoint.Y + 0.1), Vector3d.XAxis, Vector3d.ZAxis), w.Width, w.Height).ToNurbsCurve());
                }
                return Result.ToArray();
            }
            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;StartPoint&quot;&gt;開始点&lt;/param&gt;
            /// &lt;param name=&quot;Direction&quot;&gt;向き&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
            /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
            public WallGeneral(Point3d StartPoint, Vector2d Direction, double Height, double Thickness = 0)
            {
                this.StartPoint = StartPoint;
                this.Direction = Direction;
                this.Height = Height;
                this.Thickness = Thickness;
            }

            /// &lt;summary&gt;
            /// 窓を追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;窓&lt;/param&gt;
            public void Add(params Window[] item)
            {
                Windows.AddRange(item);
            }
            /// &lt;summary&gt;
            /// 壁の添加物を追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;壁の添加物&lt;/param&gt;
            public void Add(params WallAttachment[] item)
            {
                Attachments.AddRange(item);
            }

            /// &lt;summary&gt;
            /// 壁を指定された方向に移動します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;v3d&quot;&gt;移動方向&lt;/param&gt;
            public void Translate(Vector3d v3d)
            {
                StartPoint += v3d;
            }

            /// &lt;summary&gt;
            /// 壁を指定された角度回転します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;angle&quot;&gt;角度&lt;/param&gt;
            public void Rotate(double angle)
            {
                Point3d p3d = new Point3d(Direction.X, Direction.Y, 0);
                p3d.Transform(Transform.Rotation(angle, Point3d.Origin));
                Direction.X = p3d.X;
                Direction.Y = p3d.Y;
            }

            /*
            public void Transform(Transform tf)
            {
                Point3d a = Point3d.Origin;
                Point3d b = Point3d.Origin + Vector3d.YAxis;
                a.Transform(tf);
                b.Transform(tf);
                Thickness = (a - b).Length;

                Point3d End = EndPoint;
                End.Transform(tf);
                EndPoint = End;
                StartPoint.Transform(tf);

            }*/

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                List&lt;PlanObject.Member&gt; Result = new List&lt;PlanObject.Member&gt;();

                foreach (BuildingObject.WallAttachment item in Attachments)
                {
                    Result.AddRange(item.GetPlan());
                }
                List&lt;double&gt; PointList = new List&lt;double&gt;() { 0, Direction.Length };
                foreach (BuildingObject.Window item in Windows)
                {
                    Result.AddRange(item.GetPlan(this.Thickness));
                    PointList.Add(item.StartPoint.X);
                    PointList.Add(item.StartPoint.X + item.Width);
                }
                PointList.Sort();

                PlanObject.Member WallResult = new PlanObject.Member(&quot;Wall&quot;);
                for (int i = 0; i &lt; PointList.Count / 2; i++)
                {
                    WallResult.Content.Add(Providers.GetRectangle3d(new Point3d(PointList[i * 2], 0, 0), PointList[i * 2 + 1] - PointList[i * 2], this.Thickness));
                }
                Result.Add(WallResult);
                foreach (var item in Result)
                {
                    item.Transform(GeneralHelper.FitTwoPoint(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)));
                }
                return Result.ToArray();
            }
        }

        /// &lt;summary&gt;
        /// 壁の添加物です。
        /// &lt;/summary&gt;
        public interface WallAttachment : BuildingObjectProvider
        {
            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            WallAttachment Duplicate();
            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            PlanObject.Member[] GetPlan();

        }

        /// &lt;summary&gt;
        /// 軒を示します。
        /// &lt;/summary&gt;
        public class Eaves : WallAttachment
        {
            /// &lt;summary&gt;
            /// 軒の壁方向の範囲です。
            /// &lt;/summary&gt;
            public Interval Domain;
            /// &lt;summary&gt;
            /// 軒の長さです。
            /// &lt;/summary&gt;
            public double Length;
            /// &lt;summary&gt;
            /// 軒の厚さです。
            /// &lt;/summary&gt;
            public double Thickness;
            /// &lt;summary&gt;
            /// 軒の高さです。
            /// &lt;/summary&gt;
            public double Height;

            /// &lt;summary&gt;
            /// 3Dモデルを取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;3Dモデル&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;Eaves&quot;);
                Result.Add(&quot;Body&quot;, Brep.CreateFromBox(new Box(Plane.WorldXY, this.Domain, new Interval(-Length, 0), new Interval(Height - Thickness, Height))));
                return Result;
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                return new PlanObject.Member[0];
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public WallAttachment Duplicate()
            {
                return new Eaves(this.Domain, this.Length, this.Thickness, this.Height);
            }

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Domain&quot;&gt;軒の壁方向の範囲(X方向)&lt;/param&gt;
            /// &lt;param name=&quot;Length&quot;&gt;軒の長さ(Y方向)&lt;/param&gt;
            /// &lt;param name=&quot;Thickness&quot;&gt;軒の厚さ(Z方向)&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;軒の高さ(Z方向)&lt;/param&gt;
            public Eaves(Interval Domain, double Length, double Thickness, double Height)
            {
                this.Domain = Domain;
                this.Length = Length;
                this.Thickness = Thickness;
                this.Height = Height;
            }

        }

        /// &lt;summary&gt;
        /// 基本的なベランダを示します。
        /// &lt;/summary&gt;
        public class VerandaSimple : WallAttachment,ShadowObject.ShadowSingleProvider
        {
            /// &lt;summary&gt;
            /// 配置される壁における範囲
            /// &lt;/summary&gt;
            public Interval Domain;
            /// &lt;summary&gt;
            /// 床の厚さ
            /// &lt;/summary&gt;
            public double FloorThickness;
            /// &lt;summary&gt;
            /// 床の長さ
            /// &lt;/summary&gt;
            public double FloorLength;
            /// &lt;summary&gt;
            /// 手すりの厚さ
            /// &lt;/summary&gt;
            public double HandrailThickness;
            /// &lt;summary&gt;
            /// 手すりの高さ
            /// &lt;/summary&gt;
            public double HandrailHeight;
            /// &lt;summary&gt;
            /// 横の手すり厚さ。Domainの最小側に配置します。0の場合は作成しません。
            /// &lt;/summary&gt;
            public double SideThickness1;
            /// &lt;summary&gt;
            /// 横の手すり高さ。Domainの最小側に配置します。
            /// &lt;/summary&gt;
            public double SideHeight1;
            /// &lt;summary&gt;
            /// 横の手すり厚さ。Domainの最大側に配置します。0の場合は作成しません。
            /// &lt;/summary&gt;
            public double SideThickness2;
            /// &lt;summary&gt;
            /// 横の手すり高さ。Domainの最大側に配置します。
            /// &lt;/summary&gt;
            public double SideHeight2;

            /// &lt;summary&gt;
            /// ベランダを建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;ベランダ&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;VerandaSimple&quot;);
                Result.Add(&quot;Floor&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min + SideThickness1, Domain.Max - SideThickness2), new Interval(-FloorLength, 0), new Interval(-FloorThickness, 0))) });
                Result.Add(&quot;Handrail&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, Domain, new Interval(-HandrailThickness - FloorLength, -FloorLength), new Interval(-FloorThickness, HandrailHeight))) });
                if (SideThickness1 != 0)
                {
                    Result.Add(&quot;Side&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min, Domain.Min + SideThickness1), new Interval(-FloorLength, 0), new Interval(0, SideHeight1))) });
                }
                if (SideThickness2 != 0)
                {
                    Result.Add(&quot;Side&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Max - SideThickness2, Domain.Max), new Interval(-FloorLength, 0), new Interval(0, SideHeight2))) });
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを作成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Domain&quot;&gt;配置される壁における範囲&lt;/param&gt;
            /// &lt;param name=&quot;FloorThickness&quot;&gt;床の厚さ&lt;/param&gt;
            /// &lt;param name=&quot;FloorLength&quot;&gt;床の長さ&lt;/param&gt;
            /// &lt;param name=&quot;HandrailThickness&quot;&gt;手すりの厚さ&lt;/param&gt;
            /// &lt;param name=&quot;HandrailHeight&quot;&gt;手すりの高さ&lt;/param&gt;
            /// &lt;param name=&quot;SideThickness&quot;&gt;横の手すりの厚さ&lt;/param&gt;
            public VerandaSimple(Interval Domain, double FloorThickness, double FloorLength, double HandrailThickness, double HandrailHeight, double SideThickness = 0)
            {
                this.Domain = Domain;
                this.FloorLength = FloorLength;
                this.FloorThickness = FloorThickness;
                this.HandrailThickness = HandrailThickness;
                this.HandrailHeight = HandrailHeight;
                this.SideThickness1 = SideThickness;
                this.SideHeight1 = HandrailHeight;
                this.SideThickness2 = SideThickness;
                this.SideHeight2 = HandrailHeight;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public WallAttachment Duplicate()
            {
                return new VerandaSimple(this.Domain, this.FloorThickness, this.FloorLength, this.HandrailThickness, this.HandrailHeight, 0) { SideThickness1 = this.SideThickness1, SideThickness2 = this.SideThickness2, SideHeight1 = this.SideHeight1, SideHeight2 = this.SideHeight2 };
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;Veranda&quot;);
                Result.Content.Add(GetPlanPolyline().ToNurbsCurve());
                return new[] { Result };
            }

            private Polyline GetPlanPolyline()
            {
                Polyline PL = new Polyline(4);
                PL.Add(Domain.Min, 0, 0);
                PL.Add(Domain.Min, -FloorLength, 0);
                PL.Add(Domain.Max, -FloorLength, 0);
                PL.Add(Domain.Max, 0, 0);
                return PL;
            }

            public ShadowObject.ShadowSingle GetShadow(Vector3d direction, double height)
            {
                //手すりの影は省略します。
                return ShadowObject.Helper.GetShadowFromPlan(GetPlanPolyline().ToNurbsCurve(), direction, height);
            }
        }

        /// &lt;summary&gt;
        /// ガラス手すりのベランダを示します。
        /// &lt;/summary&gt;
        public class VerandaGlass : WallAttachment, ShadowObject.ShadowSingleProvider
        {
            /// &lt;summary&gt;
            /// 配置される壁における範囲
            /// &lt;/summary&gt;
            public Interval Domain;
            /// &lt;summary&gt;
            /// 床の厚さ
            /// &lt;/summary&gt;
            public double FloorThickness;
            /// &lt;summary&gt;
            /// 床の長さ
            /// &lt;/summary&gt;
            public double FloorLength;
            /// &lt;summary&gt;
            /// 横の手すり厚さ。0の場合は作成しません。
            /// &lt;/summary&gt;
            public double SideThickness;
            /// &lt;summary&gt;
            /// 横の手すり高さ。
            /// &lt;/summary&gt;
            public double SideHeight;
            /// &lt;summary&gt;
            /// 手すりの高さ
            /// &lt;/summary&gt;
            public double HandrailHeight = 1200;
            /// &lt;summary&gt;
            /// 手すりのガラス一枚当たりの長さ
            /// &lt;/summary&gt;
            public double HandrailSpace = 1000;

            /// &lt;summary&gt;
            /// ベランダを建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;ベランダ&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;VerandaGlass&quot;);
                Result.Add(&quot;Floor&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, Domain, new Interval(-FloorLength, 0), new Interval(-FloorThickness, 0))) });
                Result.Add(Providers.GetHandrailGlass(new Line(Domain.Min, -FloorLength, 0, Domain.Max, -FloorLength, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
                if (SideThickness != 0 &amp;&amp; SideHeight != 0)
                {
                    Result.Add(&quot;Side&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min, Domain.Min + SideThickness), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
                    Result.Add(&quot;Side&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Max - SideThickness, Domain.Max), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// クラスのインスタンスを生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Domain&quot;&gt;配置される壁における範囲&lt;/param&gt;
            /// &lt;param name=&quot;FloorThickness&quot;&gt;床の厚さ&lt;/param&gt;
            /// &lt;param name=&quot;FloorLength&quot;&gt;床の長さ&lt;/param&gt;
            /// &lt;param name=&quot;SideThickness&quot;&gt;横の手すり厚さ。0の場合は作成しません。&lt;/param&gt;
            /// &lt;param name=&quot;SideHeight&quot;&gt;横の手すり高さ。&lt;/param&gt;
            public VerandaGlass(Interval Domain, double FloorThickness, double FloorLength, double SideThickness = 0, double SideHeight = 0)
            {
                this.Domain = Domain;
                this.FloorLength = FloorLength;
                this.FloorThickness = FloorThickness;
                this.SideThickness = SideThickness;
                this.SideHeight = SideHeight;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public WallAttachment Duplicate()
            {
                return new VerandaGlass(this.Domain, this.FloorThickness, this.FloorLength, this.SideThickness, this.SideHeight);
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;Veranda&quot;);
                Result.Content.Add(GetPlanPolyline().ToNurbsCurve());
                return new[] { Result };
            }
            private Polyline GetPlanPolyline()
            {
                Polyline PL = new Polyline(4);
                PL.Add(Domain.Min, 0, 0);
                PL.Add(Domain.Min, -FloorLength, 0);
                PL.Add(Domain.Max, -FloorLength, 0);
                PL.Add(Domain.Max, 0, 0);
                return PL;
            }

            public ShadowObject.ShadowSingle GetShadow(Vector3d direction, double height)
            {
                //手すりの影は省略します。
                return ShadowObject.Helper.GetShadowFromPlan(GetPlanPolyline().ToNurbsCurve(), direction, height);
            }
        }

        /// &lt;summary&gt;
        /// 単純なガラス手すりのベランダを示します。
        /// &lt;/summary&gt;
        public class VerandaGlassSimple : WallAttachment,ShadowObject.ShadowSingleProvider
        {
            /// &lt;summary&gt;
            /// 配置される壁における範囲
            /// &lt;/summary&gt;
            public Interval Domain;
            /// &lt;summary&gt;
            /// 床の厚さ
            /// &lt;/summary&gt;
            public double FloorThickness;
            /// &lt;summary&gt;
            /// 床の長さ
            /// &lt;/summary&gt;
            public double FloorLength;
            /// &lt;summary&gt;
            /// 横の手すり厚さ。0の場合は作成しません。
            /// &lt;/summary&gt;
            public double SideThickness;
            /// &lt;summary&gt;
            /// 横の手すり高さ。
            /// &lt;/summary&gt;
            public double SideHeight;
            /// &lt;summary&gt;
            /// 手すりの高さ
            /// &lt;/summary&gt;
            public double HandrailHeight = 1200;
            /// &lt;summary&gt;
            /// 手すりのガラス一枚当たりの長さ
            /// &lt;/summary&gt;
            public double HandrailSpace = 1000;

            /// &lt;summary&gt;
            /// ベランダを建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;ベランダ&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;VerandaGlass&quot;);
                Result.Add(&quot;Floor&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, Domain, new Interval(-FloorLength, 0), new Interval(-FloorThickness, 0))) });
                Result.Add(Providers.GetHandrailGlassSimple(new Line(Domain.Min, -FloorLength, 0, Domain.Max, -FloorLength, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
                if (SideThickness != 0 &amp;&amp; SideHeight != 0)
                {
                    Result.Add(&quot;Side&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min, Domain.Min + SideThickness), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
                    Result.Add(&quot;Side&quot;, new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Max - SideThickness, Domain.Max), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを作成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Domain&quot;&gt;配置される壁における範囲&lt;/param&gt;
            /// &lt;param name=&quot;FloorThickness&quot;&gt;床の厚さ&lt;/param&gt;
            /// &lt;param name=&quot;FloorLength&quot;&gt;床の長さ&lt;/param&gt;
            /// &lt;param name=&quot;SideThickness&quot;&gt;横の手すりの厚さ&lt;/param&gt;
            /// &lt;param name=&quot;SideHeight&quot;&gt;横の手すりの高さ&lt;/param&gt;
            public VerandaGlassSimple(Interval Domain, double FloorThickness, double FloorLength, double SideThickness = 0, double SideHeight = 0)
            {
                this.Domain = Domain;
                this.FloorLength = FloorLength;
                this.FloorThickness = FloorThickness;
                this.SideThickness = SideThickness;
                this.SideHeight = SideHeight;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public WallAttachment Duplicate()
            {
                return new VerandaGlass(this.Domain, this.FloorThickness, this.FloorLength, this.SideThickness, this.SideHeight);
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;Veranda&quot;);
                Result.Content.Add(GetPlanPolyline().ToNurbsCurve());
                return new[] { Result };
            }

            private Polyline GetPlanPolyline()
            {
                Polyline PL = new Polyline(4);
                PL.Add(Domain.Min, 0, 0);
                PL.Add(Domain.Min, -FloorLength, 0);
                PL.Add(Domain.Max, -FloorLength, 0);
                PL.Add(Domain.Max, 0, 0);
                return PL;
            }

            public ShadowObject.ShadowSingle GetShadow(Vector3d direction, double height)
            {
                //手すりの影は省略します。
                return ShadowObject.Helper.GetShadowFromPlan(GetPlanPolyline().ToNurbsCurve(), direction, height);
            }
        }

        /// &lt;summary&gt;
        /// 幅の変化する単純なガラス手すりのベランダを示します。
        /// &lt;/summary&gt;
        public class VerandaGlassSimpleWide : WallAttachment
        {
            /// &lt;summary&gt;
            /// 配置される壁における範囲
            /// &lt;/summary&gt;
            public Interval Domain;
            /// &lt;summary&gt;
            /// 床の厚さ
            /// &lt;/summary&gt;
            public double FloorThickness;
            /// &lt;summary&gt;
            /// 床の長さ
            /// &lt;/summary&gt;
            public double FloorLength;
            /// &lt;summary&gt;
            /// 外側のベランダの配置される壁に対する範囲
            /// &lt;/summary&gt;
            public Interval DomainVeranda;
            /// &lt;summary&gt;
            /// 横の手すりの有無。Domainの最小側に配置するか。
            /// &lt;/summary&gt;
            public bool SideExist1;
            /// &lt;summary&gt;
            /// 横の手すりの有無。Domainの最大側に配置するか。
            /// &lt;/summary&gt;
            public bool SideExist2;
            /// &lt;summary&gt;
            /// 手すりの高さ
            /// &lt;/summary&gt;
            public double HandrailHeight = 1200;
            /// &lt;summary&gt;
            /// 手すりのガラス一枚当たりの長さ
            /// &lt;/summary&gt;
            public double HandrailSpace = 1000;

            /// &lt;summary&gt;
            /// ベランダを建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;ベランダ&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;VerandaGlass&quot;);

                Polyline FloorBase = new Polyline();
                FloorBase.Add(Domain.Min, 0, 0);
                FloorBase.Add(DomainVeranda.Min, -FloorLength, 0);
                FloorBase.Add(DomainVeranda.Max, -FloorLength, 0);
                FloorBase.Add(Domain.Max, 0, 0);
                FloorBase.Add(Domain.Min, 0, 0);


                Result.Add(&quot;Floor&quot;, GeneralHelper.CreateExtrusionCaped(new Curve[] { FloorBase.ToNurbsCurve() }, -Vector3d.ZAxis * FloorThickness));
                Result.Add(Providers.GetHandrailGlassSimple(new Line(DomainVeranda.Min, -FloorLength, 0, DomainVeranda.Max, -FloorLength, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
                if (SideExist1)
                {
                    Result.Add(Providers.GetHandrailGlassSimple(new Line(DomainVeranda.Min, -FloorLength, 0, Domain.Min, 0, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
                }
                if (SideExist2)
                {
                    Result.Add(Providers.GetHandrailGlassSimple(new Line(DomainVeranda.Max, -FloorLength, 0, Domain.Max, 0, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// クラスの新しいインスタンスを生成します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Domain&quot;&gt;配置される壁における範囲&lt;/param&gt;
            /// &lt;param name=&quot;DomainVeranda&quot;&gt;外側のベランダの配置される壁に対する範囲&lt;/param&gt;
            /// &lt;param name=&quot;FloorThickness&quot;&gt;床の厚さ&lt;/param&gt;
            /// &lt;param name=&quot;FloorLength&quot;&gt;床の長さ&lt;/param&gt;
            /// &lt;param name=&quot;SideExist1&quot;&gt;横の手すりの有無。Domainの最小側に配置するか。&lt;/param&gt;
            /// &lt;param name=&quot;SideExist2&quot;&gt;横の手すりの有無。Domainの最大側に配置するか。&lt;/param&gt;
            public VerandaGlassSimpleWide(Interval Domain, Interval DomainVeranda, double FloorThickness, double FloorLength, bool SideExist1 = true, bool SideExist2 = true)
            {
                this.Domain = Domain;
                this.DomainVeranda = DomainVeranda;
                this.FloorLength = FloorLength;
                this.FloorThickness = FloorThickness;
                this.SideExist1 = SideExist1;
                this.SideExist2 = SideExist2;
            }
            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public WallAttachment Duplicate()
            {
                return new VerandaGlassSimpleWide(this.Domain, this.DomainVeranda, this.FloorThickness, this.FloorLength, this.SideExist1, this.SideExist2);
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。w
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan()
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;Veranda&quot;);
                Polyline PL = new Polyline();
                if (SideExist1) { PL.Add(Domain.Min, 0, 0); }
                PL.Add(DomainVeranda.Min, -FloorLength, 0);
                PL.Add(DomainVeranda.Max, -FloorLength, 0);
                if (SideExist2) { PL.Add(Domain.Max, 0, 0); }
                Result.Content.Add(PL.ToNurbsCurve());
                return new[] { Result };
            }

        }


        /// &lt;summary&gt;
        /// 窓を示します
        /// &lt;/summary&gt;
        public interface Window
        {
            /// &lt;summary&gt;
            /// 開始点を壁における座標で指定します。
            /// &lt;/summary&gt;
            Point2d StartPoint { get; set; }
            /// &lt;summary&gt;
            /// 幅
            /// &lt;/summary&gt;
            double Width { get; set; }
            /// &lt;summary&gt;
            /// 高さ
            /// &lt;/summary&gt;
            double Height { get; set; }

            RealObject.Building GetBuilding();
            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            Window Duplicate();
            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            PlanObject.Member[] GetPlan(double WallThickness);

        }

        /// &lt;summary&gt;
        /// 単純なエレベータを示します。3Dモデルを提供しません。
        /// &lt;/summary&gt;
        public class ElevatorSimple : Window
        {
            /// &lt;summary&gt;
            /// 開始点を壁における座標で指定します。
            /// &lt;/summary&gt;
            public Point2d StartPoint { get; set; }
            /// &lt;summary&gt;
            /// ドアの幅
            /// &lt;/summary&gt;
            public double Width { get; set; }
            /// &lt;summary&gt;
            /// ドアの高さ
            /// &lt;/summary&gt;
            public double Height { get; set; }
            /// &lt;summary&gt;
            /// エレベーターの幅
            /// &lt;/summary&gt;
            public double ElevatorWidth { get; set; }
            /// &lt;summary&gt;
            /// エレベーターの長さ
            /// &lt;/summary&gt;
            public double ElevatorLength { get; set; }
            /// &lt;summary&gt;
            /// エレベーターの高さ。現時点では利用されていません。
            /// &lt;/summary&gt;
            public double ElevatorHeight { get; set; }
            /// &lt;summary&gt;
            /// エレベーターの配置される向きを示します。
            /// &lt;/summary&gt;
            public bool IsFront = true;

            /// &lt;summary&gt;
            /// コンストラクター。引数の詳細はメンバ変数で確認してください。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;StartPoint&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;Width&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;IsFrone&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;ElevatorWidth&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;ElevatorLength&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;ElevatorHeight&quot;&gt;&lt;/param&gt;
            public ElevatorSimple(Point2d StartPoint, double Width, double Height, bool IsFrone, double ElevatorWidth, double ElevatorLength, double ElevatorHeight)
            {
                this.StartPoint = StartPoint;
                this.Width = Width;
                this.Height = Height;
                this.IsFront = IsFrone;
                this.ElevatorWidth = ElevatorWidth;
                this.ElevatorLength = ElevatorLength;
                this.ElevatorHeight = ElevatorHeight;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Window Duplicate()
            {
                ElevatorSimple Result = new ElevatorSimple(StartPoint, Width, Height, IsFront, ElevatorWidth, ElevatorLength, ElevatorHeight);
                return Result;
            }

            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;Elevator&quot;);

                if (IsFront)
                {
                    Result.Add(&quot;Door&quot;, Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X, StartPoint.X + Width / 2), new Interval(-100, 0), new Interval(StartPoint.Y, StartPoint.Y + Height))));
                    Result.Add(&quot;Door&quot;, Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X + Width / 2, StartPoint.X + Width), new Interval(-100, 0), new Interval(StartPoint.Y, StartPoint.Y + Height))));
                }
                else
                {
                    Result.Add(&quot;Door&quot;, Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X, StartPoint.X + Width / 2), new Interval(0, 100), new Interval(StartPoint.Y, StartPoint.Y + Height))));
                    Result.Add(&quot;Door&quot;, Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X + Width / 2, StartPoint.X + Width), new Interval(0, 100), new Interval(StartPoint.Y, StartPoint.Y + Height))));
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan(double WallThickness)
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;Elevator&quot;);
                if (IsFront)
                {
                    Point3d A = new Point3d(StartPoint.X + Width / 2 - ElevatorWidth / 2, -WallThickness * 1.5, 0);
                    Point3d B = A + Vector3d.XAxis * ElevatorWidth;
                    Point3d C = A - Vector3d.YAxis * ElevatorLength;
                    Point3d D = B - Vector3d.YAxis * ElevatorLength;
                    Point3d E = A + Vector3d.XAxis * ElevatorWidth / 2 - Vector3d.YAxis * ElevatorLength / 2;
                    Result.Content.Add(Providers.GetRectangle3d(A, ElevatorWidth, ElevatorLength));
                    Result.Content.Add(new Line(A, A + Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
                    Result.Content.Add(new Line(B, B - Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
                    Result.Content.Add(new Line(C, C + Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
                    Result.Content.Add(new Line(D, D - Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());

                    Curve[] Cvs = GetEVText();
                    double ScaleFactor = Math.Min(ElevatorWidth / 3 / 3.0, ElevatorLength / 3 / 2);
                    foreach (Curve cv in Cvs)
                    {
                        cv.Rotate(Math.PI, Vector3d.ZAxis, Point3d.Origin);
                        cv.Scale(ScaleFactor);
                        cv.Translate((Vector3d)E);
                        Result.Content.Add(cv);
                    }

                }
                else
                {
                    Point3d A = new Point3d(StartPoint.X + Width / 2 - ElevatorWidth / 2, WallThickness * 1.5, 0);
                    Point3d B = A + Vector3d.XAxis * ElevatorWidth;
                    Point3d C = A + Vector3d.YAxis * ElevatorLength;
                    Point3d D = B + Vector3d.YAxis * ElevatorLength;
                    Point3d E = A + Vector3d.XAxis * ElevatorWidth / 2 + Vector3d.YAxis * ElevatorLength / 2;
                    Result.Content.Add(Providers.GetRectangle3d(A, ElevatorWidth, ElevatorLength));
                    Result.Content.Add(new Line(A, A + Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
                    Result.Content.Add(new Line(B, B - Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
                    Result.Content.Add(new Line(C, C + Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
                    Result.Content.Add(new Line(D, D - Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());

                    Curve[] Cvs = GetEVText();
                    double ScaleFactor = Math.Min(ElevatorWidth / 3 / 3.0, ElevatorLength / 3 / 2);
                    foreach (Curve cv in Cvs)
                    {
                        cv.Scale(ScaleFactor);
                        cv.Translate((Vector3d)E);
                        Result.Content.Add(cv);
                    }
                }
                return new[] { Result };

            }

            /// &lt;summary&gt;
            /// エレベータを示すEVの文字を線の集合で与えます。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static Curve[] GetEVText()
            {
                var pls = new List&lt;Curve&gt;();
                {
                    Polyline pl = new Polyline();
                    pl.Add(-0.5, -1, 0);
                    pl.Add(-1.5, -1, 0);
                    pl.Add(-1.5, 1, 0);
                    pl.Add(-0.5, 1, 0);
                    pls.Add(pl.ToNurbsCurve());
                }
                {
                    Polyline pl = new Polyline();
                    pl.Add(-1.5, 0, 0);
                    pl.Add(-0.5, 0, 0);
                    pls.Add(pl.ToNurbsCurve());
                }

                {
                    Polyline pl = new Polyline();
                    pl.Add(0.5, 1, 0);
                    pl.Add(1, -1, 0);
                    pl.Add(1.5, 1, 0);
                    pls.Add(pl.ToNurbsCurve());
                }
                return pls.ToArray();
            }
        }

        /// &lt;summary&gt;
        /// 単純な扉を示します。
        /// &lt;/summary&gt;
        public class DoorSimple : Window
        {
            /// &lt;summary&gt;
            /// 開始点を壁における座標で指定します。
            /// &lt;/summary&gt;
            public Point2d StartPoint { get; set; }
            /// &lt;summary&gt;
            /// 扉の幅を示します。
            /// &lt;/summary&gt;
            public double Width { get; set; }
            /// &lt;summary&gt;
            /// 扉の高さを示します。
            /// &lt;/summary&gt;
            public double Height { get; set; }
            /// &lt;summary&gt;
            /// 扉の方向と向きを示します。
            /// &lt;/summary&gt;
            public Side OpenSide = Side.FrontRight;

            /// &lt;summary&gt;
            /// コンストラクター。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;StartPoint&quot;&gt;開始点を壁における座標で指定します&lt;/param&gt;
            /// &lt;param name=&quot;Width&quot;&gt;扉の幅&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;扉の高さ&lt;/param&gt;
            /// &lt;param name=&quot;OpenSide&quot;&gt;扉の方向と向き&lt;/param&gt;
            public DoorSimple(Point2d StartPoint, double Width, double Height, Side OpenSide)
            {
                this.StartPoint = StartPoint;
                this.Width = Width;
                this.Height = Height;
                this.OpenSide = OpenSide;
            }
            /// &lt;summary&gt;
            /// 扉の方向と向き
            /// &lt;/summary&gt;
            public enum Side
            {
                /// &lt;summary&gt;
                /// 正面側右向き
                /// &lt;/summary&gt;
                FrontRight,
                /// &lt;summary&gt;
                /// 正面側左向き
                /// &lt;/summary&gt;
                FrontLeft,
                /// &lt;summary&gt;
                /// 背面側右向き
                /// &lt;/summary&gt;
                BackRight,
                /// &lt;summary&gt;
                /// 背面側左向き
                /// &lt;/summary&gt;
                BackLeft
                    
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Window Duplicate()
            {
                DoorSimple Result = new DoorSimple(StartPoint, Width, Height, OpenSide);
                return Result;
            }

            /// &lt;summary&gt;
            /// 扉を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;扉&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Door = new RealObject.Building(&quot;Door&quot;);

                Polyline PL = new Polyline(5);
                PL.Add(StartPoint.X, 0, StartPoint.Y);
                PL.Add(StartPoint.X + Width, 0, StartPoint.Y);
                PL.Add(StartPoint.X + Width, 0, StartPoint.Y + Height);
                PL.Add(StartPoint.X, 0, StartPoint.Y + Height);
                PL.Add(StartPoint.X, 0, StartPoint.Y);

                Door.Add(&quot;Body&quot;, Brep.CreatePlanarBreps(PL.ToNurbsCurve()));

                return Door;
            }
            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan(double WallThickness)
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;Door&quot;);
                switch (this.OpenSide)
                {
                    case Side.FrontLeft:
                        Result.Content.Add(new Line(StartPoint.X, 0, 0, StartPoint.X, -Width, 0).ToNurbsCurve());
                        Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X, 0, 0), Width), new Interval(-Math.PI / 2, 0)).ToNurbsCurve());
                        return new[] { Result };
                    case Side.FrontRight:
                        Result.Content.Add(new Line(StartPoint.X + Width, 0, 0, StartPoint.X + Width, -Width, 0).ToNurbsCurve());
                        Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X + Width, 0, 0), Width), new Interval(-Math.PI, -Math.PI / 2)).ToNurbsCurve());
                        return new[] { Result };
                    case Side.BackLeft:
                        Result.Content.Add(new Line(StartPoint.X, WallThickness, 0, StartPoint.X, WallThickness + Width, 0).ToNurbsCurve());
                        Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X, WallThickness, 0), Width), new Interval(0, Math.PI / 2)).ToNurbsCurve());
                        return new[] { Result };
                    case Side.BackRight:
                        Result.Content.Add(new Line(StartPoint.X + Width, WallThickness, 0, StartPoint.X + Width, WallThickness + Width, 0).ToNurbsCurve());
                        Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X + Width, WallThickness, 0), Width), new Interval(Math.PI / 2, Math.PI)).ToNurbsCurve());
                        return new[] { Result };
                    default:
                        return new[] { Result };
                }
            }


        }

        /// &lt;summary&gt;
        /// はめ殺しまたは片引きのガラス扉を示します。
        /// &lt;/summary&gt;
        public class WindowGlassSimpleSingle : Window
        {
            /// &lt;summary&gt;
            /// 開始点を壁における座標で指定します。
            /// &lt;/summary&gt;
            public Point2d StartPoint { get; set; }
            /// &lt;summary&gt;
            /// 扉の幅を示します。
            /// &lt;/summary&gt;
            public double Width { get; set; }
            /// &lt;summary&gt;
            /// 扉の高さを示します。
            /// &lt;/summary&gt;
            public double Height { get; set; }

            /// &lt;summary&gt;
            /// ガラス扉のフレーム幅を示します。
            /// &lt;/summary&gt;
            public double FrameWidth = 30;
            /// &lt;summary&gt;
            /// ガラス扉のフレーム厚さを示します。
            /// &lt;/summary&gt;
            public double FrameThickness = 30;
            /// &lt;summary&gt;
            /// ガラスの厚さを示します。住宅用は通常2〜4mmといった所です。
            /// &lt;/summary&gt;
            public double GlassThickness = 5;

            /// &lt;summary&gt;
            /// ガラス扉を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;ガラス扉&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;WindowSingle&quot;);
                Brep[] breps = new Brep[2];

                Providers.GetGlassSimple(Width, Height, FrameWidth, FrameThickness, GlassThickness, out breps[0], out breps[1]);
                Result.Add(&quot;Glass&quot;, new Brep[] { breps[1] });
                Result.Add(&quot;Frame&quot;, new Brep[] { breps[0] });

                Result.Transform(Transform.Translation(StartPoint.X, FrameThickness, StartPoint.Y));

                return Result;
            }

            /// &lt;summary&gt;
            /// コンストラクター。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;StartPoint&quot;&gt;開始点を壁における座標で指定します。&lt;/param&gt;
            /// &lt;param name=&quot;Width&quot;&gt;扉の幅&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;扉の高さ&lt;/param&gt;
            public WindowGlassSimpleSingle(Point2d StartPoint, double Width, double Height)
            {
                this.StartPoint = StartPoint;
                this.Width = Width;
                this.Height = Height;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Window Duplicate()
            {
                return new WindowGlassSimpleSingle(this.StartPoint, this.Width, this.Height)
                {
                    FrameWidth = this.FrameWidth,
                    FrameThickness = this.FrameThickness,
                    GlassThickness = this.GlassThickness
                };
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan(double WallThickness)
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;WindowSingle&quot;);
                Result.Content.Add(new Line(StartPoint.X, 0, 0, StartPoint.X, WallThickness, 0).ToNurbsCurve());
                Result.Content.Add(new Line(StartPoint.X + Width, 0, 0, StartPoint.X + Width, WallThickness, 0).ToNurbsCurve());
                return new[] { Result };
            }
        }

        /// &lt;summary&gt;
        /// 引き違いのガラス扉を示します。
        /// &lt;/summary&gt;
        public class WindowGlassSimpleDouble : Window
        {
            /// &lt;summary&gt;
            /// 開始点を壁における座標で指定します。
            /// &lt;/summary&gt;
            public Point2d StartPoint { get; set; }
            /// &lt;summary&gt;
            /// 扉全体の幅を示します。
            /// &lt;/summary&gt;
            public double Width { get; set; }
            /// &lt;summary&gt;
            /// 扉の高さを示します。
            /// &lt;/summary&gt;
            public double Height { get; set; }

            /// &lt;summary&gt;
            /// ガラスフレームの幅を示します。
            /// &lt;/summary&gt;
            public double FrameWidth = 30;
            /// &lt;summary&gt;
            /// ガラスフレームの厚さを示します。
            /// &lt;/summary&gt;
            public double FrameThickness = 30;
            /// &lt;summary&gt;
            /// ガラスの厚さを示します。
            /// &lt;/summary&gt;
            public double GlassThickness = 5;

            /// &lt;summary&gt;
            /// ガラス扉を建築として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;ガラス扉&lt;/returns&gt;
            public RealObject.Building GetBuilding()
            {
                RealObject.Building Result = new RealObject.Building(&quot;WindowDouble&quot;);
                Brep[] breps = new Brep[2];

                Providers.GetGlassSimple(Width / 2.0, Height, FrameWidth, FrameThickness, GlassThickness, out breps[0], out breps[1]);
                Result.Add(&quot;Glass&quot;, new Brep[] { breps[1] });
                Result.Add(&quot;Glass&quot;, GeneralHelper.TranslateBreps(new Brep[] { breps[1] }, new Point3d(Width / 2.0, FrameThickness, 0)));
                Result.Add(&quot;Frame&quot;, new Brep[] { breps[0] });
                Result.Add(&quot;Frame&quot;, GeneralHelper.TranslateBreps(new Brep[] { breps[0] }, new Point3d(Width / 2.0, FrameThickness, 0)));

                Result.Transform(Transform.Translation(StartPoint.X, FrameThickness, StartPoint.Y));

                return Result;
            }

            /// &lt;summary&gt;
            /// コンストラクター。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;StartPoint&quot;&gt;開始点を壁における座標で指定します。&lt;/param&gt;
            /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
            public WindowGlassSimpleDouble(Point2d StartPoint, double Width, double Height)
            {
                this.StartPoint = StartPoint;
                this.Width = Width;
                this.Height = Height;
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Window Duplicate()
            {
                return new WindowGlassSimpleDouble(this.StartPoint, this.Width, this.Height)
                {
                    FrameWidth = this.FrameWidth,
                    FrameThickness = this.FrameThickness,
                    GlassThickness = this.GlassThickness
                };
            }

            /// &lt;summary&gt;
            /// 平面図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public PlanObject.Member[] GetPlan(double WallThickness)
            {
                PlanObject.Member Result = new PlanObject.Member(&quot;WindowDouble&quot;);
                Result.Content.Add(new Line(StartPoint.X, 0, 0, StartPoint.X, WallThickness, 0).ToNurbsCurve());
                Result.Content.Add(new Line(StartPoint.X + Width, 0, 0, StartPoint.X + Width, WallThickness, 0).ToNurbsCurve());
                Result.Content.Add(new Line(StartPoint.X, WallThickness / 3, 0, StartPoint.X + Width * 3 / 4, WallThickness / 3, 0).ToNurbsCurve());
                Result.Content.Add(new Line(StartPoint.X + Width / 4, WallThickness * 2 / 3, 0, StartPoint.X + Width, WallThickness * 2 / 3, 0).ToNurbsCurve());
                Result.Content.Add(new Line(StartPoint.X + Width / 2, -WallThickness / 2, 0, StartPoint.X + Width / 2, WallThickness * 3 / 2, 0).ToNurbsCurve());
                return new[] { Result };
            }
        }
    }
#endregion

#region ..\CellObject.cs

    /// &lt;summary&gt;
    /// セル・オートマトンに関連するオブジェクトを含みます。
    /// &lt;/summary&gt;
    public class CellObject
    {
        //Magic number
        // 0 : No object.
        // -1: No result. This should not be used in IBoxel.
        // -2: Out of range.

        /// &lt;summary&gt;
        /// 3次元グリッドを示します。
        /// &lt;/summary&gt;
        public interface IBoxel
        {
            /// &lt;summary&gt;
            /// 指定した大きさで初期化します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;x方向の個数&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;y方向の個数&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;z方向の個数&lt;/param&gt;
            void Init(int x, int y, int z);
            /// &lt;summary&gt;
            /// 指定した座標の周囲のセルに関する情報を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;returns&gt;周囲のセルに関する情報&lt;/returns&gt;
            NeighborStatus GetNeighbor(int x, int y, int z);
            /// &lt;summary&gt;
            /// セル・オートマトンに関するルールを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rule&quot;&gt;ルール&lt;/param&gt;
            void Apply(IRule rule);
            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            IBoxel Duplicate();
        }

        /// &lt;summary&gt;
        /// 通常の3次元グリッドを示します。
        /// &lt;/summary&gt;
        public class Boxel : IBoxel
        {
            private int[,,] Content;
            /// &lt;summary&gt;
            /// グリッドのX方向の大きさ(幅)を示します。
            /// &lt;/summary&gt;
            public int X { get { return Content.GetLength(0) - 2; } }
            /// &lt;summary&gt;
            /// グリッドのY方向の大きさ(奥行)を示します。
            /// &lt;/summary&gt;
            public int Y { get { return Content.GetLength(1) - 2; } }
            /// &lt;summary&gt;
            /// グリッドのZ方向の大きさ(高さ)を示します。
            /// &lt;/summary&gt;
            public int Z { get { return Content.GetLength(2) - 2; } }

            /// &lt;summary&gt;
            /// 指定した大きさで初期化します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;グリッドのX方向の大きさ(幅)&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;グリッドのY方向の大きさ(奥行)&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;グリッドのZ方向の大きさ(高さ)&lt;/param&gt;
            public void Init(int x, int y, int z)
            {
                Content = new int[x + 2, y + 2, z + 2];
                for (int cntx = 0; cntx &lt; x + 2; cntx++)
                {
                    for (int cnty = 0; cnty &lt; y + 2; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; z + 2; cntz++)
                        {
                            if (cntx &gt;= 1 &amp;&amp; cnty &gt;= 1 &amp;&amp; cntz &gt;= 1 &amp;&amp; cntx &lt; 1 + x &amp;&amp; cnty &lt; 1 + y &amp;&amp; cntz &lt; 1 + z)
                            {
                                Content[cntx, cnty, cntz] = 0;
                            }
                            else
                            {
                                Content[cntx, cnty, cntz] = -2;
                            }

                        }
                    }
                }
            }

            /// &lt;summary&gt;
            /// 指定した座標の周囲のセルに関する情報を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;returns&gt;周囲のセルに関する情報&lt;/returns&gt;
            public NeighborStatus GetNeighbor(int x, int y, int z)
            {
                NeighborStatus result = new NeighborStatus();
                int floor = z;
                result.LowerNeighbor = new int[] { Content[x, y, floor], Content[x + 1, y, floor], Content[x + 2, y, floor]
                        , Content[x, y + 1, floor], Content[x + 2, y + 1, floor]
                        , Content[x, y + 2, floor], Content[x + 1, y + 2, floor], Content[x + 2, y + 2, floor] };
                result.Lower = Content[x + 1, y + 1, floor];
                floor++;
                result.Neighbor = new int[] { Content[x, y, floor], Content[x + 1, y, floor], Content[x + 2, y, floor]
                        , Content[x, y + 1, floor], Content[x + 2, y + 1, floor]
                        , Content[x, y + 2, floor], Content[x + 1, y + 2, floor], Content[x + 2, y + 2, floor] };
                result.Self = Content[x + 1, y + 1, floor];
                floor++;
                result.UpperNeighbor = new int[] { Content[x, y, floor], Content[x + 1, y, floor], Content[x + 2, y, floor]
                        , Content[x, y + 1, floor], Content[x + 2, y + 1, floor]
                        , Content[x, y + 2, floor], Content[x + 1, y + 2, floor], Content[x + 2, y + 2, floor] };
                result.Upper = Content[x + 1, y + 1, floor];
                return result;
            }

            /// &lt;summary&gt;
            /// 指定した座標の値を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;returns&gt;値&lt;/returns&gt;
            public int GetValue(int x, int y, int z)
            {
                return Content[x + 1, y + 1, z + 1];
            }
            /// &lt;summary&gt;
            /// 指定した座標の値を設定します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;param name=&quot;Value&quot;&gt;値&lt;/param&gt;
            public void SetValue(int x, int y, int z, int Value)
            {
                if (Value != -1)
                {
                    Content[x + 1, y + 1, z + 1] = Value;
                }
            }

            /// &lt;summary&gt;
            /// セル・オートマトンに関するルールを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rule&quot;&gt;ルール&lt;/param&gt;
            public void Apply(IRule rule)
            {
                Boxel Origin = (Boxel)this.Duplicate();
                for (int cntx = 0; cntx &lt; X; cntx++)
                {
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; Z; cntz++)
                        {
                            this.SetValue(cntx, cnty, cntz, rule.GetStatus(Origin.GetNeighbor(cntx, cnty, cntz), cntx, cnty, cntz));
                        }
                    }
                }
            }

            /// &lt;summary&gt;
            /// 指定した大きさで初期化します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;グリッドのX方向の大きさ(幅)&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;グリッドのY方向の大きさ(奥行)&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;グリッドのZ方向の大きさ(高さ)&lt;/param&gt;
            public Boxel(int x, int y, int z)
            {
                this.Init(x, y, z);
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public IBoxel Duplicate()
            {
                Boxel Result = new Boxel(X, Y, Z);
                for (int cntx = 0; cntx &lt; X; cntx++)
                {
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; Z; cntz++)
                        {
                            Result.SetValue(cntx, cnty, cntz, this.GetValue(cntx, cnty, cntz));
                        }
                    }
                }
                return Result;
            }
        }

        /// &lt;summary&gt;
        /// ハニカムグリッドを示します。
        /// &lt;/summary&gt;
        public class Honeycomb : IBoxel
        {
            private int[,,] Content;
            /// &lt;summary&gt;
            /// グリッドのX方向の大きさ(幅)を示します。
            /// &lt;/summary&gt;
            public int X { get { return Content.GetLength(0) - 2; } }
            /// &lt;summary&gt;
            /// グリッドのY方向の大きさ(奥行)を示します。
            /// &lt;/summary&gt;
            public int Y { get { return Content.GetLength(1) - 2; } }
            /// &lt;summary&gt;
            /// グリッドのZ方向の大きさ(高さ)を示します。
            /// &lt;/summary&gt;
            public int Z { get { return Content.GetLength(2) - 2; } }

            /// &lt;summary&gt;
            /// 指定した大きさで初期化します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;グリッドのX方向の大きさ(幅)&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;グリッドのY方向の大きさ(奥行)&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;グリッドのZ方向の大きさ(高さ)&lt;/param&gt;
            public void Init(int x, int y, int z)
            {
                Content = new int[x + 2, y + 2, z + 2];
                for (int cntx = 0; cntx &lt; x + 2; cntx++)
                {
                    for (int cnty = 0; cnty &lt; y + 2; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; z + 2; cntz++)
                        {
                            if (cntx &gt;= 1 &amp;&amp; cnty &gt;= 1 &amp;&amp; cntz &gt;= 1 &amp;&amp; cntx &lt; 1 + x &amp;&amp; cnty &lt; 1 + y &amp;&amp; cntz &lt; 1 + z)
                            {
                                Content[cntx, cnty, cntz] = 0;
                            }
                            else
                            {
                                Content[cntx, cnty, cntz] = -2;
                            }

                        }
                    }
                }
            }

            /// &lt;summary&gt;
            /// 指定した座標の周囲のセルに関する情報を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;returns&gt;周囲のセルに関する情報&lt;/returns&gt;
            public NeighborStatus GetNeighbor(int x, int y, int z)
            {
                NeighborStatus result = new NeighborStatus();
                int shift = y % 2;
                int floor = z;
                result.LowerNeighbor = new int[] {Content[x + 1+shift, y + 2, floor],Content[x + 2, y + 1, floor],Content[x + 1+shift, y, floor]
                        , Content[x+shift, y, floor], Content[x, y + 1, floor], Content[x+shift, y + 2, floor]
                          };
                result.Lower = Content[x + 1, y + 1, floor];
                floor++;
                result.Neighbor = new int[] { Content[x + 1+shift, y + 2, floor],Content[x + 2, y + 1, floor],Content[x + 1+shift, y, floor]
                        , Content[x+shift, y, floor], Content[x, y + 1, floor], Content[x+shift, y + 2, floor] };
                result.Self = Content[x + 1, y + 1, floor];
                floor++;
                result.UpperNeighbor = new int[] { Content[x + 1+shift, y + 2, floor],Content[x + 2, y + 1, floor],Content[x + 1+shift, y, floor]
                        , Content[x+shift, y, floor], Content[x, y + 1, floor], Content[x+shift, y + 2, floor] };
                result.Upper = Content[x + 1, y + 1, floor];
                return result;
            }

            /// &lt;summary&gt;
            /// 指定した座標の値を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;returns&gt;値&lt;/returns&gt;
            public int GetValue(int x, int y, int z)
            {
                return Content[x + 1, y + 1, z + 1];
            }

            /// &lt;summary&gt;
            /// 指定した座標の値を設定します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;param name=&quot;Value&quot;&gt;値&lt;/param&gt;
            public void SetValue(int x, int y, int z, int Value)
            {
                if (Value != -1)
                {
                    Content[x + 1, y + 1, z + 1] = Value;
                }
            }

            /// &lt;summary&gt;
            /// セル・オートマトンに関するルールを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rule&quot;&gt;ルール&lt;/param&gt;
            public void Apply(IRule rule)
            {
                Honeycomb Origin = (Honeycomb)this.Duplicate();
                for (int cntx = 0; cntx &lt; X; cntx++)
                {
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; Z; cntz++)
                        {
                            this.SetValue(cntx, cnty, cntz, rule.GetStatus(Origin.GetNeighbor(cntx, cnty, cntz), cntx, cnty, cntz));
                        }
                    }
                }
            }

            /// &lt;summary&gt;
            /// 指定した大きさで初期化します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;グリッドのX方向の大きさ(幅)&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;グリッドのY方向の大きさ(奥行)&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;グリッドのZ方向の大きさ(高さ)&lt;/param&gt;
            public Honeycomb(int x, int y, int z)
            {
                this.Init(x, y, z);
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public IBoxel Duplicate()
            {
                Honeycomb Result = new Honeycomb(X, Y, Z);
                for (int cntx = 0; cntx &lt; X; cntx++)
                {
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; Z; cntz++)
                        {
                            Result.SetValue(cntx, cnty, cntz, this.GetValue(cntx, cnty, cntz));
                        }
                    }
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 簡単に形状を3Dモデルで取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;BuildingHeight&quot;&gt;セルの高さ&lt;/param&gt;
            /// &lt;returns&gt;3Dモデル&lt;/returns&gt;
            public RealObject.Building GetBuildingSimple(double BuildingHeight = 1.0)
            {
                RealObject.Building Result = new RealObject.Building(&quot;HoneycombBuilding&quot;);

                Brep[] HexagonBase = GeneralHelper.CreateExtrusionCaped(new[] { GetHexagon().ToNurbsCurve() }, new Vector3d(0, 0, BuildingHeight));

                for (int cntx = 0; cntx &lt; X; cntx++)
                {
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntz = 0; cntz &lt; Z; cntz++)
                        {
                            int tmpnum = GetValue(cntx, cnty, cntz);
                            if (tmpnum &gt; 0)
                            {
                                RealObject.Member ToAdd = new RealObject.Member(&quot;Type&quot; + tmpnum);
                                Brep[] NewHouse = GeneralHelper.TranslateBreps(HexagonBase, GetCenterPoint(cntx, cnty, BuildingHeight * cntz));
                                ToAdd.Content = NewHouse;
                                Result.Add(ToAdd);
                            }
                        }
                    }
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 簡単な図を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;図&lt;/returns&gt;
            public PlanObject.Building GetPlanSimple()
            {
                PlanObject.Building Result = new PlanObject.Building(&quot;HoneycombBuilding&quot;);
                Curve HexagonBase = GetHexagon().ToNurbsCurve();
                for (int cntz = 0; cntz &lt; Z; cntz++)
                {
                    PlanObject.Floor FloorTmp = new PlanObject.Floor(&quot;F&quot; + cntz);
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntx = 0; cntx &lt; X; cntx++)
                        {
                            int tmpnum = GetValue(cntx, cnty, cntz);
                            if (tmpnum &gt; 0)
                            {
                                PlanObject.Member item = new PlanObject.Member(&quot;Type&quot; + tmpnum);
                                Curve cv = (Curve)HexagonBase.Duplicate();
                                cv.Translate((Vector3d)GetCenterPoint(cntx, cnty, 0));
                                item.Content.Add(cv);
                                FloorTmp.Content.Add(item);
                            }
                        }
                    }
                    Result.Content.Add(FloorTmp);
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 特定の値を数えます。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;target&quot;&gt;値&lt;/param&gt;
            /// &lt;returns&gt;値を持つセルの数&lt;/returns&gt;
            public int CountCellType(int target)
            {
                int Result = 0;
                for (int cntz = 0; cntz &lt; Z; cntz++)
                {
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntx = 0; cntx &lt; X; cntx++)
                        {
                            if (GetValue(cntx, cnty, cntz) == target) Result++;
                        }
                    }
                }
                return Result;

            }

            /// &lt;summary&gt;
            /// 統計情報を文字を示します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;統計情報&lt;/returns&gt;
            public string GetStatistics()
            {
                String Result = &quot;&quot;;
                for (int cntz = 0; cntz &lt; Z; cntz++)
                {
                    int[] FloorResult = new int[5];
                    for (int i = 0; i &lt; FloorResult.GetLength(0); i++)
                    {
                        FloorResult[i] = 0;
                    }
                    for (int cnty = 0; cnty &lt; Y; cnty++)
                    {
                        for (int cntx = 0; cntx &lt; X; cntx++)
                        {
                            FloorResult[GetValue(cntx, cnty, cntz)]++;
                        }
                    }
                    for (int i = 0; i &lt; FloorResult.GetLength(0); i++)
                    {
                        Result += FloorResult[i] + &quot;,&quot;;
                    }
                    Result += &quot;\n\r&quot;;
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 指定したグリッドの中心が位置する座標を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;グリッドのX方向の番号&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;グリッドのY方向の番号&lt;/param&gt;
            /// &lt;returns&gt;座標&lt;/returns&gt;
            public static Point2d GetCenterPoint(int x, int y)
            {
                return new Point2d(Math.Cos(Math.PI / 6.0) * (x * 2 + (y % 2)), (1 + Math.Cos(Math.PI / 3.0)) * y);
            }

            /// &lt;summary&gt;
            /// 指定したグリッドの中心が位置する座標に高さを含めて取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;x&quot;&gt;グリッドのX方向の番号&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;グリッドのY方向の番号&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
            /// &lt;returns&gt;座標&lt;/returns&gt;
            public static Point3d GetCenterPoint(int x, int y, double Height)
            {
                return new Point3d(Math.Cos(Math.PI / 6.0) * (x * 2 + (y % 2)), (1 + Math.Cos(Math.PI / 3.0)) * y, Height);
            }

            /// &lt;summary&gt;
            /// グリッドの中心から見た頂点の座標を示します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;cnt&quot;&gt;頂点の番号&lt;/param&gt;
            /// &lt;returns&gt;座標&lt;/returns&gt;
            public static Vector2d GetVertex(int cnt)
            {
                return new Vector2d(Math.Sin(Math.PI / 3.0 * cnt), Math.Cos(Math.PI / 3.0 * cnt));
            }

            /// &lt;summary&gt;
            /// 六角形を得ます。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;六角形を示すポリライン&lt;/returns&gt;
            public static Polyline GetHexagon()
            {
                Polyline result = new Polyline();
                for (int i = 0; i &lt;= 6; i++)
                {
                    Vector2d vrx = GetVertex(i);
                    result.Add(vrx.X, vrx.Y, 0);
                }
                return result;
            }
        }

        /// &lt;summary&gt;
        /// セル周囲の状態を示します。
        /// &lt;/summary&gt;
        public class NeighborStatus
        {
            /// &lt;summary&gt;
            /// セル近隣の状態
            /// &lt;/summary&gt;
            public int[] Neighbor;
            /// &lt;summary&gt;
            /// セル自身の状態
            /// &lt;/summary&gt;
            public int Self;
            /// &lt;summary&gt;
            /// 上層におけるセル近隣の状態
            /// &lt;/summary&gt;
            public int[] UpperNeighbor;
            /// &lt;summary&gt;
            /// 上層にあるセルの状態
            /// &lt;/summary&gt;
            public int Upper;
            /// &lt;summary&gt;
            /// 下層におけるセル近隣の状態
            /// &lt;/summary&gt;
            public int[] LowerNeighbor;
            /// &lt;summary&gt;
            /// 下層にあるセルの状態
            /// &lt;/summary&gt;
            public int Lower;

            /// &lt;summary&gt;
            /// 周囲のセルの中で該当する値がいくつあるかを計測します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;target&quot;&gt;値&lt;/param&gt;
            /// &lt;returns&gt;個数&lt;/returns&gt;
            public int CountNeighbor(int target)
            {
                int result = 0;
                for (int i = 0; i &lt; Neighbor.GetLength(0); i++)
                {
                    if (Neighbor[i] == target)
                    {
                        result++;
                    }
                }
                return result;
            }

            /// &lt;summary&gt;
            /// 周囲のセルを数値による指定で取得します。-1〜1までの値を指定してください。
            /// それ以外の場合には0とみなします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;cnt&quot;&gt;相対階層&lt;/param&gt;
            /// &lt;returns&gt;周囲の値&lt;/returns&gt;
            public int[] GetNeighborByFloor(int cnt)
            {
                if (cnt == -1) { return LowerNeighbor; }
                else if (cnt == 1) { return UpperNeighbor; }
                else { return Neighbor; }
            }

            /// &lt;summary&gt;
            /// 自分または上下のセルの値を取得します。
            /// -1〜1までの値で指定してください。
            /// それ以外の場合には0とみなします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;cnt&quot;&gt;相対階層&lt;/param&gt;
            /// &lt;returns&gt;値&lt;/returns&gt;
            public int GetSelfByFloor(int cnt)
            {
                if (cnt == -1) { return Lower; }
                else if (cnt == 1) { return Upper; }
                else { return Self; }
            }

            /// &lt;summary&gt;
            /// 階層を指定し、周囲のセルを設定します。
            /// -1〜1までの値で指定してください。
            /// それ以外の場合には0とみなします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;cnt&quot;&gt;相対階層&lt;/param&gt;
            /// &lt;param name=&quot;value&quot;&gt;周囲の値&lt;/param&gt;
            public void SetNeighborByFloor(int cnt, int[] value)
            {
                if (cnt == -1) { LowerNeighbor = value; }
                else if (cnt == 1) { UpperNeighbor = value; }
                else { Neighbor = value; }
            }

            /// &lt;summary&gt;
            /// 自分または上下のセルの値を設定します。
            /// -1〜1までの値で指定してください。
            /// それ以外の場合には0とみなします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;cnt&quot;&gt;相対階層&lt;/param&gt;
            /// &lt;param name=&quot;value&quot;&gt;値&lt;/param&gt;
            public void SetSelfByFloor(int cnt, int value)
            {
                if (cnt == -1) { Lower = value; }
                else if (cnt == 1) { Upper = value; }
                else { Self = value; }
            }

            /// &lt;summary&gt;
            ///  二つの階層の値を入れ替えます。
            /// -1〜1までの値で指定してください。
            /// それ以外の場合には0とみなします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;A&quot;&gt;相対階層A&lt;/param&gt;
            /// &lt;param name=&quot;B&quot;&gt;相対階層B&lt;/param&gt;
            public void SwapFloor(int A, int B)
            {
                int[] ANb = GetNeighborByFloor(A);
                int ASf = GetSelfByFloor(A);
                SetNeighborByFloor(A, GetNeighborByFloor(B));
                SetSelfByFloor(A, GetSelfByFloor(B));
                SetNeighborByFloor(B, ANb);
                SetSelfByFloor(B, ASf);
            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public NeighborStatus Duplicate()
            {
                NeighborStatus Result = new NeighborStatus();
                Result.Neighbor = this.Neighbor;
                Result.Self = this.Self;
                Result.UpperNeighbor = this.UpperNeighbor;
                Result.Upper = this.Upper;
                Result.LowerNeighbor = this.LowerNeighbor;
                Result.Lower = this.Lower;

                return Result;
            }
        }

        /// &lt;summary&gt;
        /// ルールを示します。
        /// &lt;/summary&gt;
        public interface IRule
        {
            /// &lt;summary&gt;
            /// ルールを設定するパラメーター
            /// &lt;/summary&gt;
            int[] Paramater { get; set; }
            /// &lt;summary&gt;
            /// 周囲の状態と座標に応じて、ルールに基づく値を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;neighbor&quot;&gt;周囲の状態&lt;/param&gt;
            /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
            /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
            /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
            /// &lt;returns&gt;値&lt;/returns&gt;
            int GetStatus(NeighborStatus neighbor, int x, int y, int z);
        }

        /// &lt;summary&gt;
        /// 基本的なルールを含みます。
        /// &lt;/summary&gt;
        public class Rules
        {
            /// &lt;summary&gt;
            /// 周囲のセルで指定した値が数え、指定範囲内にある場合に値を変化させます。
            /// 数える値は複数指定できます。
            /// &lt;/summary&gt;
            public class Count : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int tmpnc = 0;
                    for (int i = 3; i &lt; this.Paramater.GetLength(0); i++)
                    {
                        tmpnc += neighbor.CountNeighbor(this.Paramater[i]);
                    }
                    if (tmpnc &gt;= Paramater[1] &amp;&amp; tmpnc &lt;= this.Paramater[2])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumber&quot;&gt;数える値&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;条件に合致した場合の値&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;範囲の最小値&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;範囲の最大値&lt;/param&gt;
                public Count(int TargetNumber, int Result, int Min, int Max)
                {
                    Paramater = new int[4] { Result, Min, Max, TargetNumber };
                }
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumber&quot;&gt;数える値&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;条件に合致した場合の値&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;範囲の最小値&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;範囲の最大値&lt;/param&gt;
                public Count(int[] TargetNumbers, int Result, int Min, int Max)
                {
                    List&lt;int&gt; Results = new List&lt;int&gt;() { Result, Min, Max };
                    foreach (int num in TargetNumbers)
                    {
                        Results.Add(num);
                    }
                    Paramater = Results.ToArray();

                }

            }

            /// &lt;summary&gt;
            /// 周囲のセルで指定した範囲の値を数え、指定範囲内にある場合に値を変化させます。
            /// 数える値は複数指定できます。
            /// &lt;/summary&gt;
            public class CountRange : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int result = 0;
                    for (int i = 1; i &lt; neighbor.Neighbor.GetLength(0); i++)
                    {
                        if (neighbor.Neighbor[i] &gt;= Paramater[0] &amp;&amp; neighbor.Neighbor[i] &lt;= Paramater[0])
                        {
                            result++;
                        }
                    }
                    if (result &gt;= Paramater[2] &amp;&amp; result &lt;= this.Paramater[3])
                    {
                        return Paramater[1];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumberMin&quot;&gt;数える値の最小値&lt;/param&gt;
                /// &lt;param name=&quot;TargetNumberMax&quot;&gt;数える値の最大値&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;結果&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;指定した値の個数の最小値&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;指定した値の個数の最大値&lt;/param&gt;
                public CountRange(int TargetNumberMin, int TargetNumberMax, int Result, int Min, int Max)
                {
                    Paramater = new int[5] { TargetNumberMin, TargetNumberMax, Result, Min, Max };
                }

            }

            /// &lt;summary&gt;
            /// 周囲のセルの内、奇数番のみに対して指定した値を数えます。
            /// 数えた結果が指定した範囲の場合値を変化させます。
            /// &lt;/summary&gt;
            public class CountOdd : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int tmpnc = 0;

                    for (int i = 3; i &lt; this.Paramater.GetLength(0); i++)
                    {
                        int result = 0;
                        for (int j = 1; j &lt; neighbor.Neighbor.GetLength(0); j += 2)
                        {
                            if (neighbor.Neighbor[j] == this.Paramater[i])
                            {
                                result++;
                            }
                        }

                        tmpnc += result;
                    }
                    if (tmpnc &gt;= Paramater[1] &amp;&amp; tmpnc &lt;= this.Paramater[2])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumber&quot;&gt;数える番号&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;出力値&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;該当セルの最小個数&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;該当セルの最大個数&lt;/param&gt;
                public CountOdd(int TargetNumber, int Result, int Min, int Max)
                {
                    Paramater = new int[4] { Result, Min, Max, TargetNumber };
                }
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumbers&quot;&gt;数える番号&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;出力値&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;該当セルの最小個数&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;該当セルの最大個数&lt;/param&gt;
                public CountOdd(int[] TargetNumbers, int Result, int Min, int Max)
                {
                    List&lt;int&gt; Results = new List&lt;int&gt;() { Result, Min, Max };
                    foreach (int num in TargetNumbers)
                    {
                        Results.Add(num);
                    }
                    Paramater = Results.ToArray();

                }
            }

            /// &lt;summary&gt;
            /// 周囲のセルの内、偶数番のみに対して指定した値を数えます。
            /// 数えた結果が指定した範囲の場合値を変化させます。
            /// &lt;/summary&gt;
            public class CountEven : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int tmpnc = 0;

                    for (int i = 3; i &lt; this.Paramater.GetLength(0); i++)
                    {
                        int result = 0;
                        for (int j = 0; j &lt; neighbor.Neighbor.GetLength(0); j += 2)
                        {
                            if (neighbor.Neighbor[j] == this.Paramater[i])
                            {
                                result++;
                            }
                        }

                        tmpnc += result;
                    }
                    if (tmpnc &gt;= Paramater[1] &amp;&amp; tmpnc &lt;= this.Paramater[2])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumber&quot;&gt;数える番号&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;出力値&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;該当セルの最小個数&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;該当セルの最大個数&lt;/param&gt;
                public CountEven(int TargetNumber, int Result, int Min, int Max)
                {
                    Paramater = new int[4] { Result, Min, Max, TargetNumber };
                }
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;TargetNumbers&quot;&gt;数える番号&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;出力値&lt;/param&gt;
                /// &lt;param name=&quot;Min&quot;&gt;該当セルの最小個数&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;該当セルの最大個数&lt;/param&gt;
                public CountEven(int[] TargetNumbers, int Result, int Min, int Max)
                {
                    List&lt;int&gt; Results = new List&lt;int&gt;() { Result, Min, Max };
                    foreach (int num in TargetNumbers)
                    {
                        Results.Add(num);
                    }
                    Paramater = Results.ToArray();

                }

            }

            /// &lt;summary&gt;
            /// 他のルールを適用し、その最大値を採用します。
            /// &lt;/summary&gt;
            public class Max : IRule
            {
                public int[] Paramater { get; set; }
                public IRule[] Rules;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int lastResult = -1;
                    foreach (IRule ir in Rules)
                    {
                        lastResult = Math.Max(lastResult, ir.GetStatus(neighbor, x, y, z));

                    }
                    return lastResult;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;rules&quot;&gt;ルール&lt;/param&gt;
                public Max(params IRule[] rules)
                {
                    this.Rules = rules;
                }
            }

            /// &lt;summary&gt;
            /// 他のルールを適用し、その最小値を採用します。
            /// &lt;/summary&gt;
            public class Min : IRule
            {
                public int[] Paramater { get; set; }
                public IRule[] Rules;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int lastResult = int.MaxValue;
                    foreach (IRule ir in Rules)
                    {
                        lastResult = Math.Min(lastResult, ir.GetStatus(neighbor, x, y, z));

                    }
                    return lastResult;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;rules&quot;&gt;他のルール&lt;/param&gt;
                public Min(params IRule[] rules)
                {
                    this.Rules = rules;
                }
            }

            /// &lt;summary&gt;
            /// 他のルールを適用し、その合計を採用します。
            /// &lt;/summary&gt;
            public class Add : IRule
            {
                public int[] Paramater { get; set; }
                public IRule[] Rules;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int lastResult = 0;
                    foreach (IRule ir in Rules)
                    {
                        lastResult = (lastResult + ir.GetStatus(neighbor, x, y, z));

                    }
                    return lastResult;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;rules&quot;&gt;ルール&lt;/param&gt;
                public Add(params IRule[] rules)
                {
                    this.Rules = rules;
                }
            }

            /// &lt;summary&gt;
            /// 一定範囲の値を置き換えます。
            /// &lt;/summary&gt;
            public class ReplaceRange : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (neighbor.Self &gt;= Paramater[0] &amp;&amp; neighbor.Self &lt;= Paramater[1])
                    {
                        return Paramater[2];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;Min&quot;&gt;対象となる最小値&lt;/param&gt;
                /// &lt;param name=&quot;Max&quot;&gt;対象となる最大値&lt;/param&gt;
                /// &lt;param name=&quot;Result&quot;&gt;変化後の値&lt;/param&gt;
                public ReplaceRange(int Min, int Max, int Result)
                {
                    Paramater = new int[] { Min, Max, Result };
                }
            }

            /// &lt;summary&gt;
            /// 他のルールを適用し、全てが変化するなら、指定された最後のルールを適用します。
            /// &lt;/summary&gt;
            public class And : IRule
            {
                public int[] Paramater { get; set; }
                public IRule[] Rules;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int lastResult = -1;
                    foreach (IRule ir in Rules)
                    {
                        if ((lastResult = ir.GetStatus(neighbor, x, y, z)) == -1)
                        {
                            return -1;
                        }
                    }
                    return lastResult;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;rules&quot;&gt;ルール&lt;/param&gt;
                public And(params IRule[] rules)
                {
                    this.Rules = rules;
                }

            }

            /// &lt;summary&gt;
            /// 他のルールを適用し、一つでも変化するなら、指定された最後に変化するルールを適用します。
            /// &lt;/summary&gt;
            public class Or : IRule
            {
                public int[] Paramater { get; set; }
                public IRule[] Rules;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int tmpResult = -1;
                    int Result = -1;
                    foreach (IRule ir in Rules)
                    {
                        tmpResult = ir.GetStatus(neighbor, x, y, z);
                        Result = tmpResult == -1 ? Result : tmpResult;
                    }
                    return Result;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;rules&quot;&gt;ルール&lt;/param&gt;
                public Or(params IRule[] rules)
                {
                    this.Rules = rules;
                }

            }

            /// &lt;summary&gt;
            /// 他のルールの適用結果、または元の値に対して二つの値を交換します。
            /// &lt;/summary&gt;
            public class Swap : IRule
            {
                public int[] Paramater { get; set; }
                public IRule Rule;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    int Result = -1;
                    if (Rule == null)
                    {
                        Result = neighbor.Self;
                    }
                    else
                    {
                        Result = Rule.GetStatus(neighbor, x, y, z);
                    }

                    if (Result == Paramater[0])
                    {
                        return Paramater[1];
                    }
                    else if (Result == Paramater[1])
                    {
                        return Paramater[0];
                    }

                    return Result;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;A&quot;&gt;交換する値1&lt;/param&gt;
                /// &lt;param name=&quot;B&quot;&gt;交換する値2&lt;/param&gt;
                /// &lt;param name=&quot;rule&quot;&gt;ルール&lt;/param&gt;
                public Swap(int A, int B, IRule rule)
                {
                    this.Paramater = new int[] { A, B };
                    this.Rule = rule;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;A&quot;&gt;交換する値1&lt;/param&gt;
                /// &lt;param name=&quot;B&quot;&gt;交換する値2&lt;/param&gt;
                public Swap(int A, int B)
                {
                    this.Paramater = new int[] { A, B };
                    this.Rule = null;
                }
            }

            /// &lt;summary&gt;
            /// 下層の値をそのまま用います。
            /// &lt;/summary&gt;
            public class CopyLowerFloor : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    return neighbor.Lower == -2 ? -1 : neighbor.Lower;
                }

                public CopyLowerFloor()
                {
                }
            }

            /// &lt;summary&gt;
            /// 上層の値をそのまま用います。
            /// &lt;/summary&gt;
            public class CopyUpperFloor : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    return neighbor.Upper == -2 ? -1 : neighbor.Upper;
                }

                public CopyUpperFloor()
                {
                }

            }

            /// &lt;summary&gt;
            ///平面上の座標が指定値の場合に値を変化させます。
            /// &lt;/summary&gt;
            public class BuildCylinder : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (x == Paramater[1] &amp;&amp; y == Paramater[2] &amp;&amp; z &lt; Paramater[3])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;変化後の値&lt;/param&gt;
                /// &lt;param name=&quot;x&quot;&gt;x座標&lt;/param&gt;
                /// &lt;param name=&quot;y&quot;&gt;y座標&lt;/param&gt;
                /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
                public BuildCylinder(int result, int x, int y, int height)
                {
                    Paramater = new int[] { result, x, y, height };
                }

            }

            /// &lt;summary&gt;
            /// 該当セルが円柱に含まれる場合に値を変化させます。
            /// &lt;/summary&gt;
            public class BuildCylinderRadius : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (Math.Pow(x - Paramater[1], 2) + Math.Pow(y - Paramater[2], 2) &lt;= Math.Pow(Paramater[4], 2) &amp;&amp; z &lt; Paramater[3])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;結果&lt;/param&gt;
                /// &lt;param name=&quot;x&quot;&gt;中心のX座標&lt;/param&gt;
                /// &lt;param name=&quot;y&quot;&gt;中心のY座標&lt;/param&gt;
                /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
                /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
                public BuildCylinderRadius(int result, int x, int y, int height, int Radius)
                {
                    Paramater = new int[] { result, x, y, height, Radius };
                }
            }

            /// &lt;summary&gt;
            /// ハニカムグリッドにおいて、該当セルが円柱に含まれる場合に値を変化させます。
            /// &lt;/summary&gt;
            public class BuildCylinderRadiusHoneycomb : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    Point2d current = Honeycomb.GetCenterPoint(x, y);
                    Point2d target = Honeycomb.GetCenterPoint(Paramater[1], Paramater[2]);

                    if (current.DistanceTo(target) &lt;= Paramater[4] &amp;&amp; z &lt; Paramater[3])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;結果&lt;/param&gt;
                /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
                /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
                /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
                /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
                public BuildCylinderRadiusHoneycomb(int result, int x, int y, int height, int Radius)
                {
                    Paramater = new int[] { result, x, y, height, Radius };
                }

            }

            /// &lt;summary&gt;
            /// 該当セルが直方体に含まれる場合に値を変化させます。
            /// &lt;/summary&gt;
            public class BuildBox : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (x &gt;= Paramater[1] &amp;&amp; y &gt;= Paramater[2] &amp;&amp; z &gt;= Paramater[3] &amp;&amp;
                        x &lt; Paramater[4] &amp;&amp; y &lt; Paramater[5] &amp;&amp; z &lt; Paramater[6])
                    {
                        return Paramater[0];
                    }
                    else
                    {
                        return -1;
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;結果&lt;/param&gt;
                /// &lt;param name=&quot;x&quot;&gt;X座標&lt;/param&gt;
                /// &lt;param name=&quot;y&quot;&gt;Y座標&lt;/param&gt;
                /// &lt;param name=&quot;z&quot;&gt;Z座標&lt;/param&gt;
                /// &lt;param name=&quot;xLength&quot;&gt;幅(X方向)&lt;/param&gt;
                /// &lt;param name=&quot;yLength&quot;&gt;奥行(Y方向)&lt;/param&gt;
                /// &lt;param name=&quot;zLength&quot;&gt;高さ(Z方向)&lt;/param&gt;
                public BuildBox(int result, int x, int y, int z, int xLength, int yLength, int zLength)
                {
                    Paramater = new int[] { result, x, y, z, x + xLength, y + yLength, z + zLength };
                }

            }

            /// &lt;summary&gt;
            /// 条件によらず指定した値にします。
            /// &lt;/summary&gt;
            public class Init : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    return Paramater[0];
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;値&lt;/param&gt;
                public Init(int result)
                {
                    Paramater = new int[] { result };
                }

            }

            /// &lt;summary&gt;
            /// 条件によらず指定した値にします。(Initと同じ)
            /// &lt;/summary&gt;
            public class Const : Init
            {
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;値&lt;/param&gt;
                public Const(int Result) : base(Result) { }
            }

            /// &lt;summary&gt;
            /// セルが指定値の場合、指定値の最初の値を返します。
            /// &lt;/summary&gt;
            public class Self : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    foreach (int num in this.Paramater)
                    {
                        if (neighbor.Self == num) { return Paramater[0]; }
                    }
                    return -1;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;result&quot;&gt;指定値&lt;/param&gt;
                public Self(params int[] result)
                {
                    Paramater = result;
                }

            }

            /// &lt;summary&gt;
            /// 値を置き換えます。
            /// &lt;/summary&gt;
            public class Replace : IRule
            {
                public int[] Paramater { get; set; }

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (neighbor.Self == Paramater[0]) { return Paramater[1]; } else { return -1; }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;origin&quot;&gt;置き換え元&lt;/param&gt;
                /// &lt;param name=&quot;result&quot;&gt;置き換え先&lt;/param&gt;
                public Replace(int origin, int result)
                {
                    Paramater = new int[] { origin, result };
                }

            }

            /// &lt;summary&gt;
            /// 他のルールの適用結果、または元の値が指定値の場合は-1(変化しない)を返し、そうでない場合は結果をそのまま返します。
            /// &lt;/summary&gt;
            public class Keep : IRule
            {
                public int[] Paramater { get; set; }
                public IRule Content;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    foreach (int num in Paramater)
                    {
                        if (neighbor.Self == num)
                        {
                            return -1;
                        }
                    }

                    {
                        if (Content != null)
                        {
                            return Content.GetStatus(neighbor, x, y, z);
                        }
                        else
                        {
                            return neighbor.Self;
                        }
                    }
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;target&quot;&gt;変化させない値&lt;/param&gt;
                public Keep(params int[] target)
                {
                    Paramater = target;
                    this.Content = null;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;target&quot;&gt;変化させない値&lt;/param&gt;
                /// &lt;param name=&quot;Content&quot;&gt;ルール&lt;/param&gt;
                public Keep(int target, IRule Content)
                {
                    Paramater = new[] { target };
                    this.Content = Content;
                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;target&quot;&gt;変化させない値&lt;/param&gt;
                /// &lt;param name=&quot;Content&quot;&gt;ルール&lt;/param&gt;
                public Keep(int[] target, IRule Content)
                {
                    Paramater = target;
                    this.Content = Content;
                }
            }

            /// &lt;summary&gt;
            /// 周囲のセルにおける二つの階層を入れ替えた物としてルールを適用します。
            /// &lt;/summary&gt;
            public class SwapFloor : IRule
            {
                public int[] Paramater { get; set; }
                public IRule Content;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    NeighborStatus newNeighbor = neighbor.Duplicate();
                    newNeighbor.SwapFloor(Paramater[0], Paramater[1]);
                    return Content.GetStatus(newNeighbor, x, y, z);
                }
                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;A&quot;&gt;相対階層1&lt;/param&gt;
                /// &lt;param name=&quot;B&quot;&gt;相対階層2&lt;/param&gt;
                /// &lt;param name=&quot;Content&quot;&gt;適用ルール&lt;/param&gt;
                public SwapFloor(int A, int B, IRule Content)
                {
                    this.Content = Content;
                    Paramater = new[] { A, B };
                }

                /// &lt;summary&gt;
                /// コンストラクタ。交換する階層の片方は自分の階層とします。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;A&quot;&gt;相対階層1&lt;/param&gt;
                /// &lt;param name=&quot;Content&quot;&gt;適用ルール&lt;/param&gt;
                public SwapFloor(int A, IRule Content) : this(A, 0, Content)
                {
                }
            }

            /// &lt;summary&gt;
            /// 指定した階層の場合のみルールを適用します。
            /// &lt;/summary&gt;
            public class TargetFloor : IRule
            {
                public int[] Paramater { get; set; }
                public IRule Content;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (z == Paramater[0])
                    {
                        return Content.GetStatus(neighbor, x, y, z);
                    }
                    else
                    {
                        return -1;
                    }

                }

                /// &lt;summary&gt;
                /// コンストラクタ
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;target&quot;&gt;指定階層&lt;/param&gt;
                /// &lt;param name=&quot;Content&quot;&gt;適用ルール&lt;/param&gt;
                public TargetFloor(int target, IRule Content)
                {
                    this.Content = Content;
                    Paramater = new[] { target };
                }
            }

            /// &lt;summary&gt;
            /// 一定確率でルールを適用します。
            /// &lt;/summary&gt;
            public class Random : IRule
            {
                public int[] Paramater { get; set; }
                public IRule Content;
                public System.Random Rand;

                public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
                {
                    if (Rand.Next(100) &lt; Paramater[0])
                    {
                        return Content.GetStatus(neighbor, x, y, z);
                    }
                    else
                    {
                        return -1;
                    }

                }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;Probability&quot;&gt;変化確率(百分率)&lt;/param&gt;
                /// &lt;param name=&quot;rule&quot;&gt;適用ルール&lt;/param&gt;
                public Random(int Probability, IRule rule) : this(Probability, rule, new System.Random()) { }

                /// &lt;summary&gt;
                /// コンストラクタ。
                /// &lt;/summary&gt;
                /// &lt;param name=&quot;Probability&quot;&gt;変化確率(百分率)&lt;/param&gt;
                /// &lt;param name=&quot;rule&quot;&gt;適用ルール&lt;/param&gt;
                /// &lt;param name=&quot;rd&quot;&gt;利用するRandomインスタンス&lt;/param&gt;
                public Random(int Probability, IRule rule, System.Random rd)
                {
                    Paramater = new int[] { Probability };
                    Content = rule;
                    Rand = new System.Random(rd.Next());
                }

            }
        }
    }
#endregion

#region ..\GeneralHelper.cs

    /// &lt;summary&gt;
    /// Rhino Commonに標準では含まれない追加的関数を含みます。
    /// &lt;/summary&gt;
    public static class GeneralHelper
    {
        /// &lt;summary&gt;
        /// Brepを二点に合わせて配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;Brep&lt;/param&gt;
        /// &lt;param name=&quot;Point1&quot;&gt;点1&lt;/param&gt;
        /// &lt;param name=&quot;Point2&quot;&gt;点2&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep FitTwoPoint(Brep Origin, Point3d Point1, Point3d Point2)
        {
            Vector3d Direction = Point2 - Point1;
            Brep Result = (Brep)Origin.Duplicate();
            double Angle;
            if (Direction.X == 0) { Angle = Direction.Y &gt; 0 ? Math.PI / 2.0 : -Math.PI / 2.0; }
            else
            {
                Angle = Math.Atan(Direction.Y / Direction.X);
                if (Direction.X &lt; 0) { Angle += Math.PI; }
            }

            Result.Rotate(Angle, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
            Result.Translate((Vector3d)Point1);
            return Result;
        }

        /// &lt;summary&gt;
        /// 二点に合わせた移動を示すTransfromを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Point1&quot;&gt;点1&lt;/param&gt;
        /// &lt;param name=&quot;Point2&quot;&gt;点2&lt;/param&gt;
        /// &lt;returns&gt;Transform&lt;/returns&gt;
        public static Transform FitTwoPoint(Point3d Point1, Point3d Point2)
        {
            Vector3d Direction = Point2 - Point1;
            Transform tf = Transform.Identity;
            double Angle;
            if (Direction.X == 0) { Angle = Direction.Y &gt; 0 ? Math.PI / 2.0 : -Math.PI / 2.0; }
            else
            {
                Angle = Math.Atan(Direction.Y / Direction.X);
                if (Direction.X &lt; 0) { Angle += Math.PI; }
            }
            tf *= Transform.Translation((Vector3d)Point1);
            tf *= Transform.Rotation(Angle, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
            return tf;
        }

        /// &lt;summary&gt;
        /// Extrusionを行った結果にCapを行います。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Section&quot;&gt;断面&lt;/param&gt;
        /// &lt;param name=&quot;Direction&quot;&gt;方向&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] CreateExtrusionCaped(Curve[] Section, Vector3d Direction)
        {
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();

            Brep[] BaseBrep = Brep.CreatePlanarBreps(Section);
            Result.AddRange(BaseBrep);
            foreach (Brep bp in BaseBrep)
            {
                Brep TempBrep = (Brep)bp.Duplicate();
                TempBrep.Translate(Direction);
                Result.Add(TempBrep);
            }
            foreach (Curve cv in Section)
            {
                Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(cv, Direction)));
            }
            //return Brep.CreateSolid(Result, Direction.Length/100.0);
            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// 複数のBrepを複製します。手軽に使えます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;複製元のBrep&lt;/param&gt;
        /// &lt;returns&gt;複製後のBrep&lt;/returns&gt;
        public static Brep[] DuplicateBreps(Brep[] Origin)
        {
            Brep[] Result = new Brep[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                if (Origin[i] == null) continue;
                Result[i] = (Brep)Origin[i].Duplicate();
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// Curveに合わせて蓋つきパイプを作ります。(円でSweep)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;RailCurve&quot;&gt;Curve&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep CreateSweepCircle(Curve RailCurve, double Radius)
        {
            return CreateSweep(RailCurve, NurbsCurve.CreateFromCircle(new Circle(Radius)));
        }

        /// &lt;summary&gt;
        /// Sweepし、可能ならCapします。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;RailCurve&quot;&gt;Curve&lt;/param&gt;
        /// &lt;param name=&quot;BaseShape&quot;&gt;断面&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep CreateSweep(Curve RailCurve, Curve BaseShape)
        {
            Brep result = Brep.CreateFromSweep(RailCurve, GetCurveForSweep(BaseShape, RailCurve), true, 1e-2)[0];
            if (!RailCurve.IsClosed)
            {
                result.CapPlanarHoles(0);
            }
            return result;
        }
        /// &lt;summary&gt;
        /// Sweepを実行する為に断面の向きを変えます。
        /// これはBrep.CreateFromSweepの特性に対する補助です。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Shape&quot;&gt;基本形状&lt;/param&gt;
        /// &lt;param name=&quot;Rail&quot;&gt;SweepするCurve(レール)&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve GetCurveForSweep(Curve Shape, Curve Rail)
        {
            Rail.Domain = new Interval(0, 1);
            Shape.Rotate(Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
            Shape.Rotate(GeneralHelper.GetCurvatureAsAngle(Rail, 0), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
            Shape.Translate((Vector3d)Rail.PointAtStart);
            return Shape;
        }

        /// &lt;summary&gt;
        /// Curveのある点での曲率を角度として取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cv&quot;&gt;Curve&lt;/param&gt;
        /// &lt;param name=&quot;t&quot;&gt;t&lt;/param&gt;
        /// &lt;returns&gt;角度&lt;/returns&gt;
        public static double GetCurvatureAsAngle(Curve cv, double t)
        {
            Vector3d Curvature = cv.TangentAt(t);

            double angle = 0;
            if (Curvature.Y == 0) { angle = Math.PI / 2.0; }
            else
            {
                angle = -Math.Atan(Curvature.X / Curvature.Y);
                if (Curvature.X &lt; 0) { angle += Math.PI; }
            }
            return angle;
        }
        /// &lt;summary&gt;
        /// 複数のBrepを移動します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;移動するBrep&lt;/param&gt;
        /// &lt;param name=&quot;To&quot;&gt;移動方向&lt;/param&gt;
        /// &lt;returns&gt;移動結果&lt;/returns&gt;
        public static Brep[] TranslateBreps(Brep[] Origin, Point3d To)
        {
            return TranslateBreps(Origin, (Vector3d)To);
        }
        /// &lt;summary&gt;
        /// 複数のBrepを移動します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;移動するBrep&lt;/param&gt;
        /// &lt;param name=&quot;To&quot;&gt;移動方向&lt;/param&gt;
        /// &lt;returns&gt;移動結果&lt;/returns&gt;
        public static Brep[] TranslateBreps(Brep[] Origin, Vector3d To)
        {
            if (Origin == null) { return null; }
            Brep[] Result = new Brep[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                Brep TempBrep = (Brep)Origin[i].Duplicate();
                TempBrep.Translate(To);
                Result[i] = TempBrep;
            }
            return Result;
        }
        /// &lt;summary&gt;
        /// 複数のBrepを回転します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;回転元のBrep&lt;/param&gt;
        /// &lt;param name=&quot;AngleRadians&quot;&gt;回転角度&lt;/param&gt;
        /// &lt;param name=&quot;rotationAxis&quot;&gt;回転軸&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep[] RotateBreps(Brep[] Origin, double AngleRadians, Vector3d rotationAxis)
        {
            return RotateBreps(Origin, AngleRadians, rotationAxis, new Point3d(0, 0, 0));
        }
        /// &lt;summary&gt;
        /// 複数のBrepを回転します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;回転元のBrep&lt;/param&gt;
        /// &lt;param name=&quot;AngleRadians&quot;&gt;回転角度&lt;/param&gt;
        /// &lt;param name=&quot;rotationAxis&quot;&gt;回転軸&lt;/param&gt;
        /// &lt;param name=&quot;rotationCenter&quot;&gt;回転中心&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RotateBreps(Brep[] Origin, double AngleRadians, Vector3d rotationAxis, Point3d rotationCenter)
        {
            Brep[] Result = new Brep[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                Brep TempBrep = (Brep)Origin[i].Duplicate();
                TempBrep.Rotate(AngleRadians, rotationAxis, rotationCenter);
                Result[i] = TempBrep;
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// 複数のBrepを回転します。RotateBrepと同じ内容ですが互換性の為に残されています。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;回転元のBrep&lt;/param&gt;
        /// &lt;param name=&quot;AngleRadians&quot;&gt;回転角度&lt;/param&gt;
        /// &lt;param name=&quot;rotationAxis&quot;&gt;回転軸&lt;/param&gt;
        /// &lt;param name=&quot;rotationCenter&quot;&gt;回転中心&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RotateBrep(Brep[] origin, double angleRadians, Vector3d rotationAxis, Point3d rotationCenter)
        {
            Brep[] Result = new Brep[origin.GetLength(0)];
            for (int i = 0; i &lt; origin.GetLength(0); i++)
            {
                Brep bp = (Brep)origin[i].Duplicate();
                bp.Rotate(angleRadians, rotationAxis, rotationCenter);
                Result[i] = bp;
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// Brepを一定間隔で配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;配置するBrep&lt;/param&gt;
        /// &lt;param name=&quot;Vector&quot;&gt;移動方向&lt;/param&gt;
        /// &lt;param name=&quot;Count&quot;&gt;個数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RepeatBrep(Brep Origin, Vector3d Vector, int Count)
        {
            return RepeatBrep(Origin, Vector, new Vector3d(0, 0, 0), Count, 1);
        }
        /// &lt;summary&gt;
        /// Brepを一定間隔で二方向に配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;配置するBrep&lt;/param&gt;
        /// &lt;param name=&quot;Vector1&quot;&gt;移動方向1&lt;/param&gt;
        /// &lt;param name=&quot;Vector2&quot;&gt;移動方向2&lt;/param&gt;
        /// &lt;param name=&quot;CountX&quot;&gt;方向1の配置個数&lt;/param&gt;
        /// &lt;param name=&quot;CountY&quot;&gt;方向2の配置個数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RepeatBrep(Brep Origin, Vector3d Vector1, Vector3d Vector2, int CountX, int CountY)
        {
            return RepeatBrep(Origin, Vector1, Vector2, new Vector3d(0, 0, 0), CountX, CountY, 1);
        }
        /// &lt;summary&gt;
        /// 複数のBrepを一定間隔で配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;配置するBrep&lt;/param&gt;
        /// &lt;param name=&quot;Vector&quot;&gt;移動方向&lt;/param&gt;
        /// &lt;param name=&quot;Count&quot;&gt;個数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RepeatBrep(Brep[] Origin, Vector3d Vector, int Count)
        {
            return RepeatBrep(Origin, Vector, new Vector3d(0, 0, 0), Count, 1);
        }
        /// &lt;summary&gt;
        /// 複数のBrepを一定間隔で二方向に配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;配置するBrep&lt;/param&gt;
        /// &lt;param name=&quot;Vector1&quot;&gt;移動方向1&lt;/param&gt;
        /// &lt;param name=&quot;Vector2&quot;&gt;移動方向2&lt;/param&gt;
        /// &lt;param name=&quot;CountX&quot;&gt;方向1の配置個数&lt;/param&gt;
        /// &lt;param name=&quot;CountY&quot;&gt;方向2の配置個数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RepeatBrep(Brep[] Origin, Vector3d Vector1, Vector3d Vector2, int CountX, int CountY)
        {
            return RepeatBrep(Origin, Vector1, Vector2, new Vector3d(0, 0, 0), CountX, CountY, 1);
        }
        /// &lt;summary&gt;
        /// Brepを一定間隔で三方向に配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;配置するBrep&lt;/param&gt;
        /// &lt;param name=&quot;Vector1&quot;&gt;移動方向1&lt;/param&gt;
        /// &lt;param name=&quot;Vector2&quot;&gt;移動方向2&lt;/param&gt;
        /// &lt;param name=&quot;Vector3&quot;&gt;移動方向3&lt;/param&gt;
        /// &lt;param name=&quot;CountX&quot;&gt;方向1の配置個数&lt;/param&gt;
        /// &lt;param name=&quot;CountY&quot;&gt;方向2の配置個数&lt;/param&gt;
        /// &lt;param name=&quot;CountZ&quot;&gt;方向3の配置個数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RepeatBrep(Brep Origin, Vector3d Vector1, Vector3d Vector2, Vector3d Vector3, int CountX, int CountY, int CountZ)
        {
            return RepeatBrep(new Brep[] { Origin }, Vector1, Vector2, Vector3, CountX, CountY, CountZ);
        }
        /// &lt;summary&gt;
        /// 複数のBrepを一定間隔で三方向に配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;配置するBrep&lt;/param&gt;
        /// &lt;param name=&quot;Vector1&quot;&gt;移動方向1&lt;/param&gt;
        /// &lt;param name=&quot;Vector2&quot;&gt;移動方向2&lt;/param&gt;
        /// &lt;param name=&quot;Vector3&quot;&gt;移動方向3&lt;/param&gt;
        /// &lt;param name=&quot;CountX&quot;&gt;方向1の配置個数&lt;/param&gt;
        /// &lt;param name=&quot;CountY&quot;&gt;方向2の配置個数&lt;/param&gt;
        /// &lt;param name=&quot;CountZ&quot;&gt;方向3の配置個数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] RepeatBrep(Brep[] Origin, Vector3d Vector1, Vector3d Vector2, Vector3d Vector3, int CountX, int CountY, int CountZ)
        {
            Brep[] Result = new Brep[CountX * CountY * CountZ * Origin.GetLength(0)];
            for (int i = 0; i &lt; CountZ; i++)
            {
                for (int j = 0; j &lt; CountY; j++)
                {
                    for (int k = 0; k &lt; CountX; k++)
                    {
                        for (int l = 0; l &lt; Origin.GetLength(0); l++)
                        {
                            Brep tempBrep = (Brep)Origin[l].Duplicate();
                            tempBrep.Translate(Vector1 * k + Vector2 * j + Vector3 * i);
                            Result[i * CountX * CountY * Origin.GetLength(0) + j * CountX * Origin.GetLength(0) + k * Origin.GetLength(0) + l] = tempBrep;
                        }
                    }
                }
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// 複数のBrepを複製します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;origin&quot;&gt;複製元Brep&lt;/param&gt;
        /// &lt;returns&gt;複製結果&lt;/returns&gt;
        public static Brep[] DuplicateBrep(Brep[] origin)
        {
            Brep[] result = new Brep[origin.GetLength(0)];
            for (int i = 0; i &lt; origin.GetLength(0); i++)
            {
                result[i] = (Brep)origin[i].Duplicate();
            }
            return result;
        }
    }
#endregion

#region ..\GraphObject.cs

    /// &lt;summary&gt;
    /// 簡単なIKに関する機能を含みます。
    /// &lt;/summary&gt;
    public class GraphObject
    {
        /// &lt;summary&gt;
        /// ボーンを示します。
        /// &lt;/summary&gt;
        public class Path
        {
            /// &lt;summary&gt;
            /// 名前
            /// &lt;/summary&gt;
            public string Name { get { return ContentMember.ToString(); } set { ContentMember.SetName(value); } }
            /// &lt;summary&gt;
            /// ボーンに含まれる部材です。
            /// &lt;/summary&gt;
            public RealObject.Member ContentMember;
            /// &lt;summary&gt;
            /// ボーンの長さです。
            /// &lt;/summary&gt;
            public double Length;

            /// &lt;summary&gt;
            /// 距離と半径の組み合わせからパイプによるボーンを作ります。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Distance&quot;&gt;距離&lt;/param&gt;
            /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
            /// &lt;returns&gt;ボーン&lt;/returns&gt;
            public static Path CreateFromPipeSimple(double[] Distance, double[] Radius)
            {
                return new Path() { ContentMember = new Brep[] { Providers.GetPipeSimple(Distance, Radius) }, Length = Distance[Distance.GetLength(0) - 1] - Distance[0] };
            }

            /// &lt;summary&gt;
            /// 距離と半径の組み合わせから片方が閉じた形状のボーンを作ります。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Distance&quot;&gt;距離&lt;/param&gt;
            /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
            /// &lt;returns&gt;ボーン&lt;/returns&gt;
            public static Path CreateFromPipeHead(double[] Distance, double[] Radius)
            {
                return new Path() { ContentMember = new Brep[] { Providers.GetPipeHead(Distance, Radius) }, Length = Distance[Distance.GetLength(0) - 1] - Distance[0] };
            }

            /// &lt;summary&gt;
            /// 多角形柱のボーンを作ります。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;count&quot;&gt;n角形におけるn&lt;/param&gt;
            /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
            /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
            /// &lt;returns&gt;ボーン&lt;/returns&gt;
            public static Path CreateFromRegularPolygonTower(int count, double Radius, double Height)
            {
                Brep bp = Providers.GetRegularPolygonTower(count, Radius, Height, true);
                bp.Transform(Transform.ChangeBasis(Plane.WorldYZ, Plane.WorldXY));
                return new Path() { ContentMember = new Brep[] { bp }, Length = Height };
            }
        }

        /// &lt;summary&gt;
        /// 関節を示します。
        /// &lt;/summary&gt;
        public class Node
        {
            /// &lt;summary&gt;
            /// 名前
            /// &lt;/summary&gt;
            public string Name { get { return ContentMember.ToString(); } set { ContentMember.SetName(value); } }
            /// &lt;summary&gt;
            /// 関節につながるボーン1
            /// &lt;/summary&gt;
            public Path Target1;
            /// &lt;summary&gt;
            /// 関節につながるボーン2
            /// &lt;/summary&gt;
            public Path Target2;
            /// &lt;summary&gt;
            /// ボーン1のつながるボーン内の場所
            /// &lt;/summary&gt;
            public Point3d Target1ConnectionPoint = new Point3d(0, 0, 0);
            /// &lt;summary&gt;
            /// ボーン2のつながるボーン内の場所
            /// &lt;/summary&gt;
            public Point3d Target2ConnectionPoint = new Point3d(0, 0, 0);
            /// &lt;summary&gt;
            /// 関節の半径
            /// &lt;/summary&gt;
            public double Radius;
            /// &lt;summary&gt;
            /// 関節に含まれる部材
            /// &lt;/summary&gt;
            public RealObject.Member ContentMember;
            
            /// &lt;summary&gt;
            /// X方向の回転角
            /// &lt;/summary&gt;
            public double RotationAngleX { get { return _RotationAngleX; } set { _RotationAngleX = Math.Max(RotationAngleXLimitation.Min, Math.Min(RotationAngleXLimitation.Max, value % (Math.PI * 2.0))); } }
            private double _RotationAngleX = 0;
            /// &lt;summary&gt;
            /// X方向の回転可能範囲
            /// &lt;/summary&gt;
            public Interval RotationAngleXLimitation = new Interval(0, Math.PI * 2.0);

            /// &lt;summary&gt;
            /// Y方向の回転角
            /// &lt;/summary&gt;
            public double RotationAngleY { get { return _RotationAngleY; } set { _RotationAngleY = Math.Max(RotationAngleYLimitation.Min, Math.Min(RotationAngleYLimitation.Max, value % (Math.PI * 2.0))); } }
            private double _RotationAngleY = 0;
            /// &lt;summary&gt;
            /// Y方向の回転可能範囲
            /// &lt;/summary&gt;
            public Interval RotationAngleYLimitation = new Interval(0, Math.PI * 2.0);

            /// &lt;summary&gt;
            /// Z方向の回転角
            /// &lt;/summary&gt;
            public double RotationAngleZ { get { return _RotationAngleZ; } set { _RotationAngleZ = Math.Max(RotationAngleZLimitation.Min, Math.Min(RotationAngleZLimitation.Max, value % (Math.PI * 2.0))); } }
            private double _RotationAngleZ = 0;
            /// &lt;summary&gt;
            /// Z方向の回転可能範囲
            /// &lt;/summary&gt;
            public Interval RotationAngleZLimitation = new Interval(0, Math.PI * 2.0);

            /// &lt;summary&gt;
            /// 二つのボーンの内、指定値と違う方を取得する。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;that&quot;&gt;指定ボーン&lt;/param&gt;
            /// &lt;returns&gt;異なる方のボーン&lt;/returns&gt;
            public Path GetPathOtherThan(Path that)
            {
                if (that == Target1) { return Target2; }
                else if (that == Target2) { return Target1; }
                else { return new Path(); }
            }

            /// &lt;summary&gt;
            /// 指定したボーンの接続点を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;that&quot;&gt;指定ボーン&lt;/param&gt;
            /// &lt;returns&gt;接続点&lt;/returns&gt;
            public Point3d GetConnectionPoint(Path that)
            {
                if (that == Target1) { return new Point3d(Target1ConnectionPoint); }
                else if (that == Target2) { return new Point3d(Target2ConnectionPoint); }
                else { return new Point3d(0, 0, 0); }
            }

            /// &lt;summary&gt;
            /// 球から関節を作ります。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rad&quot;&gt;半径&lt;/param&gt;
            /// &lt;param name=&quot;len&quot;&gt;長さ&lt;/param&gt;
            /// &lt;returns&gt;関節&lt;/returns&gt;
            public static Node CreateFromSphere(double rad, double len)
            {
                if (len &gt; 0)
                {
                    return new Node() { Radius = len / 2.0, ContentMember = new Brep[] { Brep.CreateFromSphere(new Sphere(new Point3d(0, 0, 0), rad)) } };
                }
                else
                {
                    return new Node() { Radius = 0, ContentMember = new Brep[0] };
                }
            }
        }

        /// &lt;summary&gt;
        /// IKモデル
        /// &lt;/summary&gt;
        public class Graph
        {
            /// &lt;summary&gt;
            /// 基底ボーン。これに長さ0のボーンを設定すると関節を基底として根元から回転できるようになります。
            /// &lt;/summary&gt;
            public Path RootPath;//You can set this length to zero to set Node as root.
            private Dictionary&lt;Path, List&lt;Node&gt;&gt; NodesDic = new Dictionary&lt;Path, List&lt;Node&gt;&gt;();
            /// &lt;summary&gt;
            /// 配置場所
            /// &lt;/summary&gt;
            public Point3d Position;
            /// &lt;summary&gt;
            /// X方向の回転角
            /// &lt;/summary&gt;
            public double RotationAngleX = 0;
            /// &lt;summary&gt;
            /// Y方向の回転角
            /// &lt;/summary&gt;
            public double RotationAngleY = 0;
            /// &lt;summary&gt;
            /// Z方向の回転角
            /// &lt;/summary&gt;
            public double RotationAngleZ = 0;
            public double AddScale = 1.0;

            /// &lt;summary&gt;
            /// モデルに含まれるボーン
            /// &lt;/summary&gt;
            public Path[] Paths
            {
                get
                {
                    List&lt;Path&gt; Result = new List&lt;Path&gt;();
                    Result.Add(RootPath);
                    foreach (KeyValuePair&lt;Path, List&lt;Node&gt;&gt; kvp in NodesDic)
                    {
                        foreach (Node nd in kvp.Value)
                        {
                            Path pathtoadd = nd.GetPathOtherThan(kvp.Key);
                            if (!Result.Contains(pathtoadd)) Result.Add(pathtoadd);
                        }
                    }
                    return Result.ToArray();
                }
            }
            /// &lt;summary&gt;
            /// モデルに含まれる関数
            /// &lt;/summary&gt;
            public Node[] Nodes
            {
                get
                {
                    List&lt;Node&gt; Result = new List&lt;Node&gt;();
                    foreach (KeyValuePair&lt;Path, List&lt;Node&gt;&gt; kvp in NodesDic)
                    {
                        foreach (Node nd in kvp.Value)
                        {
                            Result.Add(nd);
                        }
                    }
                    return Result.ToArray();
                }
            }

            /// &lt;summary&gt;
            /// 既存のボーンに新規ボーンを接続します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;PathToConnect&quot;&gt;接続するボーン&lt;/param&gt;
            /// &lt;param name=&quot;PathToAdd&quot;&gt;新規ボーン&lt;/param&gt;
            /// &lt;returns&gt;接続する関節&lt;/returns&gt;
            public Node Add(Path PathToConnect, Path PathToAdd)
            {
                return Add(PathToConnect, new Point3d(PathToConnect.Length / AddScale, 0, 0), PathToAdd, new Node() { ContentMember = new Brep[0], Radius = 0 });
            }
            /// &lt;summary&gt;
            /// 既存のボーンに新規ボーンを接続します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;PathToConnect&quot;&gt;接続するボーン&lt;/param&gt;
            /// &lt;param name=&quot;PathToAdd&quot;&gt;新規ボーン&lt;/param&gt;
            /// &lt;param name=&quot;rad&quot;&gt;半径&lt;/param&gt;
            /// &lt;param name=&quot;len&quot;&gt;新規ボーンの長さ&lt;/param&gt;
            /// &lt;returns&gt;接続された関節&lt;/returns&gt;
            public Node Add(Path PathToConnect, Path PathToAdd, double rad, double len)
            {
                return Add(PathToConnect, new Point3d(PathToConnect.Length / AddScale, 0, 0), PathToAdd, Node.CreateFromSphere(rad, len));
            }

            /// &lt;summary&gt;
            /// 既存の関節に新規ボーンを接続します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;PathToConnect&quot;&gt;接続するボーン&lt;/param&gt;
            /// &lt;param name=&quot;ConnectionPoint&quot;&gt;接続する点&lt;/param&gt;
            /// &lt;param name=&quot;PathToAdd&quot;&gt;新規ボーン&lt;/param&gt;
            /// &lt;param name=&quot;node&quot;&gt;接続する関節&lt;/param&gt;
            /// &lt;returns&gt;接続された関節&lt;/returns&gt;
            public Node Add(Path PathToConnect, Point3d ConnectionPoint, Path PathToAdd, Node node)
            {
                node.Target1 = PathToConnect;
                node.Target1ConnectionPoint = ConnectionPoint * AddScale;
                node.Target2 = PathToAdd;

                Brep[] newbp;
                newbp = new Brep[PathToAdd.ContentMember.Content.GetLength(0)];
                for (int i = 0; i &lt; PathToAdd.ContentMember.Content.GetLength(0); i++)
                {
                    newbp[i] = (Brep)PathToAdd.ContentMember.Content[i].Duplicate();
                    newbp[i].Scale(AddScale);
                }
                PathToAdd.ContentMember.Content = newbp;
                PathToAdd.Length *= AddScale;

                newbp = new Brep[PathToConnect.ContentMember.Content.GetLength(0)];
                for (int i = 0; i &lt; node.ContentMember.Content.GetLength(0); i++)
                {
                    newbp[i] = (Brep)node.ContentMember.Content[i].Duplicate();
                    newbp[i].Scale(AddScale);
                }
                node.ContentMember.Content = newbp;

                node.Radius *= AddScale;

                NodesDic[PathToConnect].Add(node);
                NodesDic.Add(PathToAdd, new List&lt;Node&gt;());
                return node;
            }

            /// &lt;summary&gt;
            /// 関節をランダムに動かす。
            /// &lt;/summary&gt;
            public void MoveRandom()
            {
                MoveRandom(new Random());
            }

            /// &lt;summary&gt;
            /// 関節をランダムに動かす。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rd&quot;&gt;乱数の種&lt;/param&gt;
            public void MoveRandom(Random rd)
            {
                foreach (Node nd in Nodes)
                {
                    nd.RotationAngleX = nd.RotationAngleXLimitation.Min + nd.RotationAngleXLimitation.Length * rd.NextDouble();
                    nd.RotationAngleY = nd.RotationAngleYLimitation.Min + nd.RotationAngleYLimitation.Length * rd.NextDouble();
                    nd.RotationAngleZ = nd.RotationAngleZLimitation.Min + nd.RotationAngleZLimitation.Length * rd.NextDouble();
                }
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Root&quot;&gt;基底のボーン&lt;/param&gt;
            /// &lt;param name=&quot;Position&quot;&gt;座標&lt;/param&gt;
            public Graph(Path Root, Point3d Position)
                : this(Root, Position, false)
            {
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Root&quot;&gt;基底のボーン&lt;/param&gt;
            /// &lt;param name=&quot;ObjectPosition&quot;&gt;配置場所&lt;/param&gt;
            /// &lt;param name=&quot;CanRootMoveFreely&quot;&gt;基底ボーンが自由に動けるか&lt;/param&gt;
            public Graph(Path Root, Point3d ObjectPosition, bool CanRootMoveFreely)
                : this(Root, ObjectPosition, CanRootMoveFreely, 1.0)
            {
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Root&quot;&gt;基底のボーン&lt;/param&gt;
            /// &lt;param name=&quot;ObjectPosition&quot;&gt;配置場所&lt;/param&gt;
            /// &lt;param name=&quot;CanRootMoveFreely&quot;&gt;基底ボーンが自由に動けるか&lt;/param&gt;
            /// &lt;param name=&quot;Scale&quot;&gt;拡大率&lt;/param&gt;
            public Graph(Path Root, Point3d ObjectPosition, bool CanRootMoveFreely, double Scale)
            {
                this.AddScale = Scale;
                this.Position = ObjectPosition * AddScale;

                Brep[] newbp;
                newbp = new Brep[Root.ContentMember.Content.GetLength(0)];
                for (int i = 0; i &lt; Root.ContentMember.Content.GetLength(0); i++)
                {
                    newbp[i] = (Brep)Root.ContentMember.Content[i].Duplicate();
                    newbp[i].Scale(AddScale);
                }
                Root.ContentMember.Content = newbp;
                Root.Length *= AddScale;

                if (CanRootMoveFreely)
                {
                    RootPath = new Path() { Length = 0 };
                    NodesDic.Add(RootPath, new List&lt;Node&gt;() { new Node() { Target1 = RootPath, Target2 = Root, Radius = 0, ContentMember = new Brep[0] } });
                }
                else
                {
                    RootPath = Root;
                    NodesDic.Add(Root, new List&lt;Node&gt;());
                }
            }

            /// &lt;summary&gt;
            /// 3Dモデル(Brep)を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;3Dモデル&lt;/returns&gt;
            public Brep[] GetBrep()
            {
                Plane newpl = Plane.WorldXY;
                newpl.Transform(Transform.Rotation(RotationAngleX, newpl.XAxis, newpl.Origin));
                newpl.Transform(Transform.Rotation(RotationAngleY, newpl.YAxis, newpl.Origin));
                newpl.Transform(Transform.Rotation(RotationAngleZ, newpl.ZAxis, newpl.Origin));
                newpl.Origin = this.Position;
                List&lt;Brep[]&gt; ResultPre = GetBrepFromPath(this.RootPath, newpl);
                List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
                foreach (Brep[] bps in ResultPre)
                {
                    Result.AddRange(bps);
                }
                return Result.ToArray();
            }

            [System.Obsolete(&quot;This is old version. Use same function with Plane.&quot;)]
            private List&lt;Brep[]&gt; GetBrepFromPath(Path p, Point3d crtpos, double crtangx, double crtangy, double crtangz)
            {
                List&lt;Brep[]&gt; Result = new List&lt;Brep[]&gt;();
                Brep[] TempBreps = new Brep[p.ContentMember.Content.GetLength(0)];
                int cnt = 0;
                foreach (Brep bp in p.ContentMember.Content)
                {
                    Brep tempbp = (Brep)bp.Duplicate();
                    tempbp.Rotate(crtangx, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
                    tempbp.Rotate(crtangy, new Vector3d(0, 1, 0), new Point3d(0, 0, 0));
                    tempbp.Rotate(crtangz, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                    tempbp.Translate((Vector3d)crtpos);
                    TempBreps[cnt] = tempbp;
                    cnt++;
                }
                Result.Add(TempBreps);
                foreach (Node nd in this.NodesDic[p])
                {
                    Point3d cntpt = nd.GetConnectionPoint(p) + new Point3d(nd.Radius, 0, 0);
                    cntpt.Transform(Transform.Rotation(crtangx, new Vector3d(1, 0, 0), new Point3d(0, 0, 0)));
                    cntpt.Transform(Transform.Rotation(crtangy, new Vector3d(0, 1, 0), new Point3d(0, 0, 0)));
                    cntpt.Transform(Transform.Rotation(crtangz, new Vector3d(0, 0, 1), new Point3d(0, 0, 0)));

                    Point3d ndpt = new Point3d(nd.Radius, 0, 0);
                    ndpt.Transform(Transform.Rotation(crtangx + nd.RotationAngleX, new Vector3d(1, 0, 0), new Point3d(0, 0, 0)));
                    ndpt.Transform(Transform.Rotation(crtangy + nd.RotationAngleY, new Vector3d(0, 1, 0), new Point3d(0, 0, 0)));
                    ndpt.Transform(Transform.Rotation(crtangz + nd.RotationAngleZ, new Vector3d(0, 0, 1), new Point3d(0, 0, 0)));

                    Brep[] NodeBrep = new Brep[nd.ContentMember.Content.GetLength(0)];
                    for (int i = 0; i &lt; nd.ContentMember.Content.GetLength(0); i++)
                    {
                        if (nd.ContentMember.Content[i] == null) { continue; }
                        Brep tbp = (Brep)nd.ContentMember.Content[i].Duplicate();
                        tbp.Translate((Vector3d)(crtpos + cntpt));
                        NodeBrep[i] = tbp;
                    }
                    Result.Add(NodeBrep);

                    Result.AddRange(GetBrepFromPath(nd.GetPathOtherThan(p), crtpos + cntpt + ndpt, crtangx + nd.RotationAngleX, crtangy + nd.RotationAngleY, crtangz + nd.RotationAngleZ));
                }
                return Result;
            }

            private List&lt;Brep[]&gt; GetBrepFromPath(Path p, Plane pl)
            {
                List&lt;Brep[]&gt; Result = new List&lt;Brep[]&gt;();
                Brep[] TempBreps = new Brep[p.ContentMember.Content.GetLength(0)];
                int cnt = 0;
                foreach (Brep bp in p.ContentMember.Content)
                {
                    Brep tempbp = (Brep)bp.Duplicate();
                    tempbp.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));
                    TempBreps[cnt] = tempbp;
                    cnt++;
                }
                Result.Add(TempBreps);
                foreach (Node nd in this.NodesDic[p])
                {
                    Point3d cntpt = nd.GetConnectionPoint(p) + new Point3d(nd.Radius, 0, 0);
                    cntpt.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));

                    Plane newpl = new Plane(pl);
                    newpl.Transform(Transform.Rotation(nd.RotationAngleX, newpl.XAxis, newpl.Origin));
                    newpl.Transform(Transform.Rotation(nd.RotationAngleY, newpl.YAxis, newpl.Origin));
                    newpl.Transform(Transform.Rotation(nd.RotationAngleZ, newpl.ZAxis, newpl.Origin));
                    newpl.Origin = cntpt;

                    Point3d ndpt = (Point3d)(newpl.XAxis * nd.Radius);

                    Brep[] NodeBrep = new Brep[nd.ContentMember.Content.GetLength(0)];
                    for (int i = 0; i &lt; nd.ContentMember.Content.GetLength(0); i++)
                    {
                        if (nd.ContentMember.Content[i] == null) { continue; }
                        Brep tbp = (Brep)nd.ContentMember.Content[i].Duplicate();
                        tbp.Transform(Transform.ChangeBasis(newpl, Plane.WorldXY));
                        NodeBrep[i] = tbp;
                    }
                    Result.Add(NodeBrep);

                    Result.AddRange(GetBrepFromPath(nd.GetPathOtherThan(p), newpl));
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 3Dモデル(RealObject.Building)を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;3Dモデル&lt;/returns&gt;
            public RealObject.Building GetMember()
            {
                RealObject.Building Result = new RealObject.Building(&quot;Graph&quot;);
                Plane newpl = Plane.WorldXY;
                newpl.Transform(Transform.Rotation(RotationAngleX, newpl.XAxis, newpl.Origin));
                newpl.Transform(Transform.Rotation(RotationAngleY, newpl.YAxis, newpl.Origin));
                newpl.Transform(Transform.Rotation(RotationAngleZ, newpl.ZAxis, newpl.Origin));
                newpl.Origin = this.Position;
                Result.Add(GetMemberFromPath(this.RootPath, newpl).ToArray());
                return Result;
            }

            private List&lt;RealObject.Member&gt; GetMemberFromPath(Path p, Plane pl)
            {
                List&lt;RealObject.Member&gt; Result = new List&lt;RealObject.Member&gt;();

                int cnt = 0;
                RealObject.Member newmember = p.ContentMember.Duplicate();
                foreach (Brep bp in newmember.Content)
                {
                    bp.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));
                    newmember.Content[cnt] = bp;
                    cnt++;
                }
                Result.Add(newmember);

                foreach (Node nd in this.NodesDic[p])
                {
                    Point3d cntpt = nd.GetConnectionPoint(p) + new Point3d(nd.Radius, 0, 0);
                    cntpt.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));

                    Plane newpl = new Plane(pl);
                    newpl.Transform(Transform.Rotation(nd.RotationAngleX, newpl.XAxis, newpl.Origin));
                    newpl.Transform(Transform.Rotation(nd.RotationAngleY, newpl.YAxis, newpl.Origin));
                    newpl.Transform(Transform.Rotation(nd.RotationAngleZ, newpl.ZAxis, newpl.Origin));
                    newpl.Origin = cntpt;

                    Point3d ndpt = (Point3d)(newpl.XAxis * nd.Radius);

                    RealObject.Member newmember2 = nd.ContentMember.Duplicate();
                    for (int i = 0; i &lt; nd.ContentMember.Content.GetLength(0); i++)
                    {
                        if (nd.ContentMember.Content[i] == null) { continue; }
                        Brep tbp = (Brep)nd.ContentMember.Content[i].Duplicate();
                        tbp.Transform(Transform.ChangeBasis(newpl, Plane.WorldXY));
                        newmember2.Content[i] = tbp;
                    }
                    Result.Add(newmember2);

                    Result.AddRange(GetMemberFromPath(nd.GetPathOtherThan(p), newpl));
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// デッサン人形風のIKモデルを取得します。添景として利用できます。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
            /// &lt;returns&gt;IKモデル&lt;/returns&gt;
            public static Graph GetHumanBody(double Height)
            {
                Graph Result = new Graph(Path.CreateFromPipeSimple(new double[] { 0, 15, 30 }, new double[] { 20, 20, 15 }), new Point3d(0, 0, 165), false, Height / 260.0);
                Result.RotationAngleY = -Math.PI / 2.0;
                List&lt;Node&gt; HumanNodes = new List&lt;Node&gt;();

                Path chest = Path.CreateFromPipeSimple(new double[] { 0, 40, 50 }, new double[] { 15, 20, 10 });
                HumanNodes.Add(Result.Add(Result.RootPath, chest, 15, 15));
                HumanNodes[0].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);
                HumanNodes[0].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);
                HumanNodes[0].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);

                Path head = Path.CreateFromPipeHead(new double[] { 0, 30, 45 }, new double[] { 12, 15 });
                HumanNodes.Add(Result.Add(chest, head, 7.5, 7.5));
                HumanNodes[1].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 80, Math.PI / 180.0 * 80);
                HumanNodes[1].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);
                HumanNodes[1].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);

                Path handR1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 30, 45 }, new double[] { 7.5, 9.0, 7, 6 });
                HumanNodes.Add(Result.Add(chest, new Point3d(40, 23, 0), handR1, Node.CreateFromSphere(8, 6)));
                HumanNodes[2].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

                Path handR2 = Path.CreateFromPipeSimple(new double[] { 0, 20, 40 }, new double[] { 7, 8.0, 7 });
                HumanNodes.Add(Result.Add(handR1, handR2, 7.5, 4.0));
                HumanNodes[3].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

                Path handR3 = new Path() { ContentMember = new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, 20), new Interval(-6, 6), new Interval(-1.5, 1.5))) } };
                HumanNodes.Add(Result.Add(handR2, handR3, 4, 3));
                HumanNodes[4].RotationAngleZLimitation = new Interval(0, 0);
                HumanNodes[4].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);
                HumanNodes[4].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);

                Path handL1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 30, 45 }, new double[] { 7.5, 9.0, 7, 6 });
                HumanNodes.Add(Result.Add(chest, new Point3d(40, -23, 0), handL1, Node.CreateFromSphere(8, 6)));
                HumanNodes[5].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

                Path handL2 = Path.CreateFromPipeSimple(new double[] { 0, 20, 40 }, new double[] { 7, 8.0, 7 });
                HumanNodes.Add(Result.Add(handL1, handL2, 7.5, 4.0));
                HumanNodes[6].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

                Path handL3 = new Path() { ContentMember = new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, 20), new Interval(-6, 6), new Interval(-1.5, 1.5))) } };
                HumanNodes.Add(Result.Add(handL2, handL3, 4, 3));
                HumanNodes[7].RotationAngleZLimitation = new Interval(0, 0);
                HumanNodes[7].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);
                HumanNodes[7].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);

                Path legR1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 40, 60 }, new double[] { 7.5, 10.0, 7.5, 7.0 });
                HumanNodes.Add(Result.Add(Result.RootPath, new Point3d(-1.5, 15, 0), legR1, Node.CreateFromSphere(7.5, 6)));
                HumanNodes[8].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);
                HumanNodes[8].RotationAngleYLimitation = new Interval(Math.PI * 0.5, Math.PI * 1.5);
                HumanNodes[8].RotationAngleXLimitation = new Interval(0, 0);

                Path legR2 = Path.CreateFromPipeSimple(new double[] { 0, 15.0, 45, 65 }, new double[] { 7.5, 8.5, 7.5, 6.5 });
                HumanNodes.Add(Result.Add(legR1, legR2, 6, 5));
                HumanNodes[9].RotationAngleZLimitation = new Interval(0, 0);
                HumanNodes[9].RotationAngleYLimitation = new Interval(-Math.PI, 0);
                HumanNodes[9].RotationAngleXLimitation = new Interval(-Math.PI, 0);

                Brep shoes = Providers.GetPipeHalf(new double[] { -10, 20, 30 }, new double[] { 9, 9, 0 });
                shoes.Rotate(-Math.PI / 2.0, new Vector3d(0, 1, 0), new Point3d(0, 0, 0));
                shoes.Translate(11, 0, 0);

                Path legR3 = new Path() { ContentMember = new Brep[] { (Brep)shoes.Duplicate() } };
                HumanNodes.Add(Result.Add(legR2, legR3, 4, 2.5));
                HumanNodes[10].RotationAngleZLimitation = new Interval(0, 0);
                HumanNodes[10].RotationAngleYLimitation = new Interval(-Math.PI / 4.0, Math.PI / 4.0);
                HumanNodes[10].RotationAngleXLimitation = new Interval(-Math.PI / 2.0, Math.PI / 2.0);

                Path legL1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 40, 60 }, new double[] { 7.5, 10.0, 7.5, 7.0 });
                HumanNodes.Add(Result.Add(Result.RootPath, new Point3d(-1.5, -15, 0), legL1, Node.CreateFromSphere(7.5, 6)));
                HumanNodes[11].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);
                HumanNodes[11].RotationAngleYLimitation = new Interval(Math.PI * 0.5, Math.PI * 1.5);
                HumanNodes[11].RotationAngleXLimitation = new Interval(0, 0);

                Path legL2 = Path.CreateFromPipeSimple(new double[] { 0, 15.0, 45, 65 }, new double[] { 7.5, 8.5, 7.5, 6.5 });
                HumanNodes.Add(Result.Add(legL1, legL2, 6, 5));
                HumanNodes[12].RotationAngleZLimitation = new Interval(0, 0);
                HumanNodes[12].RotationAngleYLimitation = new Interval(-Math.PI, 0);
                HumanNodes[12].RotationAngleXLimitation = new Interval(-Math.PI, 0);

                Path legL3 = new Path() { ContentMember = new Brep[] { (Brep)shoes.Duplicate() } };
                HumanNodes.Add(Result.Add(legL2, legL3, 4, 2.5));
                HumanNodes[13].RotationAngleZLimitation = new Interval(0, 0);
                HumanNodes[13].RotationAngleYLimitation = new Interval(-Math.PI / 4.0, Math.PI / 4.0);
                HumanNodes[13].RotationAngleXLimitation = new Interval(-Math.PI / 2.0, Math.PI / 2.0);

                return Result;

            }
        }
    }
#endregion

#region ..\LSystem.cs

    /// &lt;summary&gt;
    /// LSystemに関係する機能を含みます。
    /// &lt;/summary&gt;
    public class LSystem
    {
        /// &lt;summary&gt;
        /// 毎ステップ適用するルール。
        /// &lt;/summary&gt;
        public Rule[] Rules;
        /// &lt;summary&gt;
        /// 現在のツリー
        /// &lt;/summary&gt;
        public Sequence Tree;
        /// &lt;summary&gt;
        /// 初期の状態
        /// &lt;/summary&gt;
        public Sequence InitialState;
        /// &lt;summary&gt;
        /// 現在の世代
        /// &lt;/summary&gt;
        public int Generation { get; private set; }
        /// &lt;summary&gt;
        /// ツリーを構成する要素
        /// &lt;/summary&gt;
        public Dictionary&lt;string, BodyType&gt; BodyTypes { get; private set; }

        /// &lt;summary&gt;
        /// ルールを指定回数適用する。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cnt&quot;&gt;適用回数&lt;/param&gt;
        public void ApplyRules(int cnt)
        {
            for (int i = 0; i &lt; cnt; i++)
            {
                ApplyRules();
            }
        }

        /// &lt;summary&gt;
        /// ルールを一度適用する。
        /// &lt;/summary&gt;
        public void ApplyRules()
        {
            Generation++;
            foreach (Rule rl in Rules)
            {
                Tree = Tree.ApplyRule(rl, Generation);
            }
        }

        /// &lt;summary&gt;
        /// コンストラクタ
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Initial&quot;&gt;初期の状態&lt;/param&gt;
        /// &lt;param name=&quot;Rules&quot;&gt;ルール&lt;/param&gt;
        public LSystem(Sequence Initial, Rule[] Rules)
        {
            InitialState = Initial.Duplicate();
            Tree = Initial.Duplicate();
            this.Rules = Rules;
            Generation = 0;
            BodyTypes = new Dictionary&lt;string, BodyType&gt;();
        }

        /// &lt;summary&gt;
        /// ツリー構成要素を追加する
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;bts&quot;&gt;追加要素&lt;/param&gt;
        public void RegisterBodyType(params BodyType[] bts)
        {
            foreach (BodyType bt in bts)
            {
                BodyTypes.Add(bt.Name, bt);
            }
        }

        /// &lt;summary&gt;
        /// ツリーを構成する要素
        /// &lt;/summary&gt;
        public class BodyType
        {
            /// &lt;summary&gt;
            /// 名前
            /// &lt;/summary&gt;
            public readonly string Name;
            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;名前&lt;/param&gt;
            public BodyType(string name) { Name = name; }

            public override string ToString() { return Name; }
        }

        /// &lt;summary&gt;
        /// 要素の連続を表します。
        /// &lt;/summary&gt;
        public class Sequence
        {
            /// &lt;summary&gt;
            /// 含まれる要素。
            /// &lt;/summary&gt;
            public List&lt;Body&gt; Content = new List&lt;Body&gt;();

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            public Sequence()
            {
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;BodyTypes&quot;&gt;要素&lt;/param&gt;
            public Sequence(params BodyType[] BodyTypes)
            {
                for (int i = 0; i &lt; BodyTypes.Count(); i++)
                {
                    Content.Add(new Body(BodyTypes[i]));
                }
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Gen&quot;&gt;設定世代&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public Sequence Duplicate(int Gen)
            {
                List&lt;Body&gt; Result = new List&lt;Body&gt;();
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.Add(Content[i].Duplicate(Gen));
                }
                return new Sequence() { Content = Result };
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Sequence Duplicate()
            {
                List&lt;Body&gt; Result = new List&lt;Body&gt;();
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.Add(Content[i].Duplicate());
                }
                return new Sequence() { Content = Result };
            }

            /// &lt;summary&gt;
            /// ルールを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rl&quot;&gt;ルール&lt;/param&gt;
            /// &lt;param name=&quot;CurrentGeneration&quot;&gt;現在の世代&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public Sequence ApplyRule(Rule rl, int CurrentGeneration)
            {
                List&lt;Body&gt; Result = new List&lt;Body&gt;();
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    if (Content[i].BodyType == rl.Target)
                    {
                        Result.AddRange(rl.Result.Duplicate(CurrentGeneration).Content);
                    }
                    else
                    {
                        Result.Add(Content[i].ApplyRule(rl, CurrentGeneration));
                    }
                }
                return new Sequence() { Content = Result };
            }

            public override string ToString()
            {
                string result = &quot;&quot;;
                for (int i = 0; i + 1 &lt; Content.Count(); i++)
                {
                    result += Content[i].ToString();
                    result += &quot;,&quot;;
                }
                result += Content[Content.Count() - 1].ToString();
                return result;
            }

        }

        /// &lt;summary&gt;
        /// 分岐を示します。
        /// &lt;/summary&gt;
        public class Body
        {
            /// &lt;summary&gt;
            /// 世代
            /// &lt;/summary&gt;
            public int Generation;
            /// &lt;summary&gt;
            /// 子要素
            /// &lt;/summary&gt;
            public Sequence[] Child = new Sequence[0];
            /// &lt;summary&gt;
            /// 要素の種類
            /// &lt;/summary&gt;
            public BodyType BodyType;

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;type&quot;&gt;要素の種類&lt;/param&gt;
            public Body(BodyType type) { this.BodyType = type; }

            /// &lt;summary&gt;
            /// 複製する
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Body Duplicate()
            {
                return Duplicate(this.Generation);
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Gen&quot;&gt;設定世代&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public Body Duplicate(int Gen)
            {
                Sequence[] NewChild = new Sequence[Child.GetLength(0)];
                for (int i = 0; i &lt; Child.GetLength(0); i++)
                {
                    NewChild[i] = Child[i].Duplicate(Gen);
                }
                return new Body(this.BodyType) { Child = NewChild, Generation = Gen };
            }

            /// &lt;summary&gt;
            /// ルールを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rl&quot;&gt;ルール&lt;/param&gt;
            /// &lt;param name=&quot;CurrentGeneration&quot;&gt;現在の世代&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public Body ApplyRule(Rule rl, int CurrentGeneration)
            {
                Sequence[] NewChild = new Sequence[Child.GetLength(0)];
                for (int i = 0; i &lt; Child.GetLength(0); i++)
                {
                    NewChild[i] = Child[i].ApplyRule(rl, CurrentGeneration);
                }
                return new Body(this.BodyType) { Child = NewChild, Generation = this.Generation };
            }

            public override string ToString()
            {
                string result = &quot;&quot;;
                result += BodyType.ToString();
                for (int i = 0; i &lt; Child.GetLength(0); i++)
                {
                    result += &quot;[&quot;;
                    result += Child[i].ToString();
                    result += &quot;]&quot;;
                }
                result += &quot;&quot; + this.Generation;
                return result;
            }

        }

        /// &lt;summary&gt;
        /// ルールを示します。
        /// &lt;/summary&gt;
        public interface Rule
        {
            /// &lt;summary&gt;
            /// 変換元
            /// &lt;/summary&gt;
            BodyType Target { get; set; }
            /// &lt;summary&gt;
            /// 変換結果
            /// &lt;/summary&gt;
            Sequence Result { get; }
        }

        /// &lt;summary&gt;
        /// 単純な置き換えルールを示します。
        /// &lt;/summary&gt;
        public class RuleSimple : Rule
        {
            public BodyType Target { get; set; }
            public Sequence Result { get; set; }
        }

        /// &lt;summary&gt;
        /// 確率的に変化するルールを示します。
        /// &lt;/summary&gt;
        public class RuleProbability : Rule
        {
            public BodyType Target { get; set; }
            public Sequence Result { get { return GetResult(); } }

            private Dictionary&lt;Sequence, double&gt; Rules;
            private Random rand;

            public RuleProbability()
                : this(new Random())
            {
            }

            public RuleProbability(Random rd)
            {
                rand = rd;
                Rules = new Dictionary&lt;Sequence, double&gt;();
            }
            /// &lt;summary&gt;
            /// 変化可能な連続要素を追加します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Content&quot;&gt;追加要素&lt;/param&gt;
            /// &lt;param name=&quot;Rate&quot;&gt;変化確率&lt;/param&gt;
            public void AddSequence(Sequence Content, double Rate)
            {
                Rules.Add(Content.Duplicate(), Rate);
            }

            /// &lt;summary&gt;
            /// 結果を取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            private Sequence GetResult()
            {
                double randResult = rand.NextDouble();
                double PosSum = 0.0;

                foreach (var kvp in Rules)
                {
                    if (PosSum &lt;= randResult &amp;&amp; randResult &lt; PosSum + kvp.Value)
                    {
                        return kvp.Key;
                    }
                    PosSum += kvp.Value;
                }
                return new Sequence() { Content = new List&lt;Body&gt;() { new Body(Target) } };
            }
        }
    }
#endregion

#region ..\PanelBuilder.cs

    /// &lt;summary&gt;
    /// プレゼンテーション用のパネルを示します。
    /// 余り恰好は良くないので非推奨です。
    /// &lt;/summary&gt;
    public class PanelBuilder
    {
        /// &lt;summary&gt;
        /// 出力先のドキュメント
        /// &lt;/summary&gt;
        public Rhino.RhinoDoc Document;
        /// &lt;summary&gt;
        /// ランダムインスタンス
        /// &lt;/summary&gt;
        public Random Rand;
        /// &lt;summary&gt;
        /// 画像などを出力するディレクトリ
        /// &lt;/summary&gt;
        public string CurrentDirectory;
        /// &lt;summary&gt;
        /// 現在のレイヤー番号
        /// &lt;/summary&gt;
        public int CurrentLayer = 0;

        /// &lt;summary&gt;
        /// コンストラクタ
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Doc&quot;&gt;出力先のドキュメント&lt;/param&gt;
        /// &lt;param name=&quot;currentDirectory&quot;&gt;画像などを出力するディレクトリ&lt;/param&gt;
        public PanelBuilder(RhinoDoc Doc, string currentDirectory)
        {
            Document = Doc;
            Rand = new Random();
            this.CurrentDirectory = currentDirectory;
        }

        /// &lt;summary&gt;
        /// モデルに3Dモデルを追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;モデル名&lt;/param&gt;
        /// &lt;param name=&quot;col&quot;&gt;色&lt;/param&gt;
        /// &lt;param name=&quot;content&quot;&gt;Brep&lt;/param&gt;
        public void Add(string name, Color col, params Brep[] content)
        {
            int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
            if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
            int GroupIndex = Document.Groups.Add(name + Rand.Next(100000));

            Material m = new Material();
            m.DiffuseColor = col;
            int matidx = Document.Materials.Add(m);

            foreach (Brep bp in content)
            {
                ObjectAttributes oba = new ObjectAttributes();
                oba.LayerIndex = layerIndex;
                oba.AddToGroup(GroupIndex);
                oba.MaterialIndex = matidx;
                oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
                Document.Objects.AddBrep(bp, oba);
            }
        }

        /// &lt;summary&gt;
        /// ISO 216のAシリーズの紙を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;a&quot;&gt;番号(Anのn)&lt;/param&gt;
        /// &lt;param name=&quot;Landscape&quot;&gt;向き(trueで横向き)&lt;/param&gt;
        public void AddPaperSizeA(int a, bool Landscape)
        {
            AddPaperSizeA(a, Landscape, Color.White);
        }

        /// &lt;summary&gt;
        /// ISO 216のAシリーズの紙を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;a&quot;&gt;番号(Anのn)&lt;/param&gt;
        /// &lt;param name=&quot;Landscape&quot;&gt;向き(trueで横向き)&lt;/param&gt;
        /// &lt;param name=&quot;col&quot;&gt;紙の色&lt;/param&gt;
        public void AddPaperSizeA(int a, bool Landscape, Color col)
        {
            this.Add(&quot;Paper:A&quot; + a, col, Providers.GetPaperSizeA(a, Landscape));
        }

        /// &lt;summary&gt;
        /// 指定座標に押しピンを刺します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;point&quot;&gt;座標&lt;/param&gt;
        public void Pin(Point2d point)
        {
            RealObject.Building pin = Providers.GetThumbtack();
            pin.Transform(Transform.Rotation(-Math.PI / 2.0, Point3d.Origin));

            double AngleDifference = Math.PI / 12.0;
            Random rd = new Random();
            pin.Transform(Transform.Rotation(-AngleDifference / 2.0 + Rand.NextDouble() * AngleDifference / 2.0, new Vector3d(0, 0, 1), Point3d.Origin));
            pin.Transform(Transform.Rotation(-AngleDifference / 2.0 + Rand.NextDouble() * AngleDifference / 2.0, new Vector3d(1, 0, 0), Point3d.Origin));
            pin.Transform(Transform.Translation(point.X, -5.0, point.Y));

            pin.Bake(Document);
        }

        /// &lt;summary&gt;
        /// 色付きの紙を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;col&quot;&gt;色&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;追加場所&lt;/param&gt;
        /// &lt;param name=&quot;width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
        public void AddColorPaper(Color col, Point2d point, double width, double height)
        {
            Brep paper = Brep.CreatePlanarBreps(new Rectangle3d(new Plane(new Point3d(point.X, -0.5, point.Y), Vector3d.XAxis, Vector3d.ZAxis), width, height).ToNurbsCurve())[0];
            Material m = new Material();
            m.DiffuseColor = col;
            int matidx = Document.Materials.Add(m);

            string name = &quot;ColorPaper&quot;;
            int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
            if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
            ObjectAttributes oba = new ObjectAttributes();
            oba.LayerIndex = layerIndex;
            oba.MaterialIndex = matidx;
            oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
            Document.Objects.AddBrep(paper, oba);
        }

        /// &lt;summary&gt;
        /// 3D文字を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;thickness&quot;&gt;太さ&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        /// &lt;param name=&quot;cl&quot;&gt;色&lt;/param&gt;
        public void AddText3d(string text, double height, double thickness, Point2d point, Color cl)
        {
            Brep[] texts = Providers.GetTextBrep(text, height, thickness);
            texts = GeneralHelper.RotateBreps(texts, Math.PI / 2.0, Vector3d.XAxis);
            texts = GeneralHelper.TranslateBreps(texts, new Point3d(point.X, 0, point.Y));
            this.Add(&quot;Text3d&quot;, cl, texts);
        }
        /// &lt;summary&gt;
        /// 3D文字を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        /// &lt;param name=&quot;cl&quot;&gt;色&lt;/param&gt;
        /// &lt;param name=&quot;fontname&quot;&gt;フォント名&lt;/param&gt;
        public void AddText3d(string text, double height, double thickness, Point2d point, Color cl, string fontname)
        {
            Brep[] texts = Providers.GetTextBrep(text, height, thickness, fontname, false, false, this.Document);
            texts = GeneralHelper.RotateBreps(texts, Math.PI / 2.0, Vector3d.XAxis);
            texts = GeneralHelper.TranslateBreps(texts, new Point3d(point.X, 0, point.Y));
            this.Add(&quot;Text3d&quot;, cl, texts);
        }

        /// &lt;summary&gt;
        /// 写真を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;url&quot;&gt;写真のアドレス&lt;/param&gt;
        /// &lt;param name=&quot;dpi&quot;&gt;解像度。dpiで指定。72が標準的です。&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        public void AddPhoto(string url, double dpi, Point2d point)
        {
            System.Drawing.Bitmap bmp = new Bitmap(url);
            double inchToMm = 25.4;

            Brep paper = Brep.CreatePlanarBreps(new Rectangle3d(new Plane(new Point3d(0, 0, 0), Vector3d.XAxis, Vector3d.ZAxis), new Point3d(-bmp.Width / dpi * inchToMm / 2.0, 0, 0), new Point3d(bmp.Width / dpi * inchToMm / 2.0, 0, -bmp.Height / dpi * inchToMm)).ToNurbsCurve())[0];

            Material m = new Material();
            m.SetBitmapTexture(url);
            int matidx = Document.Materials.Add(m);

            paper.Translate(point.X, -2.5 + CurrentLayer * 0.1, point.Y);

            string name = &quot;Photo&quot;;
            int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
            if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
            ObjectAttributes oba = new ObjectAttributes();
            oba.LayerIndex = layerIndex;
            oba.MaterialIndex = matidx;
            oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
            Document.Objects.AddBrep(paper, oba);

            this.Pin(point + new Vector2d(0, -10));

            CurrentLayer++;
        }

        /// &lt;summary&gt;
        /// XMLで設定されたレイアウト設定付きのテキストを追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;url&quot;&gt;XMLのアドレス&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        public void AddTextXml(string url, Point2d point)
        {
            AddTextXml(Generator.ReadTextXml(url), System.IO.Path.GetFileNameWithoutExtension(url), point);
        }

        /// &lt;summary&gt;
        /// XMLで設定されたレイアウト設定付きのテキストを追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;xmlobj&quot;&gt;XMLのアドレス&lt;/param&gt;
        /// &lt;param name=&quot;filename&quot;&gt;画像ファイル名&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        public void AddTextXml(Schemas.text xmlobj, string filename, Point2d point)
        {
            double scale = 5.0;
            Bitmap bp = Generator.CreateTextBitmap(xmlobj, scale);
            string fn = GetImageSavePath(filename);
            if (!System.IO.Directory.Exists(System.IO.Path.GetDirectoryName(fn))) { System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(fn)); }
            bp.Save(fn);

            this.AddPhoto(fn, 72 * scale, point);
        }

        /// &lt;summary&gt;
        /// 一時画像フォルダが保存される場所を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;filename&quot;&gt;元ファイル名&lt;/param&gt;
        /// &lt;returns&gt;保存先&lt;/returns&gt;
        public string GetImageSavePath(string filename)
        {
            return CurrentDirectory + @&quot;\Texture\&quot; + filename + &quot;.png&quot;;
        }

        /// &lt;summary&gt;
        /// タイトル付き画像を追加します
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;head&quot;&gt;タイトル&lt;/param&gt;
        /// &lt;param name=&quot;Content&quot;&gt;内容&lt;/param&gt;
        /// &lt;param name=&quot;width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;場所&lt;/param&gt;
        public void AddText(string head, string Content, double width, double height, Point2d point)
        {
            Schemas.text txt = new Schemas.text();
            txt.width = width;
            txt.height = height;
            string[] SeparetedContent = Content.Split(&apos;\n&apos;);
            List&lt;Object&gt; Body = new List&lt;object&gt;();
            Body.Add(head);

            foreach (string st in SeparetedContent)
            {
                Schemas.textParagraph1 tp1 = new Schemas.textParagraph1();
                tp1.Items = new string[] { st };
                tp1.ItemsElementName = new Schemas.ItemsChoiceType[] { Schemas.ItemsChoiceType.plain };
                Body.Add(tp1);
            }
            txt.body = Body.ToArray();

            AddTextXml(txt, Rand.Next(0, (int)1e5).ToString(), point);
        }

        /// &lt;summary&gt;
        /// 文字のみが記された紙を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;内容&lt;/param&gt;
        /// &lt;param name=&quot;fontname&quot;&gt;フォント名&lt;/param&gt;
        /// &lt;param name=&quot;fontsize&quot;&gt;フォントサイズ&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        /// &lt;param name=&quot;marginh&quot;&gt;水平方向の余白&lt;/param&gt;
        /// &lt;param name=&quot;marginv&quot;&gt;垂直方向の余白&lt;/param&gt;
        public void AddTextSimple(string text, string fontname, float fontsize, Point2d point, double marginh, double marginv)
        {
            AddTextSimple(text, fontname, fontsize, new FontStyle(), point, marginh, marginv, Color.White, Color.Black);
        }

        /// &lt;summary&gt;
        /// 文字のみが記された紙を追加します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;内容&lt;/param&gt;
        /// &lt;param name=&quot;fontname&quot;&gt;フォント名&lt;/param&gt;
        /// &lt;param name=&quot;fontsize&quot;&gt;フォントサイズ&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        /// &lt;param name=&quot;marginh&quot;&gt;水平方向の余白&lt;/param&gt;
        /// &lt;param name=&quot;marginv&quot;&gt;垂直方向の余白&lt;/param&gt;
        /// &lt;param name=&quot;Background&quot;&gt;背景色&lt;/param&gt;
        /// &lt;param name=&quot;ForeGround&quot;&gt;文字色&lt;/param&gt;
        public void AddTextSimple(string text, string fontname, float fontsize, FontStyle fs, Point2d point, double marginh, double marginv, Color Background, Color ForeGround)
        {
            float scale = 5;
            Bitmap bp = new Bitmap(640, 480);
            System.Drawing.Font f = new System.Drawing.Font(fontname, fontsize * scale, fs);
            Graphics g = Graphics.FromImage(bp);
            SizeF size = g.MeasureString(text, f);
            int pwidth = (int)((size.Width + marginh * 2 * scale));
            int pheight = (int)((size.Height + marginv * 2 * scale));
            bp = new Bitmap(pwidth, pheight);
            g = Graphics.FromImage(bp);
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
            g.DrawString(text, f, new SolidBrush(ForeGround), new PointF((int)(marginh * scale), (int)(marginv * scale)));
            string filename = GetImageSavePath(&quot;TextSimple&quot; + text);
            bp.Save(filename);

            Brep paper = Brep.CreatePlanarBreps(new Rectangle3d(new Plane(new Point3d(point.X - pwidth / scale / 2.0, -1.0, point.Y - pheight / scale / 2.0), Vector3d.XAxis, Vector3d.ZAxis), pwidth / scale, pheight / scale).ToNurbsCurve())[0];

            Material m = new Material();
            m.SetBitmapTexture(filename);
            m.DiffuseColor = Background;
            int matidx = Document.Materials.Add(m);

            string name = &quot;Tag&quot;;
            int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
            if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
            ObjectAttributes oba = new ObjectAttributes();
            oba.LayerIndex = layerIndex;
            oba.MaterialIndex = matidx;
            oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
            Document.Objects.AddBrep(paper, oba);
        }
        /// &lt;summary&gt;
        /// タグを追加できます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;text&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;fontname&quot;&gt;フォント名&lt;/param&gt;
        /// &lt;param name=&quot;fontSize&quot;&gt;フォントサイズ&lt;/param&gt;
        /// &lt;param name=&quot;width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;cl&quot;&gt;色&lt;/param&gt;
        /// &lt;param name=&quot;point&quot;&gt;配置場所&lt;/param&gt;
        /// &lt;param name=&quot;yvalue&quot;&gt;奥行&lt;/param&gt;
        public void AddTag(string text, string fontname, double fontSize, double width, double height, Color cl, Point2d point, double yvalue)
        {
            Curve cv = Curve.JoinCurves(new Curve[] { new Line(0, 0, 0, width / 2.5, 0, 0).ToNurbsCurve(), new Arc(new Point3d(width / 2.5, 0, 0), Vector3d.XAxis, new Point3d(width, -10, 0)).ToNurbsCurve() })[0];
            //Curve cv = Curve.CreateInterpolatedCurve(new Point3d[] { new Point3d(0, 0, 0), new Point3d(width / 2.5, 0, 0), }, 5);
            cv = cv.Rebuild(10, 5, true);
            Surface ExtSrf = Surface.CreateExtrusion(cv, new Vector3d(0, 0, height));
            ExtSrf = ExtSrf.Transpose();
            ExtSrf.Translate(point.X, -yvalue, point.Y);

            double scale = 3.0;
            Bitmap bp = new Bitmap((int)(scale * cv.GetLength()), (int)(scale * height));
            Graphics g = Graphics.FromImage(bp);
            g.FillRectangle(new SolidBrush(cl), new Rectangle(0, 0, (int)(height * scale), (int)(height * scale)));
            System.Drawing.Font font = new System.Drawing.Font(fontname, (float)(fontSize * scale));
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
            g.DrawString(text, font, Brushes.Black, new PointF((float)(scale * height), (float)((scale * height - font.GetHeight(72)) / 2.0)));

            string filenamebody = text;
            char[] invalidchar = Path.GetInvalidFileNameChars();
            foreach (char c in invalidchar)
            {
                filenamebody = filenamebody.Replace(c, &apos;_&apos;);
            }
            string filename = GetImageSavePath(&quot;Tag&quot; + filenamebody);
            bp.Save(filename);

            Material m = new Material();
            m.SetBitmapTexture(filename);
            m.DiffuseColor = Color.White;
            int matidx = Document.Materials.Add(m);

            string name = &quot;Tag&quot;;
            int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
            if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
            ObjectAttributes oba = new ObjectAttributes();
            oba.LayerIndex = layerIndex;
            oba.MaterialIndex = matidx;
            oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
            Document.Objects.AddBrep(Brep.CreateFromSurface(ExtSrf), oba);
        }


        /// &lt;summary&gt;
        /// XMLに対応するオブジェクト
        /// &lt;/summary&gt;
        public class Schemas
        {
            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            [System.Xml.Serialization.XmlRootAttribute(Namespace = &quot;kurema/PanelLayout/0.0&quot;, IsNullable = false)]
            public partial class text
            {

                private textHeading headingField;

                private textParagraph paragraphField;

                private object[] bodyField;

                private double widthField;

                private double heightField;

                public text()
                {
                    this.widthField = 640D;
                    this.heightField = 480D;
                }

                /// &lt;remarks/&gt;
                public textHeading heading
                {
                    get
                    {
                        return this.headingField;
                    }
                    set
                    {
                        this.headingField = value;
                    }
                }

                /// &lt;remarks/&gt;
                public textParagraph paragraph
                {
                    get
                    {
                        return this.paragraphField;
                    }
                    set
                    {
                        this.paragraphField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlArrayItemAttribute(&quot;heading&quot;, typeof(string), IsNullable = false)]
                [System.Xml.Serialization.XmlArrayItemAttribute(&quot;paragraph&quot;, typeof(textParagraph1), IsNullable = false)]
                public object[] body
                {
                    get
                    {
                        return this.bodyField;
                    }
                    set
                    {
                        this.bodyField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                [System.ComponentModel.DefaultValueAttribute(640D)]
                public double width
                {
                    get
                    {
                        return this.widthField;
                    }
                    set
                    {
                        this.widthField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                [System.ComponentModel.DefaultValueAttribute(480D)]
                public double height
                {
                    get
                    {
                        return this.heightField;
                    }
                    set
                    {
                        this.heightField = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            public partial class textHeading
            {

                private style styleField;

                /// &lt;remarks/&gt;
                public style style
                {
                    get
                    {
                        return this.styleField;
                    }
                    set
                    {
                        this.styleField = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            public partial class style
            {

                private styleFont fontField;

                private styleMargin marginField;

                /// &lt;remarks/&gt;
                public styleFont font
                {
                    get
                    {
                        return this.fontField;
                    }
                    set
                    {
                        this.fontField = value;
                    }
                }

                /// &lt;remarks/&gt;
                public styleMargin margin
                {
                    get
                    {
                        return this.marginField;
                    }
                    set
                    {
                        this.marginField = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            public partial class styleFont
            {

                private string nameField;

                private double sizeField;

                private bool sizeFieldSpecified;

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                public string name
                {
                    get
                    {
                        return this.nameField;
                    }
                    set
                    {
                        this.nameField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                public double size
                {
                    get
                    {
                        return this.sizeField;
                    }
                    set
                    {
                        this.sizeField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlIgnoreAttribute()]
                public bool sizeSpecified
                {
                    get
                    {
                        return this.sizeFieldSpecified;
                    }
                    set
                    {
                        this.sizeFieldSpecified = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            public partial class styleMargin
            {

                private double leftField;

                private double rightField;

                private double topField;

                private double bottomField;

                public styleMargin()
                {
                    this.leftField = 0D;
                    this.rightField = 0D;
                    this.topField = 0D;
                    this.bottomField = 0D;
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                [System.ComponentModel.DefaultValueAttribute(0D)]
                public double left
                {
                    get
                    {
                        return this.leftField;
                    }
                    set
                    {
                        this.leftField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                [System.ComponentModel.DefaultValueAttribute(0D)]
                public double right
                {
                    get
                    {
                        return this.rightField;
                    }
                    set
                    {
                        this.rightField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                [System.ComponentModel.DefaultValueAttribute(0D)]
                public double top
                {
                    get
                    {
                        return this.topField;
                    }
                    set
                    {
                        this.topField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlAttributeAttribute()]
                [System.ComponentModel.DefaultValueAttribute(0D)]
                public double bottom
                {
                    get
                    {
                        return this.bottomField;
                    }
                    set
                    {
                        this.bottomField = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            public partial class textParagraph
            {

                private style styleField;

                /// &lt;remarks/&gt;
                public style style
                {
                    get
                    {
                        return this.styleField;
                    }
                    set
                    {
                        this.styleField = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Diagnostics.DebuggerStepThroughAttribute()]
            [System.ComponentModel.DesignerCategoryAttribute(&quot;code&quot;)]
            [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = &quot;kurema/PanelLayout/0.0&quot;)]
            public partial class textParagraph1
            {

                private string[] itemsField;

                private ItemsChoiceType[] itemsElementNameField;

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlElementAttribute(&quot;bold&quot;, typeof(string))]
                [System.Xml.Serialization.XmlElementAttribute(&quot;plain&quot;, typeof(string))]
                [System.Xml.Serialization.XmlElementAttribute(&quot;underline&quot;, typeof(string))]
                [System.Xml.Serialization.XmlChoiceIdentifierAttribute(&quot;ItemsElementName&quot;)]
                public string[] Items
                {
                    get
                    {
                        return this.itemsField;
                    }
                    set
                    {
                        this.itemsField = value;
                    }
                }

                /// &lt;remarks/&gt;
                [System.Xml.Serialization.XmlElementAttribute(&quot;ItemsElementName&quot;)]
                [System.Xml.Serialization.XmlIgnoreAttribute()]
                public ItemsChoiceType[] ItemsElementName
                {
                    get
                    {
                        return this.itemsElementNameField;
                    }
                    set
                    {
                        this.itemsElementNameField = value;
                    }
                }
            }

            /// &lt;remarks/&gt;
            [System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;xsd&quot;, &quot;4.0.30319.1&quot;)]
            [System.SerializableAttribute()]
            [System.Xml.Serialization.XmlTypeAttribute(Namespace = &quot;kurema/PanelLayout/0.0&quot;, IncludeInSchema = false)]
            public enum ItemsChoiceType
            {

                /// &lt;remarks/&gt;
                bold,

                /// &lt;remarks/&gt;
                plain,

                /// &lt;remarks/&gt;
                underline,
            }


        }

        /// &lt;summary&gt;
        /// 関連する機能を含みます。
        /// &lt;/summary&gt;
        public class Generator
        {
            /// &lt;summary&gt;
            /// XMLファイルをデシリアライズします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;fileName&quot;&gt;ファイル名&lt;/param&gt;
            /// &lt;returns&gt;相当するオブジェクト&lt;/returns&gt;
            public static Schemas.text ReadTextXml(string fileName)
            {
                System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(Schemas.text));
                System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));
                Schemas.text text = (Schemas.text)serializer.Deserialize(sr);
                sr.Close();
                return text;
            }

            /// &lt;summary&gt;
            /// レイアウト設定付きの文字を画像化します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;text&quot;&gt;文字に相当するインスタンス&lt;/param&gt;
            /// &lt;param name=&quot;zoom&quot;&gt;拡大率&lt;/param&gt;
            /// &lt;returns&gt;画像&lt;/returns&gt;
            public static Bitmap CreateTextBitmap(Schemas.text text, double zoom = 1.0)
            {

                int x = (int)(text.width * zoom);
                int y = (int)(text.height * zoom);

                double mainMarginT = 0, mainMarginL = 0, mainMarginR = 0, mainMarginB = 0;
                double headMarginT = 0, headMarginL = 0, headMarginR = 0, headMarginB = 0;

                System.Drawing.Font HeadingFont;
                System.Drawing.Font MainFont;
                System.Drawing.Font MainFontBold;
                System.Drawing.Font MainFontUnderline;

                string fontnamedefault = &quot;游明朝&quot;;
                {
                    float fontsizedefault = (float)(12);
                    string fontname = &quot;&quot;;
                    float fontsize = fontsizedefault;
                    if (text.paragraph == null)
                    {
                        fontname = fontnamedefault;
                        fontsize = fontsizedefault;

                        mainMarginT = mainMarginL = mainMarginR = mainMarginT = 0.0;
                    }
                    else
                    {
                        fontname = text.paragraph.style.font.name == &quot;&quot; ? fontnamedefault : text.paragraph.style.font.name;
                        fontsize = text.paragraph.style.font.size &lt;= 0 ? fontsizedefault : (float)text.paragraph.style.font.size;

                        mainMarginT = text.paragraph.style.margin.top * zoom;
                        mainMarginL = text.paragraph.style.margin.left * zoom;
                        mainMarginR = text.paragraph.style.margin.right * zoom;
                        mainMarginB = text.paragraph.style.margin.bottom * zoom;
                    }
                    MainFont = new System.Drawing.Font(fontname, fontsize * (float)zoom);
                    MainFontBold = new System.Drawing.Font(fontname, fontsize * (float)zoom, FontStyle.Bold);
                    MainFontUnderline = new System.Drawing.Font(fontname, fontsize * (float)zoom, FontStyle.Underline);
                }
                {
                    float fontsizedefault = 25;
                    string fontname = &quot;&quot;;
                    float fontsize = fontsizedefault;
                    if (text.heading == null)
                    {
                        fontname = fontnamedefault;
                        fontsize = fontsizedefault;

                        headMarginT = headMarginL = headMarginR = headMarginT = 0.0;
                    }
                    else
                    {
                        fontname = text.heading.style.font.name == &quot;&quot; ? fontnamedefault : text.heading.style.font.name;
                        fontsize = text.heading.style.font.size &lt;= 0 ? fontsizedefault : (float)text.heading.style.font.size;

                        headMarginT = text.heading.style.margin.top * zoom;
                        headMarginL = text.heading.style.margin.left * zoom;
                        headMarginR = text.heading.style.margin.right * zoom;
                        headMarginB = text.heading.style.margin.bottom * zoom;
                    }
                    HeadingFont = new System.Drawing.Font(fontname, fontsize * (float)zoom);
                }

                Bitmap img = new Bitmap(x, y);
                Graphics g = Graphics.FromImage(img);
                g.FillRectangle(Brushes.White, 0, 0, x, y);
                double CurrentY = 0;
                double CurrentX = 0;

                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;

                for (int i = 0; i &lt; text.body.GetLength(0); i++)
                {
                    if (text.body[i] is string)
                    {
                        CurrentX = headMarginL;
                        CurrentY += headMarginT;

                        g.DrawString((string)text.body[i], HeadingFont, Brushes.Black, new PointF((int)CurrentX, (int)CurrentY));
                        CurrentY += HeadingFont.Height;

                        CurrentY += headMarginB;
                    }
                    else
                    {
                        CurrentX = mainMarginL;
                        CurrentY += mainMarginT;
                        for (int j = 0; j &lt; ((Schemas.textParagraph1)text.body[i]).Items.GetLength(0); j++)
                        {
                            System.Drawing.Font font;
                            if (((Schemas.textParagraph1)text.body[i]).ItemsElementName[j] == Schemas.ItemsChoiceType.bold)
                            {
                                font = MainFontBold;
                            }
                            else if (((Schemas.textParagraph1)text.body[i]).ItemsElementName[j] == Schemas.ItemsChoiceType.underline)
                            {
                                font = MainFontUnderline;
                            }
                            else
                            {
                                font = MainFont;
                            }

                            string baseText = ((Schemas.textParagraph1)text.body[i]).Items[j];
                            while (CurrentX + g.MeasureString(baseText, font).Width &gt; x - mainMarginR &amp;&amp; baseText.Length &gt; 0)
                            {
                                string currentText = baseText;
                                int SubTxtCount = 0;
                                while (CurrentX + g.MeasureString(currentText, font).Width &gt; x - mainMarginR &amp;&amp; currentText.Length &gt; 0)
                                {
                                    SubTxtCount++;
                                    currentText = baseText.Substring(0, baseText.Length - SubTxtCount);
                                }
                                if (SubTxtCount &gt; 0)
                                {
                                    g.DrawString(currentText, font, Brushes.Black, new PointF((int)CurrentX, (int)CurrentY));
                                    CurrentY += MainFont.Height;
                                    CurrentX = mainMarginR;
                                    baseText = baseText.Substring(baseText.Length - SubTxtCount);
                                    //g.DrawString(baseText.Substring(SubTxtCount+2), font, Brushes.Black, new PointF((int)CurrentX, (int)CurrentY));

                                }
                                else
                                {
                                    break;
                                }
                            }
                            g.DrawString(baseText, font, Brushes.Black, new PointF((int)CurrentX, (int)CurrentY));
                            CurrentX += g.MeasureString(baseText, font).Width;
                        }
                        CurrentY += MainFont.Height;
                        CurrentY += mainMarginB;
                    }
                }
                g.Dispose();
                return img;
            }
        }

    }
#endregion

#region ..\PlanObject.cs

    /// &lt;summary&gt;
    /// 図面を示します。レイヤー設定付きでBake可能です。
    /// &lt;/summary&gt;
    public class PlanObject
    {
        /// &lt;summary&gt;
        /// 建築全体の図面を示します。
        /// &lt;/summary&gt;
        public class Building
        {
            /// &lt;summary&gt;
            /// 名前
            /// &lt;/summary&gt;
            public String Name;
            /// &lt;summary&gt;
            /// 建築に含まれる階層。
            /// &lt;/summary&gt;
            public List&lt;Floor&gt; Content = new List&lt;Floor&gt;();

            /// &lt;summary&gt;
            /// 図面を曲線として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public Curve[] GetCurve()
            {
                List&lt;Curve&gt; Result = new List&lt;Curve&gt;();
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.AddRange(Content[i].GetCurve());
                }
                return Result.ToArray();
            }

            /// &lt;summary&gt;
            /// Transformを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Tf&quot;&gt;Transform&lt;/param&gt;
            public void Transform(Transform Tf)
            {
                List&lt;Floor&gt; Operated = new List&lt;Floor&gt;();
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    if (!Operated.Contains(Content[i]))
                    {
                        Content[i].Transform(Tf);
                        Operated.Add(Content[i]);
                    }
                }
            }

            /// &lt;summary&gt;
            /// Bake(Rhino Documentに出力)します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;RhinoDocument&quot;&gt;出力先&lt;/param&gt;
            /// &lt;param name=&quot;TargetFloor&quot;&gt;対象階層&lt;/param&gt;
            public void Bake(RhinoDoc RhinoDocument, int TargetFloor)
            {
                Content[TargetFloor].Bake(RhinoDocument, this.Name + &quot;:&quot;);

            }

            /// &lt;summary&gt;
            /// 複製します
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Building Duplicate()
            {
                Building Result = new Building(this.Name);
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.Content.Add(this.Content[i].Duplicate());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Name&quot;&gt;名前&lt;/param&gt;
            public Building(string Name)
            {
                this.Name = Name;
            }
        }

        /// &lt;summary&gt;
        /// 一階層分の平面図を示します。
        /// &lt;/summary&gt;
        public class Floor
        {
            /// &lt;summary&gt;
            /// 階層の名前
            /// &lt;/summary&gt;
            public String Name;
            /// &lt;summary&gt;
            /// 階高
            /// &lt;/summary&gt;
            public double Height;
            /// &lt;summary&gt;
            /// 階層に含まれる部材の平面図を示します。
            /// &lt;/summary&gt;
            public List&lt;Member&gt; Content = new List&lt;Member&gt;();

            /// &lt;summary&gt;
            /// Bake(Rhino Documentに出力)します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;RhinoDocument&quot;&gt;出力先&lt;/param&gt;
            /// &lt;param name=&quot;LayerNameHead&quot;&gt;出力時のレイヤー名の先端部分&lt;/param&gt;
            public void Bake(RhinoDoc RhinoDocument, string LayerNameHead)
            {
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Content[i].Bake(RhinoDocument, LayerNameHead + this.Name + &quot;.&quot;);
                }
            }

            /// &lt;summary&gt;
            /// Transformを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Tf&quot;&gt;Transform&lt;/param&gt;
            public void Transform(Transform Tf)
            {
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Content[i].Transform(Tf);
                }
            }

            /// &lt;summary&gt;
            /// 平面図を曲線の集合として取得します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;曲線&lt;/returns&gt;
            public Curve[] GetCurve()
            {
                List&lt;Curve&gt; Result = new List&lt;Curve&gt;();
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.AddRange(Content[i].GetCurve());
                }
                return Result.ToArray();
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Floor Duplicate()
            {
                Floor Result = new Floor(this.Name);
                Result.Height = this.Height;
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.Content.Add(this.Content[i].Duplicate());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// コンストラクタ。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Name&quot;&gt;名前&lt;/param&gt;
            public Floor(string Name)
            {
                this.Name = Name;
            }
        }

        /// &lt;summary&gt;
        /// 部材の平面図を示します。
        /// ここでの部材は平面図に描かれる建築の要素全てを含みます。
        /// &lt;/summary&gt;
        public class Member
        {
            /// &lt;summary&gt;
            /// 部材名
            /// &lt;/summary&gt;
            public String Name;

            /// &lt;summary&gt;
            /// 場所を示します。
            /// &lt;/summary&gt;
            public Point2d Point;
            /// &lt;summary&gt;
            /// 平面図の線を含みます。
            /// &lt;/summary&gt;
            public List&lt;Curve&gt; Content = new List&lt;Curve&gt;();
            /// &lt;summary&gt;
            /// 出力時の色を設定します。
            /// &lt;/summary&gt;
            public RealObject.Color Color = new RealObject.Color();

            /// &lt;summary&gt;
            /// 平面図を出力します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;平面図&lt;/returns&gt;
            public Curve[] GetCurve()
            {
                Curve[] Result = new Curve[Content.Count()];
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result[i] = (this.Content[i].DuplicateCurve());
                }
                return Result;
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Member Duplicate()
            {
                Member Result = new Member(this.Name);
                Result.Point = this.Point;
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Result.Content.Add(this.Content[i].DuplicateCurve());
                }

                return Result;
            }

            /// &lt;summary&gt;
            /// Transformを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Tf&quot;&gt;Transform&lt;/param&gt;
            public void Transform(Transform Tf)
            {
                for (int i = 0; i &lt; Content.Count(); i++)
                {
                    Content[i].Transform(Tf);
                }
            }

            /// &lt;summary&gt;
            /// Bake(Rhino Documentに出力)します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;RhinoDocument&quot;&gt;出力先&lt;/param&gt;
            /// &lt;param name=&quot;LayerNameHead&quot;&gt;レイヤー名の&lt;/param&gt;
            public void Bake(RhinoDoc RhinoDocument, String LayerNameHead)
            {
                string LayerName = LayerNameHead + this.Name;
                int layerIndex = RhinoDocument.Layers.Add(LayerName, System.Drawing.Color.Black);
                if (RhinoDocument.Layers.FindByFullPath(LayerName, true) &gt;= 0) { layerIndex = RhinoDocument.Layers.FindByFullPath(LayerName, true); }
                int GroupIndex = RhinoDocument.Groups.Add(this.ToString() + Guid.NewGuid().ToString());
                foreach (Curve cv in Content)
                {
                    ObjectAttributes oba = new ObjectAttributes();
                    oba.LayerIndex = layerIndex;

                    oba.ColorSource = this.Color.IsUndefined ? ObjectColorSource.ColorFromLayer : ObjectColorSource.ColorFromObject;
                    oba.ObjectColor = (System.Drawing.Color)this.Color;
                    oba.AddToGroup(GroupIndex);
                    RhinoDocument.Objects.AddCurve(cv, oba);
                }
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Name&quot;&gt;部材名&lt;/param&gt;
            public Member(string Name)
            {
                this.Name = Name;
            }
        }
    }
#endregion

#region ..\Providers.cs

    /// &lt;summary&gt;
    /// 建築などに関係する機能を多数含みます。
    /// &lt;/summary&gt;
    public static class Providers
    {
        /// &lt;summary&gt;
        /// 四角形を線として取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;p&quot;&gt;開始点&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve GetRectangle3d(Point3d p, double Width, double Height)
        {
            Polyline pl = new Polyline();
            pl.Add(p);
            pl.Add(p + Vector3d.XAxis * Width);
            pl.Add(p + Vector3d.XAxis * Width + Vector3d.YAxis * Height);
            pl.Add(p + Vector3d.YAxis * Height);
            pl.Add(p);
            return pl.ToNurbsCurve();
        }

        /// &lt;summary&gt;
        /// ISO 216のAシリーズの四角形を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;i&quot;&gt;番号(Anのn)&lt;/param&gt;
        /// &lt;param name=&quot;Landscape&quot;&gt;向き(trueで横向き)&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetPaperSizeA(int i, bool Landscape)
        {
            double width = 1189 * Math.Pow(2.0, -i / 2.0);
            double height = 841 * Math.Pow(2.0, -i / 2.0);
            if (!Landscape) { double temp; temp = height; height = width; width = height; }
            return Brep.CreatePlanarBreps(new Rectangle3d(Plane.WorldZX, height, width).ToNurbsCurve())[0];
        }

        /// &lt;summary&gt;
        /// 画鋲を取得します。
        /// &lt;/summary&gt;
        /// &lt;returns&gt;画鋲&lt;/returns&gt;
        public static RealObject.Building GetThumbtack()
        {
            RealObject.Building result = new RealObject.Building(&quot;Thumbtack&quot;);
            Polyline pl = new Polyline(3);
            pl.Add(5, 0, 0.5);
            pl.Add(-7.5, 0, 0.5);
            pl.Add(-10.0, 0, 0);
            result.Content.Add(new RealObject.Member(&quot;Needle&quot;)
            {
                Content = new Brep[]{
                Brep.CreateFromRevSurface(RevSurface.Create(pl.ToNurbsCurve(), new Line(0, 0, 0, 1, 0, 0)), true, true)},
                Material = new RealObject.Material(&quot;Silver&quot;),
                DeatailLevel = -1
            });

            Curve[] cv = Curve.JoinCurves(new Curve[]{
                    new Arc(new Point3d(0,0,4),new Point3d(1,0,2+Math.Sqrt(2)),new Point3d(2,0,2)).ToNurbsCurve(),
                    new Line(2,0,2,7,0,1.5).ToNurbsCurve(),
                    new Line(7,0,1.5,7,0,2.5).ToNurbsCurve(),
                    new Arc(new Point3d(7,0,2.5),new Point3d(7.3,0,2.2),new Point3d(7.5,0,0)).ToNurbsCurve()
                });

            result.Content.Add(new RealObject.Member(&quot;Body&quot;)
            {
                Content = new Brep[] { Brep.CreateFromRevSurface(RevSurface.Create(cv[0], new Line(0, 0, 0, 1, 0, 0)), true, true) },
                Material = new RealObject.Material(&quot;Plastic&quot;),
                DeatailLevel = 0
            });
            return result;
        }

        /// &lt;summary&gt;
        /// コッホ曲線を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Angle&quot;&gt;角度&lt;/param&gt;
        /// &lt;param name=&quot;Generation&quot;&gt;世代&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Polyline GetKochCurve(double Angle, int Generation)
        {
            Polyline result = new Polyline();

            double crtangle = 0.0;
            Point3d crtpt = new Point3d(0, 0, 0);
            LSystem lsys = GetKochCurveLSystem();
            for (int i = 0; i &lt; Generation; i++)
            {
                lsys.ApplyRules();
            }
            foreach (LSystem.Body bd in lsys.Tree.Content)
            {
                if (bd.BodyType == lsys.BodyTypes[&quot;F&quot;])
                {
                    crtpt += new Vector3d(Math.Cos(crtangle), Math.Sin(crtangle), 0);
                    result.Add(crtpt);
                }
                else if (bd.BodyType == lsys.BodyTypes[&quot;+&quot;])
                {
                    crtangle += Angle;
                }
                else if (bd.BodyType == lsys.BodyTypes[&quot;-&quot;])
                {
                    crtangle -= Angle;
                }
            }
            return result;
        }

        /// &lt;summary&gt;
        /// コッホ曲線を意味するLSystemを得ます。
        /// &lt;/summary&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static LSystem GetKochCurveLSystem()
        {
            LSystem.BodyType F = new LSystem.BodyType(&quot;F&quot;);
            LSystem.BodyType P = new LSystem.BodyType(&quot;+&quot;);
            LSystem.BodyType M = new LSystem.BodyType(&quot;-&quot;);

            LSystem.Sequence initseq = new LSystem.Sequence(F);

            LSystem.RuleSimple rs = new LSystem.RuleSimple()
            {
                Target = F,
                Result = new LSystem.Sequence(F, P, F, M, F, M, F, P, F)//F+F-F-F+F
            };

            LSystem treesys = new LSystem(initseq, new LSystem.Rule[] { rs });
            treesys.RegisterBodyType(F, P, M);
            return treesys;
        }

        /// &lt;summary&gt;
        /// 樹木に相当するLSystemを得ます。
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static LSystem GetTreeLSystem()
        {
            LSystem.BodyType B = new LSystem.BodyType(&quot;B&quot;);//branch
                                                           //LSystem.BodyType F = new LSystem.BodyType(&quot;F&quot;);//flower
            LSystem.BodyType L = new LSystem.BodyType(&quot;L&quot;);//leaf
            LSystem.BodyType G = new LSystem.BodyType(&quot;G&quot;);//growth
            LSystem.BodyType TR = new LSystem.BodyType(&quot;-&quot;);//turn_right
            LSystem.BodyType TL = new LSystem.BodyType(&quot;+&quot;);//turn_left
            LSystem.BodyType D = new LSystem.BodyType(&quot;D&quot;);//Divergence


            LSystem.Sequence initseq = new LSystem.Sequence(B, G);

            LSystem.RuleProbability rp = new LSystem.RuleProbability(new Random());
            rp.Target = G;
            rp.AddSequence(new LSystem.Sequence()
            {
                Content = new List&lt;LSystem.Body&gt;(){
            new LSystem.Body(D){
              Child = new LSystem.Sequence[]{
              new LSystem.Sequence(B, G, L),
              new LSystem.Sequence(TL, B, TL, B, G)
              }
              }
            }
            }, 0.5);
            rp.AddSequence(new LSystem.Sequence()
            {
                Content = new List&lt;LSystem.Body&gt;(){
            new LSystem.Body(D){
              Child = new LSystem.Sequence[]{
              new LSystem.Sequence(TR, B, G, L),
              new LSystem.Sequence(TL, B, L, G)
              }
              }
            }
            }, 0.5);

            LSystem treesys = new LSystem(initseq, new LSystem.Rule[] { rp });
            //treesys.RegisterBodyType(B, F, L, G, TR, TL, D);
            treesys.RegisterBodyType(B, L, G, TR, TL, D);
            return treesys;

        }

        /// &lt;summary&gt;
        /// 樹木に相当するIKを取得します。
        /// 世代が多いほどモデルが処理の負荷が大きくなります。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Generation&quot;&gt;世代&lt;/param&gt;
        /// &lt;returns&gt;樹木相当のIKモデル&lt;/returns&gt;
        public static GraphObject.Graph GetTreeGraph(int Generation)
        {
            LSystem lsys = GetTreeLSystem();
            lsys.ApplyRules(Generation);
            GraphObject.Graph Result = new GraphObject.Graph(new GraphObject.Path() { ContentMember = new Brep[0], Length = 0 }, new Point3d(0, 0, 0));
            Result.RotationAngleY = -Math.PI / 2.0;
            GraphObject.Path EndPath = Result.RootPath;
            GetTreeGraphBranch(ref Result, EndPath, lsys.Tree, lsys.BodyTypes, Math.PI / 6.0, 1500, 0.8, 60, 0.7, 0, Math.PI / 24.0, Math.PI / 6.0);
            return Result;
        }

        private static void GetTreeGraphBranch(ref GraphObject.Graph Result, GraphObject.Path EndPath, LSystem.Sequence sq, Dictionary&lt;string, LSystem.BodyType&gt; bodyTypes, double Angle, double BaseLength, double LengthRate, double BaseRad, double RadRate, double TwistAngle, double TwistAngleRange, double TwistAngleTwisted)
        {
            Brep LeafBrep;
            //LeafBrep = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, 40), new Interval(-6, 6), new Interval(-1, 0)));
            {
                Curve LeafBaseCrv1 = Curve.CreateInterpolatedCurve(new Point3d[] { new Point3d(0, 0, 0), new Point3d(60, 50, 0), new Point3d(200, 0, 0) }, 3);
                Curve LeafBaseCrv2 = (Curve)LeafBaseCrv1.Duplicate();
                LeafBaseCrv2.Transform(Transform.Mirror(Plane.WorldZX));
                Curve LeafBaseCrv = Curve.JoinCurves(new Curve[] { LeafBaseCrv1, LeafBaseCrv2 })[0];
                LeafBrep = Brep.CreatePlanarBreps(new Curve[] { LeafBaseCrv })[0];
            }
            foreach (LSystem.Body bd in sq.Content)
            {
                if (bd.BodyType == bodyTypes[&quot;B&quot;])
                {
                    //GraphObject.Path TmpPath = GraphObject.Path.CreateFromPipeSimple(new double[] { 0, BaseLength * Math.Pow(LengthRate, bd.Generation) }, new double[] { BaseRad * Math.Pow(RadRate, bd.Generation), BaseRad * Math.Pow(RadRate, bd.Generation + 1) });
                    GraphObject.Path TmpPath = GraphObject.Path.CreateFromRegularPolygonTower(5, BaseRad * Math.Pow(RadRate, bd.Generation), BaseLength * Math.Pow(LengthRate, bd.Generation));
                    TmpPath.Name = &quot;Branch&quot;;
                    var TmpNode = Result.Add(EndPath, TmpPath);
                    EndPath = TmpPath;

                    TmpNode.RotationAngleX = 0;
                    TmpNode.RotationAngleY = TwistAngle;
                    TmpNode.RotationAngleYLimitation = new Interval(TwistAngle - (TwistAngleRange / 2.0), TwistAngle + (TwistAngleRange / 2.0));
                    TmpNode.RotationAngleZ = 0;
                    TmpNode.RotationAngleZLimitation = new Interval(0, 0);

                    TwistAngle = 0;
                }
                else if (bd.BodyType == bodyTypes[&quot;+&quot;])
                {
                    TwistAngle = TwistAngleTwisted;
                }
                else if (bd.BodyType == bodyTypes[&quot;-&quot;])
                {
                    TwistAngle = -TwistAngleTwisted;
                }
                else if (bd.BodyType == bodyTypes[&quot;L&quot;])
                {
                    GraphObject.Path TmpPath = new GraphObject.Path() { ContentMember = new Brep[] { (Brep)LeafBrep.Duplicate() } };
                    TmpPath.Name = &quot;Leaf&quot;;
                    var TmpNode = Result.Add(EndPath, TmpPath);
                    EndPath = TmpPath;
                }
                //F省略
                else if (bd.BodyType == bodyTypes[&quot;D&quot;])
                {
                    foreach (LSystem.Sequence tmpsq in bd.Child)
                    {
                        GetTreeGraphBranch(ref Result, EndPath, tmpsq, bodyTypes, Angle, BaseLength, LengthRate, BaseRad, RadRate, TwistAngle, TwistAngleRange, TwistAngleTwisted);
                    }

                }

            }
        }

        /// &lt;summary&gt;
        /// 2Dの樹木を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Generation&quot;&gt;世代&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Polyline[] GetTree2D(int Generation)
        {
            double Angle = Math.PI / 6.0;
            LSystem lsys = GetTreeLSystem();
            lsys.ApplyRules(Generation);
            return GetTree2DBranch(lsys.Tree, lsys.BodyTypes, new Point3d(0, 0, 0), 0, Angle);
        }

        private static Polyline[] GetTree2DBranch(LSystem.Sequence sq, Dictionary&lt;string, LSystem.BodyType&gt; bodyTypes, Point3d CurrentPoint, double CurrentAngle, double Angle)
        {
            Polyline result = new Polyline();
            result.Add(CurrentPoint);
            List&lt;Polyline&gt; PLs = new List&lt;Polyline&gt;();
            foreach (LSystem.Body bd in sq.Content)
            {
                if (bd.BodyType == bodyTypes[&quot;B&quot;])
                {
                    CurrentPoint += new Vector3d(Math.Cos(CurrentAngle), Math.Sin(CurrentAngle), 0);
                    result.Add(CurrentPoint);
                }
                else if (bd.BodyType == bodyTypes[&quot;-&quot;])
                {
                    CurrentAngle -= Angle;
                }
                else if (bd.BodyType == bodyTypes[&quot;+&quot;])
                {
                    CurrentAngle += Angle;
                }
                else if (bd.BodyType == bodyTypes[&quot;D&quot;])
                {
                    foreach (LSystem.Sequence seq in bd.Child)
                    {
                        PLs.AddRange(GetTree2DBranch(seq, bodyTypes, CurrentPoint, CurrentAngle, Angle));
                    }
                }
            }
            PLs.Add(result);
            return PLs.ToArray();
        }

        /// &lt;summary&gt;
        /// 適当な格好をしたデッサン人形モデルを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Height&quot;&gt;背の高さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetHumanRandom(double Height)
        {
            return GetHumanRandom(Height, new Random());
        }

        /// &lt;summary&gt;
        /// 適当な格好をしたデッサン人形モデルを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Height&quot;&gt;背の高さ&lt;/param&gt;
        /// &lt;param name=&quot;rd&quot;&gt;乱数インスタンス&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetHumanRandom(double Height, Random rd)
        {
            GraphObject.Graph human = GraphObject.Graph.GetHumanBody(Height);
            human.MoveRandom(rd);
            return human.GetBrep();
        }

        /// &lt;summary&gt;
        /// 多角形柱を取得します
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;c&quot;&gt;辺の数(n角形のn)&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;param name=&quot;height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Cap&quot;&gt;Capをするか&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetRegularPolygonTower(int c, double Radius, double height, bool Cap)
        {
            Brep result = Brep.CreateFromSurface(Surface.CreateExtrusion(GetRegularPolygon(c, Radius), new Vector3d(0, 0, height)));
            if (Cap) { result = result.CapPlanarHoles(0); }
            return result;
        }

        /// &lt;summary&gt;
        /// 多角形を線として取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;c&quot;&gt;辺の数(n角形のn)&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;returns&gt;多角形&lt;/returns&gt;
        public static Curve GetRegularPolygon(int c, double Radius)
        {
            Polyline pl = new Polyline(c + 1);
            for (int i = 0; i &lt;= c; i++)
            {
                pl.Add(Math.Cos(Math.PI * (double)i / (double)c * 2.0) * Radius, Math.Sin(Math.PI * (double)i / (double)c * 2.0) * Radius, 0);
            }
            return pl.ToNurbsCurve();
        }

        /// &lt;summary&gt;
        /// 簡易な連続したガラス窓を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;CountX&quot;&gt;X方向の個数&lt;/param&gt;
        /// &lt;param name=&quot;CountY&quot;&gt;Y方向の個数&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidth&quot;&gt;フレームの幅&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラス厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラスを出力します&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;フレームを出力します&lt;/param&gt;
        public static void GetGlassWindowLight(int CountX, int CountY, double Width, double Height, double FrameWidth, double GlassThickness, out Brep[] Glass, out Brep[] Frame)
        {
            {
                Polyline secPL = new Polyline(5);
                secPL.Add(0, 0, 0);
                secPL.Add(Width * CountX, 0, 0);
                secPL.Add(Width * CountX, 0, Height * CountY);
                secPL.Add(0, 0, Height * CountY);
                secPL.Add(0, 0, 0);

                List&lt;Brep&gt; GlassBrep = new List&lt;Brep&gt;();
                Curve secCv = secPL.ToNurbsCurve();
                GlassBrep.AddRange(Brep.CreatePlanarBreps(secCv));
                GlassBrep.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(secCv, new Vector3d(0, GlassThickness, 0))));
                secCv.Translate(0, GlassThickness, 0);
                GlassBrep.AddRange(Brep.CreatePlanarBreps(secCv));
                Glass = Brep.CreateSolid(GlassBrep, GlassThickness / 100.0);
            }
            Brep[] ResultFrame = GetFrame2d(CountX, CountY, Width, Height, FrameWidth, FrameWidth, FrameWidth, FrameWidth);
            for (int i = 0; i &lt; ResultFrame.GetLength(0); i++)
            {
                ResultFrame[i].Translate(0, -GlassThickness, 0);
            }
            Frame = ResultFrame;
        }

        /// &lt;summary&gt;
        /// 二次元的なフレームを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;CountX&quot;&gt;X方向の個数&lt;/param&gt;
        /// &lt;param name=&quot;CountY&quot;&gt;Y方向の個数&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidthTop&quot;&gt;フレームの上側の幅&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidthLeft&quot;&gt;フレームの左側の幅&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidthRight&quot;&gt;フレームの右側の幅&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidthBottom&quot;&gt;フレームの下側の幅&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetFrame2d(int CountX, int CountY, double Width, double Height, double FrameWidthTop, double FrameWidthLeft, double FrameWidthRight, double FrameWidthBottom)
        {
            Curve RecBase;
            {
                Polyline recPL = new Polyline(5);
                recPL.Add(FrameWidthRight, 0, FrameWidthBottom);
                recPL.Add(Width - FrameWidthLeft, 0, FrameWidthBottom);
                recPL.Add(Width - FrameWidthLeft, 0, Height - FrameWidthTop);
                recPL.Add(FrameWidthRight, 0, Height - FrameWidthTop);
                recPL.Add(FrameWidthRight, 0, FrameWidthBottom);
                RecBase = recPL.ToNurbsCurve();
            }
            List&lt;Curve&gt; ResultBase = new List&lt;Curve&gt;();
            {
                Polyline recPL = new Polyline(5);
                recPL.Add(0, 0, 0);
                recPL.Add(Width * CountX, 0, 0);
                recPL.Add(Width * CountX, 0, Height * CountY);
                recPL.Add(0, 0, Height * CountY);
                recPL.Add(0, 0, 0);
                ResultBase.Add(recPL.ToNurbsCurve());
            }

            for (int cntx = 0; cntx &lt; CountX; cntx++)
            {
                for (int cnty = 0; cnty &lt; CountY; cnty++)
                {
                    Curve Rec = (Curve)RecBase.Duplicate();
                    Rec.Translate(cntx * Width, 0, cnty * Height);
                    ResultBase.Add(Rec);
                }
            }
            return Brep.CreatePlanarBreps(ResultBase);
        }

        /// &lt;summary&gt;
        /// 日本風の屋根を得ます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;LengthTop&quot;&gt;上側の長さ&lt;/param&gt;
        /// &lt;param name=&quot;LengthBottom&quot;&gt;下側の長さ&lt;/param&gt;
        /// &lt;param name=&quot;Depth&quot;&gt;深さ&lt;/param&gt;
        /// &lt;param name=&quot;Pitch&quot;&gt;ピッチ&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;RafterSpace&quot;&gt;梁の感覚&lt;/param&gt;
        /// &lt;param name=&quot;RafterWidth&quot;&gt;梁の幅&lt;/param&gt;
        /// &lt;param name=&quot;RafterHeight&quot;&gt;梁の高さ&lt;/param&gt;
        /// &lt;param name=&quot;Main&quot;&gt;屋根部分&lt;/param&gt;
        /// &lt;param name=&quot;Rafter&quot;&gt;梁&lt;/param&gt;
        public static void GetJapaneseRoof(double LengthTop, double LengthBottom, double Depth, double Pitch, double Height, double RafterSpace, double RafterWidth, double RafterHeight, out Brep[] Main, out Brep[] Rafter)
        {
            Main = GetJapaneseRoofMain(LengthTop, LengthBottom, Depth, Pitch, Height);
            Rafter = GetJapaneseRoofRafter(LengthTop, LengthBottom, Depth, Pitch, Height, RafterSpace, RafterWidth, RafterHeight);
        }

        /// &lt;summary&gt;
        /// 日本風の屋根における梁を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;LengthTop&quot;&gt;上側の長さ&lt;/param&gt;
        /// &lt;param name=&quot;LengthBottom&quot;&gt;下側の長さ&lt;/param&gt;
        /// &lt;param name=&quot;Depth&quot;&gt;深さ&lt;/param&gt;
        /// &lt;param name=&quot;Pitch&quot;&gt;ピッチ&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;RafterSpace&quot;&gt;梁の感覚&lt;/param&gt;
        /// &lt;param name=&quot;RafterWidth&quot;&gt;梁の幅&lt;/param&gt;
        /// &lt;param name=&quot;RafterHeight&quot;&gt;梁の高さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetJapaneseRoofRafter(double LengthTop, double LengthBottom, double Depth, double Pitch, double Height, double RafterSpace, double RafterWidth, double RafterHeight)
        {
            List&lt;Brep&gt; Lafters = new List&lt;Brep&gt;();
            double RafterSpaceBottom = LengthBottom / Math.Floor(LengthBottom / RafterSpace);
            double RafterSpaceTop = LengthTop / Math.Floor(LengthBottom / RafterSpace);

            Curve SectionBase;
            {
                Polyline SectionPL = new Polyline(5);
                SectionPL.Add(RafterWidth / 2.0, 0, 0);
                SectionPL.Add(RafterWidth / 2.0, 0, -RafterHeight);
                SectionPL.Add(-RafterWidth / 2.0, 0, -RafterHeight);
                SectionPL.Add(-RafterWidth / 2.0, 0, 0);
                SectionPL.Add(RafterWidth / 2.0, 0, 0);

                SectionBase = SectionPL.ToNurbsCurve();
            }

            double CurrentPositonTop = -LengthTop / 2.0 + RafterSpaceTop;
            double CurrentPositonBottom = -LengthBottom / 2.0 + RafterSpaceBottom;
            for (; CurrentPositonBottom &lt;= LengthBottom / 2.0 - RafterSpaceBottom; CurrentPositonBottom += RafterSpaceBottom, CurrentPositonTop += RafterSpaceTop)
            {
                Point3d PointTop = new Point3d(CurrentPositonTop, 0, -Height);
                Point3d PointBottom = new Point3d(CurrentPositonBottom, -Depth, -Depth * Pitch - Height);

                Curve TempCurve1 = (Curve)SectionBase.Duplicate();
                TempCurve1.Translate((Vector3d)PointTop);
                Lafters.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(TempCurve1, PointBottom - PointTop)).CapPlanarHoles(Height / 100.0));
            }
            return Lafters.ToArray();
        }

        /// &lt;summary&gt;
        /// 日本風の屋根における屋根部分を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;LengthTop&quot;&gt;上側の長さ&lt;/param&gt;
        /// &lt;param name=&quot;LengthBottom&quot;&gt;下側の長さ&lt;/param&gt;
        /// &lt;param name=&quot;Depth&quot;&gt;深さ&lt;/param&gt;
        /// &lt;param name=&quot;Pitch&quot;&gt;ピッチ&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetJapaneseRoofMain(double LengthTop, double LengthBottom, double Depth, double Pitch, double Height)
        {
            List&lt;Brep&gt; ResultRoof = new List&lt;Brep&gt;();
            Polyline RoofPL = new Polyline(5);
            RoofPL.Add(LengthTop / 2.0, 0, 0);
            RoofPL.Add(LengthBottom / 2.0, -Depth, -Depth * Pitch);
            RoofPL.Add(-LengthBottom / 2.0, -Depth, -Depth * Pitch);
            RoofPL.Add(-LengthTop / 2.0, 0, 0);
            RoofPL.Add(LengthTop / 2.0, 0, 0);

            Curve RoofCurve = RoofPL.ToNurbsCurve();
            Brep RoofPlanar = (Brep.CreatePlanarBreps(RoofCurve))[0];
            ResultRoof.Add(RoofPlanar);
            RoofPlanar = (Brep)RoofPlanar.Duplicate();
            RoofPlanar.Translate(0, 0, -Height);
            ResultRoof.Add(RoofPlanar);

            ResultRoof.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(RoofCurve, new Vector3d(0, 0, -Height))));
            return Brep.CreateSolid(ResultRoof, Height / 100.0);
        }

        /// &lt;summary&gt;
        /// 線に沿ってガラス手すりを作成します。諸設定は自動的に行われます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BaseCurve&quot;&gt;ガイドレール&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static RealObject.Building GetHandrailGlass(Curve BaseCurve)
        {
            return GetHandrailGlass(BaseCurve, 700, 100, 600, 750, 50, 25, 37.5, 10, 100, 5.0);
        }

        /// &lt;summary&gt;
        /// 線に沿ってガラス手すりを作成します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BaseCurve&quot;&gt;ガイドレール&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;ガラス一枚当たりの幅&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static RealObject.Building GetHandrailGlass(Curve BaseCurve, double Height, double Space)
        {
            return GetHandrailGlass(BaseCurve, Height, 100, Height - 100, Space, 50, 25, 37.5, 10, 100, 5.0);
        }

        /// &lt;summary&gt;
        /// 線に沿ってガラス手すりを作成します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BaseCurve&quot;&gt;ガイドレール&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassHeightBottom&quot;&gt;下側のガラスの高さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassHeightTop&quot;&gt;上側のガラスの高さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;ガラス一枚当たりの幅param&gt;
        /// &lt;param name=&quot;GlassMarginSide&quot;&gt;ガラスの横の間隔&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;半径1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;半径2&lt;/param&gt;
        /// &lt;param name=&quot;GlassThick&quot;&gt;ガラス厚さ&lt;/param&gt;
        /// &lt;param name=&quot;EndSpace&quot;&gt;端の感覚&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidth&quot;&gt;枠の幅&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static RealObject.Building GetHandrailGlass(Curve BaseCurve, double Height, double GlassHeightBottom, double GlassHeightTop, double Space, double GlassMarginSide, double Radius1, double Radius2, double GlassThick, double EndSpace, double FrameWidth)
        {
            EndSpace = BaseCurve.IsClosed ? 0 : EndSpace;
            List&lt;Brep&gt; Handrail = new List&lt;Brep&gt;();
            List&lt;Brep&gt; Glass = new List&lt;Brep&gt;();
            List&lt;Brep&gt; Frame = new List&lt;Brep&gt;();
            {
                Curve TopRailCurve = (Curve)BaseCurve.Duplicate();
                TopRailCurve.Translate(0, 0, Height);
                Handrail.Add(Brep.CreateFromSweep(TopRailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius2)), TopRailCurve), true, Space / 1000)[0]);
            }
            double Length = BaseCurve.GetLength();
            double EndTreatment = 0.5;
            for (double CurrentLength = EndSpace; CurrentLength + Space * EndTreatment + EndSpace &lt; Length; CurrentLength += Space)
            {
                Point3d Point1 = BaseCurve.PointAtLength(CurrentLength);
                Point3d Point2 = BaseCurve.PointAtLength(CurrentLength + Space);
                if (CurrentLength + Space * (EndTreatment + 1) &gt; Length) { Point2 = BaseCurve.PointAtLength(Length - EndSpace); }

                Handrail.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(Point1, Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));

                double GlassLength = (Point2 - Point1).Length;
                if (GlassLength &gt; GlassMarginSide * 2)
                {
                    Brep GlassTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(GlassMarginSide, GlassLength - GlassMarginSide), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom, GlassHeightTop)));
                    GlassTemp = GeneralHelper.FitTwoPoint(GlassTemp, Point1, Point2);
                    Glass.Add(GlassTemp);
                    if (FrameWidth &gt; 0)
                    {
                        {
                            Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, GlassLength), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom - FrameWidth, GlassHeightBottom)));
                            FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
                            Frame.Add(FrameTemp);
                        }
                        {
                            Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, GlassLength), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightTop, GlassHeightTop + FrameWidth)));
                            FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
                            Frame.Add(FrameTemp);
                        }
                        {
                            Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(GlassMarginSide - FrameWidth, GlassMarginSide), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom, GlassHeightTop)));
                            FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
                            Frame.Add(FrameTemp);
                        }
                        {
                            Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(GlassLength - GlassMarginSide, GlassLength - GlassMarginSide + FrameWidth), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom, GlassHeightTop)));
                            FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
                            Frame.Add(FrameTemp);
                        }
                    }
                }
            }
            if (!BaseCurve.IsClosed)
            {
                Handrail.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(BaseCurve.PointAtLength(Length - EndSpace), Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
                Handrail[0] = Handrail[0].CapPlanarHoles(0);
            }
            RealObject.Building result = new RealObject.Building(&quot;GlassHandrail&quot;);
            result.Add(&quot;Rail&quot;, Handrail.ToArray());
            result.Add(&quot;Glass&quot;, Glass.ToArray());
            result.Add(&quot;Frame&quot;, Frame.ToArray());
            return result;
        }

        /// &lt;summary&gt;
        /// 線に沿ってシンプルなガラス手すりを作成します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BaseCurve&quot;&gt;ガイドレール&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static RealObject.Building GetHandrailGlassSimple(Curve BaseCurve, double Height, double Space)
        {
            return GetHandrailGlassSimple(BaseCurve, Height, Space, 10, 10, 50);
        }

        /// &lt;summary&gt;
        /// 線に沿ってシンプルなガラス手すりを作成します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BaseCurve&quot;&gt;ガイドレール&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;param name=&quot;FrameSizeHorizontal&quot;&gt;水平方向の枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSizeBottom&quot;&gt;下の枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSizeTop&quot;&gt;上の枠の大きさ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static RealObject.Building GetHandrailGlassSimple(Curve BaseCurve, double Height, double Space, double FrameSizeHorizontal, double FrameSizeBottom, double FrameSizeTop)
        {
            RealObject.Building Result = new RealObject.Building(&quot;HandrailGlassSimple&quot;);
            double CurveLen = BaseCurve.GetLength();
            double SpaceModified = (CurveLen - 0.01) / (int)(CurveLen / Space);

            List&lt;Brep&gt; Glass = new List&lt;Brep&gt;();
            List&lt;Brep&gt; Frame = new List&lt;Brep&gt;();

            for (int i = 0; i &lt; (int)(CurveLen / Space); i++)
            {
                Point3d Point1 = BaseCurve.PointAtLength(SpaceModified * i);
                Point3d Point2 = BaseCurve.PointAtLength(SpaceModified * (i + 1));
                double Dist = Point2.DistanceTo(Point1);
                if (FrameSizeHorizontal != 0)
                {
                    Polyline PL1 = new Polyline(5);
                    Polyline PL2 = new Polyline(5);
                    PL1.Add(0, 0, 0);
                    PL1.Add(Dist, 0, 0);
                    PL1.Add(Dist, 0, Height);
                    PL1.Add(0, 0, Height);
                    PL1.Add(0, 0, 0);

                    PL2.Add(FrameSizeHorizontal, 0, FrameSizeBottom);
                    PL2.Add(Dist - FrameSizeHorizontal, 0, FrameSizeBottom);
                    PL2.Add(Dist - FrameSizeHorizontal, 0, Height - FrameSizeTop);
                    PL2.Add(FrameSizeHorizontal, 0, Height - FrameSizeTop);
                    PL2.Add(FrameSizeHorizontal, 0, FrameSizeBottom);

                    Brep Temp = Brep.CreatePlanarBreps(new Curve[] { PL1.ToNurbsCurve(), PL2.ToNurbsCurve() })[0];
                    Temp = GeneralHelper.FitTwoPoint(Temp, Point1, Point2);
                    Frame.Add(Temp);
                }
                {
                    Brep Temp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(FrameSizeHorizontal, Dist - FrameSizeHorizontal), new Interval(0, 5), new Interval(FrameSizeBottom, Height - FrameSizeTop)));
                    Temp = GeneralHelper.FitTwoPoint(Temp, Point1, Point2);
                    Glass.Add(Temp);
                }
            }
            Result.Add(&quot;Glass&quot;, Glass.ToArray());
            Result.Add(&quot;Frame&quot;, Frame.ToArray());

            return Result;
        }

        /// &lt;summary&gt;
        /// 距離と半径の組み合わせからパイプを作ります。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Distance&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep GetPipeSimple(double[] Distance, double[] Radius)
        {
            return Brep.CreateFromRevSurface(RevSurface.Create(GetHeightMap(Distance, Radius), new Line(0, 0, 0, 1, 0, 0)), false, false);
        }

        /// &lt;summary&gt;
        /// 距離と半径の組み合わせから半周分のパイプを作ります。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Distance&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep GetPipeHalf(double[] Distance, double[] Radius)
        {
            Curve RevBase = GetHeightMap(Distance, Radius);
            return Brep.CreateFromRevSurface(RevSurface.Create(RevBase, new Line(0, 0, 0, 1, 0, 0), Math.PI * 0, Math.PI), true, true);
        }

        /// &lt;summary&gt;
        /// 距離と半径の組み合わせを滑らかにつないだ線を表示します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Distance&quot;&gt;距離&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;returns&gt;曲線&lt;/returns&gt;
        public static Curve GetHeightMap(double[] Distance, double[] Radius)
        {
            List&lt;Point3d&gt; Points = new List&lt;Point3d&gt;();
            for (int i = 0; i &lt; Distance.GetLength(0); i++)
            {
                Points.Add(new Point3d(Distance[i], Radius[i], 0));
            }
            List&lt;Curve&gt; intcrv = new List&lt;Curve&gt;();
            intcrv.Add(Curve.CreateInterpolatedCurve(Points, 3));
            if (Radius[0] &gt; 0) intcrv.Add((new Line(Distance[0], Radius[0], 0, Distance[0], 0, 0)).ToNurbsCurve());
            if (Radius[Radius.GetLength(0) - 1] &gt; 0) intcrv.Add((new Line(Distance[Distance.GetLength(0) - 1], Radius[Radius.GetLength(0) - 1], 0, Distance[Distance.GetLength(0) - 1], 0, 0)).ToNurbsCurve());
            return Curve.JoinCurves(intcrv)[0];
        }

        /// &lt;summary&gt;
        /// 距離と半径の組み合わせから片方が閉じた形状を作ります。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Distance&quot;&gt;距離&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetPipeHead(double[] Distance, double[] Radius)
        {
            List&lt;Point3d&gt; Points = new List&lt;Point3d&gt;();
            for (int i = 0; i &lt; Radius.GetLength(0); i++)
            {
                Points.Add(new Point3d(Distance[i], Radius[i], 0));
            }
            Points.Add(new Point3d(Distance[Distance.GetLength(0) - 1], 0, 0));
            for (int i = Radius.GetLength(0) - 1; i &gt;= 0; i--)
            {
                Points.Add(new Point3d(Distance[i], -Radius[i], 0));
            }
            Curve intcrv = Curve.CreateInterpolatedCurve(Points, 3, CurveKnotStyle.Chord);
            intcrv.Domain = new Interval(0, 1);
            intcrv = intcrv.Split(0.5)[0];
            return Brep.CreateFromRevSurface(RevSurface.Create(intcrv, new Line(0, 0, 0, 1, 0, 0), 0, Math.PI * 2.0), true, true);
        }

        /// &lt;summary&gt;
        /// 簡単な時計を作成します。時間は作成時点に設定します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;rd&quot;&gt;ランダムインスタンス&lt;/param&gt;
        /// &lt;param name=&quot;r&quot;&gt;半径&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[][] GetClock(RhinoDoc rd, double r)
        {
            return GetClock(rd, System.DateTime.Now, r, &quot;Cambria&quot;);
        }

        /// &lt;summary&gt;
        /// 簡単な時計を作成します。時間は作成時点に設定します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;rd&quot;&gt;ランダムインスタンス&lt;/param&gt;
        /// &lt;param name=&quot;dt&quot;&gt;表示させる時間&lt;/param&gt;
        /// &lt;param name=&quot;r&quot;&gt;半径&lt;/param&gt;
        /// &lt;param name=&quot;fontname&quot;&gt;文字盤のフォント名&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[][] GetClock(RhinoDoc rd, System.DateTime dt, double r, string fontname)
        {
            return GetClock(rd, dt, r, fontname, new Interval(0.75, 0.85), new Interval(0.9, 1.0), 0.02, new Interval[] { new Interval(-0.0, 0.6), new Interval(-0.1, 0.7), new Interval(-0.2, 0.75) },
              new double[] { 0.03, 0.02, 0.01 }, 5, 2, 2, 2);
        }

        /// &lt;summary&gt;
        /// 簡単な時計を作成します。時間は作成時点に設定します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;rd&quot;&gt;ランダムインスタンス&lt;/param&gt;
        /// &lt;param name=&quot;time&quot;&gt;表示させる時間&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;param name=&quot;TextFontName&quot;&gt;文字盤のフォント名&lt;/param&gt;
        /// &lt;param name=&quot;TextRad&quot;&gt;文字盤の半径&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;フレームの存在範囲&lt;/param&gt;
        /// &lt;param name=&quot;CenterRad&quot;&gt;時計の半径&lt;/param&gt;
        /// &lt;param name=&quot;HandsRad&quot;&gt;針の半径&lt;/param&gt;
        /// &lt;param name=&quot;HandsWidth&quot;&gt;針の太さ&lt;/param&gt;
        /// &lt;param name=&quot;BaseThick&quot;&gt;基本的な厚さ&lt;/param&gt;
        /// &lt;param name=&quot;HandsThick&quot;&gt;針の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;TextThick&quot;&gt;文字の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThick&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep[][] GetClock(RhinoDoc rd, System.DateTime time, double Radius, string TextFontName, Interval TextRad, Interval Frame, double CenterRad, Interval[] HandsRad, double[] HandsWidth, double BaseThick, double HandsThick, double TextThick, double GlassThick)
        {
            Brep[][] Result = new Brep[5][];

            List&lt;Brep&gt; Texts = new List&lt;Brep&gt;();
            for (int i = 1; i &lt;= 12; i++)
            {
                TextEntity TE = new TextEntity();
                TE.Plane = new Plane(new Point3d(0, 0, 0), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1));
                TE.Justification = TextJustification.MiddleCenter;
                TE.Text = &quot;&quot; + i;
                TE.FontIndex = rd.Fonts.FindOrCreate(TextFontName, false, false);
                TE.TextHeight = TextRad.Length * Radius;
                TE.Translate(Radius * TextRad.Mid * Math.Sin(Math.PI * i / 6.0), -BaseThick, Radius * TextRad.Mid * Math.Cos(Math.PI * i / 6.0));
                Texts.AddRange(GeneralHelper.CreateExtrusionCaped(TE.Explode(), new Vector3d(0, -TextThick, 0)));
            }
            Result[0] = Texts.ToArray();

            List&lt;Brep&gt; Hands = new List&lt;Brep&gt;();
            double[] Angles = new double[] { (time.Hour + time.Minute / 60.0) * Math.PI / 6.0, (time.Minute + time.Second / 60.0) * Math.PI / 30.0, time.Second * Math.PI / 30.0 };
            for (int i = 0; i &lt; 3; i++)
            {
                if (HandsRad[i].Length &gt; 0)
                {
                    Box bx = new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(Math.Sin(Angles[i]), 0, Math.Cos(Angles[i])), new Vector3d(Math.Sin(Angles[i] + Math.PI / 2.0), 0, Math.Cos(Angles[i] + Math.PI / 2.0)))
                      , new Interval(HandsRad[i].Min * Radius, HandsRad[i].Max * Radius), new Interval(-Radius * HandsWidth[i] / 2.0, Radius * HandsWidth[i] / 2.0), new Interval(-BaseThick - TextThick * 2.0 - HandsThick * (i + 1), -BaseThick - TextThick * 2.0 - HandsThick * i));
                    Hands.Add(Brep.CreateFromBox(bx));
                }
            }
            Result[1] = Hands.ToArray();

            Curve RevCrv =
              (Curve.JoinCurves(new Curve[]{(new Arc(new Circle(new Plane(new Point3d(Frame.Min * Radius, -BaseThick, 0), new Vector3d(0, 0, 1)), Frame.Length * Radius), new Interval(-Math.PI / 2.0, 0))).ToNurbsCurve(),
                      new Line(Frame.Min * Radius, -BaseThick, 0, Frame.Min * Radius, -BaseThick - Frame.Length * Radius, 0).ToNurbsCurve(),
                      new Line(Frame.Min * Radius, -BaseThick, 0, Frame.Max * Radius, -BaseThick, 0).ToNurbsCurve()
              }))[0];
            Result[2] = new Brep[]{
                    Brep.CreateFromCylinder(new Cylinder(new Circle(Plane.WorldZX, Radius), -BaseThick), true, true),
                    Brep.CreateFromRevSurface(RevSurface.Create(RevCrv, new Line(0, 0, 0, 0, 1, 0)), false, false)
                };
            Result[3] = new Brep[]{
                    Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Frame.Length * Radius - BaseThick, 0), new Vector3d(0, 1, 0)), Radius * Frame.Min), GlassThick), true, true)
                };
            Result[4] = new Brep[]{
                    Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -BaseThick, 0), new Vector3d(0, 1, 0)), Radius * CenterRad), -TextThick * 2.0 - HandsThick * 4.0), true, true)
                };
            return Result;
        }

        /// &lt;summary&gt;
        /// 文字のアウトラインを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextContent&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;FontName&quot;&gt;フォント名&lt;/param&gt;
        /// &lt;param name=&quot;Bold&quot;&gt;ボールドにするか&lt;/param&gt;
        /// &lt;param name=&quot;Italic&quot;&gt;イタリックにするか&lt;/param&gt;
        /// &lt;param name=&quot;RhinoDocument&quot;&gt;対象のドキュメント&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] GetTextCurve(string TextContent, double Height, string FontName, bool Bold, bool Italic, RhinoDoc RhinoDocument)
        {
            Rhino.Geometry.TextEntity txt = new TextEntity();
            txt.Text = TextContent;
            txt.TextHeight = Height;

            txt.FontIndex = RhinoDocument.Fonts.FindOrCreate(FontName, Bold, Italic);
            return txt.Explode();
        }

        /// &lt;summary&gt;
        /// 文字のアウトラインを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextContent&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;returns&gt;アウトライン&lt;/returns&gt;
        public static Curve[] GetTextCurve(string TextContent, double Height) { return (new TextEntity() { Text = TextContent, TextHeight = Height }).Explode(); }
        /// &lt;summary&gt;
        /// 文字をBrepとして取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextContent&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;returns&gt;形状&lt;/returns&gt;
        public static Brep[] GetTextBrep(string TextContent, double Height, double Thickness) { return GeneralHelper.CreateExtrusionCaped((new TextEntity() { Text = TextContent, TextHeight = Height }).Explode(), new Vector3d(0, 0, Thickness)); }
        /// &lt;summary&gt;
        /// 文字をBrepとして取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;TextContent&quot;&gt;文字&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;param name=&quot;FontName&quot;&gt;フォント名&lt;/param&gt;
        /// &lt;param name=&quot;Bold&quot;&gt;ボールドであるか&lt;/param&gt;
        /// &lt;param name=&quot;Italic&quot;&gt;イタリックであるか&lt;/param&gt;
        /// &lt;param name=&quot;RhinoDocument&quot;&gt;ドキュメント&lt;/param&gt;
        /// &lt;returns&gt;Brep&lt;/returns&gt;
        public static Brep[] GetTextBrep(string TextContent, double Height, double Thickness, string FontName, bool Bold, bool Italic, RhinoDoc RhinoDocument) { return GeneralHelper.CreateExtrusionCaped(GetTextCurve(TextContent, Height, FontName, Bold, Italic, RhinoDocument), new Vector3d(0, 0, Thickness)); }
        /// &lt;summary&gt;
        /// 線路のバラストを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BallastWidthTop&quot;&gt;上側の幅&lt;/param&gt;
        /// &lt;param name=&quot;BallastWidthBottom&quot;&gt;下側の幅&lt;/param&gt;
        /// &lt;param name=&quot;BallastHeight&quot;&gt;高さ&lt;/param&gt;
        /// &lt;returns&gt;Brep&lt;/returns&gt;
        public static Curve GetRailroadBallast(double BallastWidthTop, double BallastWidthBottom, double BallastHeight)
        {
            Polyline BallastBasePL = new Polyline(5);
            BallastBasePL.Add(BallastWidthBottom / 2.0, 0, 0);
            BallastBasePL.Add(BallastWidthTop / 2.0, 0, BallastHeight);
            BallastBasePL.Add(-BallastWidthTop / 2.0, 0, BallastHeight);
            BallastBasePL.Add(-BallastWidthBottom / 2.0, 0, 0);
            BallastBasePL.Add(BallastWidthBottom / 2.0, 0, 0);
            return BallastBasePL.ToNurbsCurve();
        }

        /// &lt;summary&gt;
        /// 標準的な鉄道線路の断面を取得します。
        /// &lt;/summary&gt;
        /// &lt;returns&gt;断面&lt;/returns&gt;
        public static Curve GetRailroadTrackShape()
        {
            return GetRailroadTrackShape(145.0, 65.0, 49.0, 94.9, 30.1, 16.5);
        }

        /// &lt;summary&gt;
        /// 標準的な鉄道線路の断面を取得します。
        /// 大きさを設定可能ですが、標準値以外を利用する必要性は特にありません。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;b&quot;&gt;B&lt;/param&gt;
        /// &lt;param name=&quot;c&quot;&gt;C&lt;/param&gt;
        /// &lt;param name=&quot;d&quot;&gt;D&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;E&lt;/param&gt;
        /// &lt;param name=&quot;f&quot;&gt;F&lt;/param&gt;
        /// &lt;param name=&quot;g&quot;&gt;G&lt;/param&gt;
        /// &lt;returns&gt;断面&lt;/returns&gt;
        public static Curve GetRailroadTrackShape(double b, double c, double d, double e, double f, double g)
        {
            Polyline BallastBasePL = new Polyline(11);
            BallastBasePL.Add(b / 2.0, 0, 0);
            BallastBasePL.Add(b / 2.0, 0, f / 2.0);
            BallastBasePL.Add(g / 2.0, 0, f);
            BallastBasePL.Add(g / 2.0, 0, f + e);
            BallastBasePL.Add(c / 2.0, 0, f + e);
            BallastBasePL.Add(c / 2.0, 0, f + e + d);

            BallastBasePL.Add(-c / 2.0, 0, f + e + d);
            BallastBasePL.Add(-c / 2.0, 0, f + e);
            BallastBasePL.Add(-g / 2.0, 0, f + e);
            BallastBasePL.Add(-g / 2.0, 0, f);
            BallastBasePL.Add(-b / 2.0, 0, f / 2.0);
            BallastBasePL.Add(-b / 2.0, 0, 0);

            BallastBasePL.Add(b / 2.0, 0, 0);
            return BallastBasePL.ToNurbsCurve();
        }

        /// &lt;summary&gt;
        /// ガイドレールに沿って線路を配置します。
        /// バラストや枕木を含みます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;RailCurves&quot;&gt;レール&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static RealObject.Building GetRailroad(Curve[] RailCurves)
        {
            Brep[] brep1, brep2, brep3;
            GetRailroad(RailCurves, out brep1, out brep2, out brep3);
            RealObject.Building result = new RealObject.Building(&quot;Railroad&quot;);
            RealObject.Member mem;
            mem = result.Add(&quot;Rail&quot;, brep1);
            mem.Material = new RealObject.Material(&quot;Silver&quot;);
            mem = result.Add(&quot;Tie&quot;, brep2);
            mem.Material = new RealObject.Material(&quot;Wood&quot;);
            mem = result.Add(&quot;Ballast&quot;, brep3);
            mem.Material = new RealObject.Material(&quot;Stone&quot;);
            return result;
        }

        /// &lt;summary&gt;
        /// ガイドレールに沿って線路を配置します。
        /// バラストや枕木を含みます。
        /// Brepとして出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;RailCurves&quot;&gt;レール&lt;/param&gt;
        /// &lt;param name=&quot;Railroad&quot;&gt;線路を出力します。&lt;/param&gt;
        /// &lt;param name=&quot;RailroadTie&quot;&gt;枕木を得ます。&lt;/param&gt;
        /// &lt;param name=&quot;TrackBallast&quot;&gt;バラストを得ます。&lt;/param&gt;
        public static void GetRailroad(Curve[] RailCurves, out Brep[] Railroad, out Brep[] RailroadTie, out Brep[] TrackBallast)
        {
            double TrackGauge = 1067.0;
            GetRailroad(RailCurves, GetRailroadTrackShape(), TrackGauge, out Railroad, out RailroadTie, out TrackBallast);
        }

        /// &lt;summary&gt;
        /// ガイドレールに沿って線路を配置します。
        /// バラストや枕木を含みます。
        /// Brepとして出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;RailCurves&quot;&gt;レール&lt;/param&gt;
        /// &lt;param name=&quot;TrackShape&quot;&gt;線路の形状&lt;/param&gt;
        /// &lt;param name=&quot;TrackGauge&quot;&gt;軌間。国内では1067mmの狭軌と1435mmの標準機が主流です。&lt;/param&gt;
        /// &lt;param name=&quot;Railroad&quot;&gt;線路を出力します。&lt;/param&gt;
        /// &lt;param name=&quot;RailroadTie&quot;&gt;枕木を得ます。&lt;/param&gt;
        /// &lt;param name=&quot;TrackBallast&quot;&gt;バラストを得ます。&lt;/param&gt;
        public static void GetRailroad(Curve[] RailCurves, Curve TrackShape, double TrackGauge, out Brep[] Railroad, out Brep[] RailroadTie, out Brep[] TrackBallast)
        {
            GetRailroad(RailCurves, TrackShape, TrackGauge, TrackGauge * 2.0, 200, 50, 700, TrackGauge * 2.5, TrackGauge * 3.0, 140, out Railroad, out RailroadTie, out TrackBallast);
        }

        /// &lt;summary&gt;
        /// ガイドレールに沿って線路を配置します。
        /// バラストや枕木を含みます。
        /// Brepとして出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;RailCurves&quot;&gt;レール&lt;/param&gt;
        /// &lt;param name=&quot;TrackShape&quot;&gt;線路の形状&lt;/param&gt;
        /// &lt;param name=&quot;TrackGauge&quot;&gt;軌間。国内では1067mmの狭軌と1435mmの標準機が主流です。&lt;/param&gt;
        /// &lt;param name=&quot;TieWidth&quot;&gt;枕木の幅。0では作成しません。&lt;/param&gt;
        /// &lt;param name=&quot;TieLength&quot;&gt;枕木の長さ&lt;/param&gt;
        /// &lt;param name=&quot;TieHeight&quot;&gt;枕木の高さ&lt;/param&gt;
        /// &lt;param name=&quot;TieSpace&quot;&gt;枕木の間隔&lt;/param&gt;
        /// &lt;param name=&quot;BallastWidthTop&quot;&gt;バラストの上部の幅&lt;/param&gt;
        /// &lt;param name=&quot;BallastWidthBottom&quot;&gt;バラストの下部の幅&lt;/param&gt;
        /// &lt;param name=&quot;BallastHeight&quot;&gt;バラストの高さ&lt;/param&gt;
        /// &lt;param name=&quot;Railroad&quot;&gt;線路を出力します。&lt;/param&gt;
        /// &lt;param name=&quot;RailroadTie&quot;&gt;枕木を得ます。&lt;/param&gt;
        /// &lt;param name=&quot;TrackBallast&quot;&gt;バラストを得ます。&lt;/param&gt;
        public static void GetRailroad(Curve[] RailCurves, Curve TrackShape, double TrackGauge, double TieWidth, double TieLength, double TieHeight, double TieSpace, double BallastWidthTop, double BallastWidthBottom, double BallastHeight, out Brep[] Railroad, out Brep[] RailroadTie, out Brep[] TrackBallast)
        {
            TrackGauge = Math.Abs(TrackGauge);
            List&lt;Brep&gt; ResultRoad = new List&lt;Brep&gt;();
            List&lt;Brep&gt; ResultTie = new List&lt;Brep&gt;();
            List&lt;Brep&gt; ResultBallast = new List&lt;Brep&gt;();

            Brep TieBase = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-TieWidth / 2.0, TieWidth / 2.0), new Interval(-TieLength / 2.0, TieLength / 2.0), new Interval(0, TieHeight)));

            Curve BallastBase = GetRailroadBallast(BallastWidthTop, BallastWidthBottom, BallastHeight);

            foreach (Curve RailCurve in RailCurves)
            {
                RailCurve.Domain = new Interval(0, 1.0);
                double RailLength = RailCurve.GetLength();

                Curve[] OffsetedCurves = new Curve[]{
        (RailCurve.Offset(Plane.WorldXY, TrackGauge / 2.0, TrackGauge / 100.0, CurveOffsetCornerStyle.Smooth))[0],
        (RailCurve.Offset(Plane.WorldXY, -TrackGauge / 2.0, TrackGauge / 100.0, CurveOffsetCornerStyle.Smooth))[0]};
                OffsetedCurves[0].Translate(0, 0, BallastHeight + TieHeight);
                OffsetedCurves[1].Translate(0, 0, BallastHeight + TieHeight);

                for (int i = 0; i &lt;= 1; i++)
                {
                    Curve TempTrackShape = (Curve)TrackShape.Duplicate();
                    OffsetedCurves[i].Domain = new Interval(0, 1);
                    TempTrackShape.Rotate(GeneralHelper.GetCurvatureAsAngle(OffsetedCurves[i], 0), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                    TempTrackShape.Translate((Vector3d)OffsetedCurves[i].PointAtStart);
                    ResultRoad.Add(Brep.CreateFromSweep(OffsetedCurves[i], TempTrackShape, true, TrackGauge / 1e6)[0].CapPlanarHoles(TrackGauge / 1e6));
                }

                if (TieHeight &gt; 0 &amp;&amp; TieWidth &gt; 0)
                {
                    for (double CurrentLength = TieSpace; CurrentLength &lt; RailLength; CurrentLength += TieSpace)
                    {
                        double TempT;
                        RailCurve.LengthParameter(CurrentLength, out TempT);
                        Brep TempTie = (Brep)TieBase.Duplicate();
                        TempTie.Rotate(GeneralHelper.GetCurvatureAsAngle(RailCurve, TempT), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                        TempTie.Translate((Vector3d)(RailCurve.PointAt(TempT)) + new Vector3d(0, 0, BallastHeight));
                        ResultTie.Add(TempTie);
                    }
                }
                if (BallastHeight &gt; 0)
                {
                    Curve TempBallaseBase = (Curve)BallastBase.Duplicate();
                    TempBallaseBase.Rotate(GeneralHelper.GetCurvatureAsAngle(RailCurve, 0), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                    TempBallaseBase.Translate((Vector3d)RailCurve.PointAtStart);
                    ResultBallast.Add(Brep.CreateFromSweep(RailCurve, TempBallaseBase, true, TrackGauge / 1e6)[0].CapPlanarHoles(TrackGauge / 1e6));
                }
            }
            Railroad = ResultRoad.ToArray();
            RailroadTie = ResultTie.ToArray();
            TrackBallast = ResultBallast.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンを出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;AngleClane&quot;&gt;クレーン部分の角度&lt;/param&gt;
        /// &lt;param name=&quot;AngleHead&quot;&gt;上部の角度&lt;/param&gt;
        /// &lt;param name=&quot;Basement&quot;&gt;基底部の角度&lt;/param&gt;
        /// &lt;param name=&quot;LadderBasement&quot;&gt;出力1&lt;/param&gt;
        /// &lt;param name=&quot;LiftFrame&quot;&gt;出力2&lt;/param&gt;
        /// &lt;param name=&quot;RotationUnit&quot;&gt;出力3&lt;/param&gt;
        /// &lt;param name=&quot;HeadHouseWall&quot;&gt;出力4&lt;/param&gt;
        /// &lt;param name=&quot;HeadHouseGlass&quot;&gt;出力5&lt;/param&gt;
        /// &lt;param name=&quot;HeadBody&quot;&gt;出力6&lt;/param&gt;
        /// &lt;param name=&quot;HeadHandrail&quot;&gt;出力7&lt;/param&gt;
        /// &lt;param name=&quot;HeadClaneBodyRed&quot;&gt;出力8&lt;/param&gt;
        /// &lt;param name=&quot;HeadClaneBodyWhite&quot;&gt;出力9&lt;/param&gt;
        /// &lt;param name=&quot;HeadClaneLadderRed&quot;&gt;出力10&lt;/param&gt;
        /// &lt;param name=&quot;HeadClaneLadderWhite&quot;&gt;出力11&lt;/param&gt;
        /// &lt;param name=&quot;HeadPole&quot;&gt;出力12&lt;/param&gt;
        /// &lt;param name=&quot;HeadPoleWorkSpace&quot;&gt;出力13&lt;/param&gt;
        /// &lt;param name=&quot;HeadClaneWorkSpace&quot;&gt;出力14&lt;/param&gt;
        /// &lt;param name=&quot;HeadClaneWire&quot;&gt;出力15&lt;/param&gt;
        public static void GetTowerClane(double AngleClane, double AngleHead, out Brep[] Basement, out Brep[] LadderBasement, out Brep[] LiftFrame, out Brep[] RotationUnit,
            out Brep[] HeadHouseWall, out Brep[] HeadHouseGlass, out Brep[] HeadBody, out Brep[] HeadHandrail, out Brep[] HeadClaneBodyRed, out Brep[] HeadClaneBodyWhite, out Brep[] HeadClaneLadderRed, out Brep[] HeadClaneLadderWhite,
            out Brep[] HeadPole, out Brep[] HeadPoleWorkSpace, out Brep[] HeadClaneWorkSpace, out Brep[] HeadClaneWire)
        {
            Basement = GetTowerClaneBasement(20);
            LadderBasement = GeneralHelper.TranslateBreps(GetLadderSimple(20 * 800), new Point3d(0, 400, 0));
            LiftFrame = GeneralHelper.TranslateBreps(GetTowerClaneLiftFrame(1200, 2200), new Vector3d(0, 0, 20 * 800));
            RotationUnit = GeneralHelper.TranslateBreps(GetTowerClaneRotationUnit(600, 2300, 150, 2500), new Vector3d(0, 0, 20 * 800));

            Brep[] RetWall;
            Brep[] RetGlass;
            Brep[] RetBody;
            Brep[] RetHandrail;
            Brep[] RetPole;
            Brep[] ClaneWorkSpace;

            Brep[] RedBody;
            Brep[] WhiteBody;
            Brep[] ClaneLadderRed;
            Brep[] ClaneLadderWhite;
            Brep[] ClaneClaneWorkSpace;
            Brep[] Wire;

            GetTowerClaneHead(out RetBody, out RetHandrail, out RetWall, out RetGlass, out RetPole, out ClaneWorkSpace, AngleClane, out RedBody, out WhiteBody, out ClaneLadderRed, out ClaneLadderWhite, out ClaneClaneWorkSpace, 20000, out Wire);

            HeadHouseWall = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetWall, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadHouseGlass = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetGlass, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadBody = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetBody, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadHandrail = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetHandrail, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadPole = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetPole, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadPoleWorkSpace = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneWorkSpace, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));

            HeadClaneBodyRed = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RedBody, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadClaneBodyWhite = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(WhiteBody, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadClaneLadderRed = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneLadderRed, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadClaneLadderWhite = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneLadderWhite, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadClaneWorkSpace = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneClaneWorkSpace, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
            HeadClaneWire = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(Wire, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
        }

        /// &lt;summary&gt;
        /// タワークレーンのクレーン部分を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Count&quot;&gt;個数&lt;/param&gt;
        /// &lt;param name=&quot;Angle&quot;&gt;角度&lt;/param&gt;
        /// &lt;param name=&quot;Width1&quot;&gt;幅1&lt;/param&gt;
        /// &lt;param name=&quot;Width2&quot;&gt;幅2&lt;/param&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;半径1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;半径2&lt;/param&gt;
        /// &lt;param name=&quot;Body1&quot;&gt;本体1&lt;/param&gt;
        /// &lt;param name=&quot;Body2&quot;&gt;本体2&lt;/param&gt;
        /// &lt;param name=&quot;Ladder1&quot;&gt;梯子1&lt;/param&gt;
        /// &lt;param name=&quot;Ladder2&quot;&gt;梯子2&lt;/param&gt;
        /// &lt;param name=&quot;WorkSpace&quot;&gt;作業場&lt;/param&gt;
        public static void GetTowerClaneClane(int Count, double Angle, double Width1, double Width2, double Length, double Space, double Radius1, double Radius2, out Brep[] Body1, out Brep[] Body2, out Brep[] Ladder1, out Brep[] Ladder2, out Brep[] WorkSpace)
        {
            Angle = -Angle;
            Count = Math.Max(Count, 2);
            List&lt;List&lt;Brep&gt;&gt; ResultBody = new List&lt;List&lt;Brep&gt;&gt;();
            ResultBody.Add(new List&lt;Brep&gt;());
            ResultBody.Add(new List&lt;Brep&gt;());
            ResultBody.Add(new List&lt;Brep&gt;());
            ResultBody.Add(new List&lt;Brep&gt;());

            ResultBody[0].AddRange(GeneralHelper.RotateBreps(GetTowerClaneClaneUnit(Width1, Width2, Length, Space, Radius1, Radius2), Angle, new Vector3d(0, 1, 0)));
            for (int i = 1; i + 1 &lt; Count; i++)
            {
                ResultBody[i % 2].AddRange(GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GetTowerClaneClaneUnit(Width2, Width2, Length, Space, Radius1, Radius2), new Vector3d(i * Length, 0, 0)), Angle, new Vector3d(0, 1, 0)));
            }
            Brep[] LadderBase = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GeneralHelper.RotateBreps(GetLadderSimple(Length), Math.PI / 2.0, new Vector3d(0, 0, 1)), new Vector3d(Width1 / 2.0, 0, 0)), Math.PI / 2.0, new Vector3d(0, 1, 0));
            for (int i = 0; i &lt; Count; i++)
            {
                ResultBody[i % 2 + 2].AddRange(GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GeneralHelper.DuplicateBreps(LadderBase), new Vector3d(i * Length, 0, 0)), Angle, new Vector3d(0, 1, 0)));
            }
            {
                int i = Count - 1;
                ResultBody[i % 2].AddRange(GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GetTowerClaneClaneUnit(Width2, Width1, Length, Space, Radius1, Radius2), new Vector3d(i * Length, 0, 0)), Angle, new Vector3d(0, 1, 0)));
            }
            {
                Brep[] WorkSpaceTemp = GetWorkSpace(Width1 * 2, Width1 * 2, 100);
                double WSAngle = Math.PI / 4.0;
                WorkSpace = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GeneralHelper.RotateBreps(WorkSpaceTemp, WSAngle, new Vector3d(0, 1, 0)), new Vector3d(Length * Count + Width1 * Math.Sin(WSAngle), 0, -Width1)), Angle, new Vector3d(0, 1, 0));
            }

            Body1 = ResultBody[0].ToArray();
            Body2 = ResultBody[1].ToArray();
            Ladder1 = ResultBody[2].ToArray();
            Ladder2 = ResultBody[3].ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンのクレーンユニットを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width1&quot;&gt;幅1&lt;/param&gt;
        /// &lt;param name=&quot;Width2&quot;&gt;幅2&lt;/param&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;半径1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;半径2&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetTowerClaneClaneUnit(double Width1, double Width2, double Length, double Space, double Radius1, double Radius2)
        {
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
            Polyline PartsPL = new Polyline(2);
            PartsPL.Add(0, Width1 / 2.0, Width1 / 2.0);
            PartsPL.Add(Length, Width2 / 2.0, Width2 / 2.0);
            Brep BaseParts1 = (Brep.CreateFromSweep(PartsPL.ToNurbsCurve(), GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius1)), PartsPL.ToNurbsCurve()), true, 1.0)[0]);
            for (int i = 0; i &lt; 4; i++)
            {
                Brep TempParts1 = (Brep)BaseParts1.Duplicate();
                TempParts1.Rotate(Math.PI / 2.0 * i, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
                Result.Add(TempParts1);
            }
            for (double CurrentLength = 0; CurrentLength &lt; Length; CurrentLength += Space)
            {
                PartsPL = new Polyline(2);
                PartsPL.Add(CurrentLength, (Width1 + (Width2 - Width1) * (CurrentLength / Length)) / 2.0, (Width1 + (Width2 - Width1) * (CurrentLength / Length)) / 2.0);
                PartsPL.Add((CurrentLength + Space / 2.0), -(Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0, (Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0);
                Brep BaseParts2 = (Brep.CreateFromSweep(PartsPL.ToNurbsCurve(), GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius1)), PartsPL.ToNurbsCurve()), true, 1.0)[0]);

                PartsPL = new Polyline(2);
                PartsPL.Add((CurrentLength + Space / 2.0), -(Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0, (Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0);
                PartsPL.Add((CurrentLength + Space), (Width1 + (Width2 - Width1) * ((CurrentLength + Space) / Length)) / 2.0, (Width1 + (Width2 - Width1) * ((CurrentLength + Space) / Length)) / 2.0);
                Brep BaseParts3 = (Brep.CreateFromSweep(PartsPL.ToNurbsCurve(), GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius1)), PartsPL.ToNurbsCurve()), true, 1.0)[0]);
                for (int i = 0; i &lt; 4; i++)
                {
                    Brep TempParts2 = (Brep)BaseParts2.Duplicate();
                    TempParts2.Rotate(Math.PI / 2.0 * i, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
                    Result.Add(TempParts2);

                    Brep TempParts3 = (Brep)BaseParts3.Duplicate();
                    TempParts3.Rotate(Math.PI / 2.0 * i, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
                    Result.Add(TempParts3);
                }
            }
            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーン用のケーブルローラーを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;CableRadius&quot;&gt;ケーブル半径&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;幅1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;幅2&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Body&quot;&gt;本体を出力します&lt;/param&gt;
        /// &lt;param name=&quot;Cable&quot;&gt;ケーブルを出力します&lt;/param&gt;
        /// &lt;param name=&quot;CableTarget&quot;&gt;ケーブル用の目標を設定します。&lt;/param&gt;
        public static void GetTowerClaneCableRoller(double Width, double CableRadius, double Radius1, double Radius2, double Thickness, out Brep[] Body, out Brep[] Cable, out Point3d CableTarget)
        {
            Body = new Brep[]{Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), Thickness), true, true),
      Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), -Thickness), true, true)};

            List&lt;Curve&gt; Arcs = new List&lt;Curve&gt;();
            Curve BaseArc = NurbsCurve.CreateFromArc(new Arc(new Circle(new Plane(new Point3d(0, 0, 0), new Vector3d(1, 0, 0)), CableRadius), new Interval(0, Math.PI)));
            for (double CurrentLength = -Width / 2.0 + Thickness + (Width / 2.0 - Thickness) % (CableRadius * 2); CurrentLength &lt; Width / 2.0 - Thickness; CurrentLength += CableRadius)
            {
                Curve TempArc = (Curve)BaseArc.Duplicate();
                TempArc.Translate(new Vector3d(0, CurrentLength, Radius1));
                Arcs.Add(TempArc);
            }
            Brep TempCable = Brep.CreateFromRevSurface(RevSurface.Create(Curve.JoinCurves(Arcs)[0], new Line(new Point3d(0, 0, 0), new Point3d(0, 1, 0))), false, false);
            TempCable.Translate(0, 0, Radius2);
            Cable = new Brep[] { TempCable };

            CableTarget = new Point3d(Radius1 * Math.Cos(Math.PI * 3.0 / 4.0), 0, Radius1 * Math.Sin(Math.PI * 3.0 / 4.0) + Radius2);
        }

        /// &lt;summary&gt;
        /// タワークレーン用のケーブルローラーの軽量版を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;CableRadius&quot;&gt;ケーブル半径&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;幅1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;幅2&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Body&quot;&gt;本体を出力します&lt;/param&gt;
        /// &lt;param name=&quot;Cable&quot;&gt;ケーブルを出力します&lt;/param&gt;
        /// &lt;param name=&quot;CableTarget&quot;&gt;ケーブル用の目標を設定します。&lt;/param&gt;
        public static void GetTowerClaneCableRollerLight(double Width, double CableRadius, double Radius1, double Radius2, double Thickness, out Brep[] Body, out Brep[] Cable, out Point3d CableTarget)
        {
            Body = new Brep[]{Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), Thickness), true, true),
      Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), -Thickness), true, true)};
            Cable = new Brep[] { Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Width / 2.0 + Thickness, Radius2), new Vector3d(0, 1, 0)), Radius1), Width - Thickness * 2), false, false) };
            CableTarget = new Point3d(Radius1 * Math.Cos(Math.PI * 3.0 / 4.0), 0, Radius1 * Math.Sin(Math.PI * 3.0 / 4.0) + Radius2);
        }

        /// &lt;summary&gt;
        /// 作業用スペースを出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep[] GetWorkSpace(double Width, double Length, double Thickness)
        {
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
            Result.Add(Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-Length / 2.0, Length / 2.0), new Interval(-Width / 2.0, Width / 2.0), new Interval(-Thickness, 0))));

            Polyline HandrailBase = new Polyline();
            double HRRadius = 25;
            HandrailBase.Add(Length / 2.0 - HRRadius * 2, Width / 2.0 - HRRadius * 2, 0);
            HandrailBase.Add(Length / 2.0 - HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
            HandrailBase.Add(-Length / 2.0 + HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
            HandrailBase.Add(-Length / 2.0 + HRRadius * 2, Width / 2.0 - HRRadius * 2, 0);
            HandrailBase.Add(Length / 2.0 - HRRadius * 2, Width / 2.0 - HRRadius * 2, 0);
            Result.AddRange(GetHandrailSimple(HandrailBase.ToNurbsCurve(), 800, new double[] { 400, 600 }, 500, HRRadius, 15, 10));

            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンのポールを出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;Size1&quot;&gt;サイズ1&lt;/param&gt;
        /// &lt;param name=&quot;Size2&quot;&gt;サイズ2&lt;/param&gt;
        /// &lt;param name=&quot;Radius&quot;&gt;半径&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep[] GetTowerClanePole(double Width, double Length, double Height, double Size1, double Size2, double Radius, double Space)
        {
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
            {
                Polyline BasePoly = new Polyline(5);
                BasePoly.Add(0, -Width / 2.0, 0);
                BasePoly.Add(Size1, -Width / 2.0, 0);
                BasePoly.Add(Size1, -Width / 2.0 + Size1, 0);
                BasePoly.Add(0, -Width / 2.0 + Size1, 0);
                BasePoly.Add(0, -Width / 2.0, 0);
                Brep TempBrep = (Brep.CreateFromSurface(Surface.CreateExtrusion(BasePoly.ToNurbsCurve(), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
                Result.Add(TempBrep);
                TempBrep = (Brep)TempBrep.Duplicate();
                TempBrep.Translate(0, Width - Size1, 0);
                Result.Add(TempBrep);
            }
            {
                Polyline BasePoly = new Polyline(5);
                BasePoly.Add(Length, -Width / 2.0, 0);
                BasePoly.Add(Length - Size2, -Width / 2.0, 0);
                BasePoly.Add(Length - Size2, -Width / 2.0 + Size2, 0);
                BasePoly.Add(Length, -Width / 2.0 + Size2, 0);
                BasePoly.Add(Length, -Width / 2.0, 0);
                Brep TempBrep = (Brep.CreateFromSurface(Surface.CreateExtrusion(BasePoly.ToNurbsCurve(), new Vector3d(-Length + Size1, 0, Height))).CapPlanarHoles(0));
                Result.Add(TempBrep);
                TempBrep = (Brep)TempBrep.Duplicate();
                TempBrep.Translate(0, Width - Size2, 0);
                Result.Add(TempBrep);
            }
            for (double CrtLen = Space; CrtLen &lt; Height; CrtLen += Space)
            {
                Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Plane(new Point3d(Size1 / 2.0, -Width / 2.0 + Size1, CrtLen), new Vector3d(0, 1, 0)), Radius))
                  , new Vector3d(0, Width - Size1 * 2, 0))));
            }

            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンの頭部を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Body&quot;&gt;本体&lt;/param&gt;
        /// &lt;param name=&quot;Handrail&quot;&gt;手すり&lt;/param&gt;
        /// &lt;param name=&quot;Wall&quot;&gt;壁&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        /// &lt;param name=&quot;Pole&quot;&gt;ポール&lt;/param&gt;
        /// &lt;param name=&quot;WorkSpace&quot;&gt;作業場&lt;/param&gt;
        /// &lt;param name=&quot;Angle&quot;&gt;角度&lt;/param&gt;
        /// &lt;param name=&quot;RedBody&quot;&gt;赤い部分&lt;/param&gt;
        /// &lt;param name=&quot;WhiteBody&quot;&gt;白い部分&lt;/param&gt;
        /// &lt;param name=&quot;ClaneLadderRed&quot;&gt;梯子(赤)&lt;/param&gt;
        /// &lt;param name=&quot;ClaneLadderWhite&quot;&gt;梯子(城)&lt;/param&gt;
        /// &lt;param name=&quot;ClaneWorkSpace&quot;&gt;作業場&lt;/param&gt;
        /// &lt;param name=&quot;WireLength&quot;&gt;ワイヤー長さ&lt;/param&gt;
        /// &lt;param name=&quot;Wire&quot;&gt;ワイヤー&lt;/param&gt;
        public static void GetTowerClaneHead(out Brep[] Body, out Brep[] Handrail, out Brep[] Wall, out Brep[] Glass, out Brep[] Pole
        , out Brep[] WorkSpace, double Angle, out Brep[] RedBody, out Brep[] WhiteBody, out Brep[] ClaneLadderRed, out Brep[] ClaneLadderWhite, out Brep[] ClaneWorkSpace, double WireLength, out Brep[] Wire)
        {

            GetTowerClaneHeadBase(4.5e3, 9e3, 500, out Body, out Handrail, out Wall, out Glass);
            Pole = GeneralHelper.TranslateBreps(GetTowerClanePole(4.5e3 / 3.0 + 500, 9e3 * 2 / 3, 10e3, 400, 400, 80, 2000), new Vector3d(-9e3 / 2.0, 0, 500));
            WorkSpace = GeneralHelper.TranslateBreps(GetWorkSpace(4.5e3 / 3.0 + 1e3, 1e3, 100), new Vector3d(-9e3 / 2.0 - (1e3) / 2.0 + 400, 0, 500 + 10e3 + 100));
            {
                Brep[] ResultClane1;
                Brep[] ResultClane2;
                Brep[] ResultClane3;
                Brep[] ResultClane4;
                Brep[] ResultClane5;

                GetTowerClaneClane(5, Angle, 500, 1000, 5000, 1000, 25, 10, out ResultClane1, out ResultClane2, out ResultClane3, out ResultClane4, out ResultClane5);
                RedBody = GeneralHelper.TranslateBreps(ResultClane1, new Vector3d(0, 0, 500 + 500));
                WhiteBody = GeneralHelper.TranslateBreps(ResultClane2, new Vector3d(0, 0, 500 + 500));
                ClaneLadderRed = GeneralHelper.TranslateBreps(ResultClane3, new Vector3d(0, 0, 500 + 500));
                ClaneLadderWhite = GeneralHelper.TranslateBreps(ResultClane4, new Vector3d(0, 0, 500 + 500));
                ClaneWorkSpace = GeneralHelper.TranslateBreps(ResultClane5, new Vector3d(0, 0, 500 + 500));
            }
            {
                double WireRadius = 25;
                List&lt;Brep&gt; ResultWire = new List&lt;Brep&gt;();
                {
                    Polyline WirePL = new Polyline();
                    WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) + 1e3 / 2.0, 0, 500 + 10e3 + 100 + 400);
                    WirePL.Add(5 * 5000 * Math.Cos(Angle), 0, 500 + 500 + 5 * 5000 * Math.Sin(Angle));

                    Curve RailCurve = WirePL.ToNurbsCurve();
                    RailCurve.Rotate(-Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
                    Brep WireBase = (Brep.CreateFromSweep(RailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(WireRadius)), RailCurve), true, 0.1)[0]).CapPlanarHoles(0);
                    WireBase.Rotate(Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));

                    Brep WireTemp = (Brep)WireBase.Duplicate();
                    WireTemp.Translate(0, (500 / 2.0), 0);
                    ResultWire.Add(WireTemp);

                    WireTemp = (Brep)WireBase.Duplicate();
                    WireTemp.Translate(0, -(500 / 2.0), 0);
                    ResultWire.Add(WireTemp);
                }
                {
                    Polyline WirePL = new Polyline();
                    WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) - 1e3 / 2.0 - 1e3, 0, 500);
                    WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) - 1e3 / 2.0, 0, 500 + 10e3 + 100 + 400);
                    WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) + 1e3 / 2.0, 0, 500 + 10e3 + 100 + 400);
                    WirePL.Add(5 * 5000 * Math.Cos(Angle), 0, 500 + 500 + 5 * 5000 * Math.Sin(Angle));
                    WirePL.Add(5 * 5000 * Math.Cos(Angle), 0, 500 + 500 + 5 * 5000 * Math.Sin(Angle) - WireLength);

                    Curve RailCurve = WirePL.ToNurbsCurve();
                    RailCurve.Rotate(-Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
                    Brep WireBase = (Brep.CreateFromSweep(RailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(WireRadius)), RailCurve), true, 0.1)[0]).CapPlanarHoles(0);
                    WireBase.Rotate(Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));

                    Brep WireTemp = (Brep)WireBase.Duplicate();
                    WireTemp.Translate(0, (500 / 2.0) / 3.0, 0);
                    ResultWire.Add(WireTemp);

                    WireTemp = (Brep)WireBase.Duplicate();
                    WireTemp.Translate(0, -(500 / 2.0) / 3.0, 0);
                    ResultWire.Add(WireTemp);
                }
                Wire = ResultWire.ToArray();
            }
        }

        /// &lt;summary&gt;
        /// タワークレーンの頭部基底部を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Body&quot;&gt;本体&lt;/param&gt;
        /// &lt;param name=&quot;Handrail&quot;&gt;手すり&lt;/param&gt;
        /// &lt;param name=&quot;Wall&quot;&gt;壁&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        public static void GetTowerClaneHeadBase(double Width, double Length, double Thickness, out Brep[] Body, out Brep[] Handrail, out Brep[] Wall, out Brep[] Glass)
        {
            GetTowerClaneControlUnit(Width / 3.0, Length / 2.0, Length / 2.0 + 500, 1.0e3, 2.5e3, 1.0e3, 150, out Wall, out Glass);
            Wall = GeneralHelper.TranslateBreps(Wall, new Point3d(-Length / 4.0, -Width / 2.0 - 500, Thickness));
            Glass = GeneralHelper.TranslateBreps(Glass, new Point3d(-Length / 4.0, -Width / 2.0 - 500, Thickness));
            Body = new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-Length * 3.0 / 4.0, Length / 4.0), new Interval(-Width / 2.0, Width / 2.0), new Interval(0, Thickness))) };

            Polyline HandrailBase = new Polyline();
            double HRRadius = 25;
            HandrailBase.Add(-Length / 4.0 - HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
            HandrailBase.Add(-Length * 3.0 / 4.0 + HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
            HandrailBase.Add(-Length * 3.0 / 4.0 + HRRadius * 2, +Width / 2.0 - HRRadius * 2, 0);
            HandrailBase.Add(Length / 4.0 - HRRadius * 2, +Width / 2.0 - HRRadius * 2, 0);
            Handrail = GeneralHelper.TranslateBreps(GetHandrailSimple(HandrailBase.ToNurbsCurve(), 800, new double[] { 400, 600 }, 500, HRRadius, 15, 10), new Vector3d(0, 0, Thickness));
        }

        /// &lt;summary&gt;
        /// タワークレーンの操作ユニットを出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Wall&quot;&gt;壁&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        public static void GetTowerClaneControlUnit(out Brep[] Wall, out Brep[] Glass)
        {
            GetTowerClaneControlUnit(1.5e3, 5e3, 5.5e3, 1.0e3, 2.5e3, 1.0e3, 150, out Wall, out Glass);
        }

        /// &lt;summary&gt;
        /// タワークレーンの操作ユニットを出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;BottomLength&quot;&gt;底の長さ&lt;/param&gt;
        /// &lt;param name=&quot;TopLength&quot;&gt;上部の長さ&lt;/param&gt;
        /// &lt;param name=&quot;SideWindowLength&quot;&gt;横の窓の長さ&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;BarHeight&quot;&gt;バーの高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameWidth&quot;&gt;フレームの幅&lt;/param&gt;
        /// &lt;param name=&quot;Wall&quot;&gt;壁&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        public static void GetTowerClaneControlUnit(double Width, double BottomLength, double TopLength, double SideWindowLength, double Height, double BarHeight, double FrameWidth, out Brep[] Wall, out Brep[] Glass)
        {
            double WallThickness = 50.0;
            List&lt;Brep&gt; RetWall = new List&lt;Brep&gt;();
            {
                Polyline Parts1PL = new Polyline(13);
                Parts1PL.Add(0, 0, 0);
                Parts1PL.Add(BottomLength, 0, 0);
                Parts1PL.Add(BottomLength, 0, FrameWidth);
                Parts1PL.Add(BottomLength - SideWindowLength, 0, FrameWidth);
                Parts1PL.Add(BottomLength - SideWindowLength, 0, BarHeight);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height, 0, BarHeight);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * (BarHeight + FrameWidth) / Height, 0, (BarHeight + FrameWidth));
                Parts1PL.Add(BottomLength - SideWindowLength, 0, (BarHeight + FrameWidth));
                Parts1PL.Add(BottomLength - SideWindowLength, 0, (Height - FrameWidth));
                Parts1PL.Add(TopLength - (TopLength - BottomLength) * FrameWidth / Height, 0, (Height - FrameWidth));
                Parts1PL.Add(TopLength, 0, Height);
                Parts1PL.Add(0, 0, Height);
                Parts1PL.Add(0, 0, 0);
                Curve Part1Curve = Parts1PL.ToNurbsCurve();
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, -WallThickness, 0))).CapPlanarHoles(0));
                Part1Curve.Translate(0, Width, 0);
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, WallThickness, 0))).CapPlanarHoles(0));
            }
            {
                Polyline Parts1PL = new Polyline(5);
                Parts1PL.Add(BottomLength, 0, 0);
                Parts1PL.Add(TopLength, 0, Height);
                Parts1PL.Add(TopLength - FrameWidth, 0, Height);
                Parts1PL.Add(BottomLength - FrameWidth, 0, 0);
                Parts1PL.Add(BottomLength, 0, 0);
                Curve Part1Curve = Parts1PL.ToNurbsCurve();
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, -WallThickness, 0))).CapPlanarHoles(0));
                Part1Curve.Translate(0, Width, 0);
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, WallThickness, 0))).CapPlanarHoles(0));
                Part1Curve.Translate(0, -Width / 2.0 - FrameWidth / 2.0, 0);
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, FrameWidth, 0))).CapPlanarHoles(0));
            }
            {
                Polyline Parts1PL = new Polyline(5);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height, 0, BarHeight);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * (BarHeight + FrameWidth) / Height, 0, (BarHeight + FrameWidth));
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * (BarHeight + FrameWidth) / Height - WallThickness, 0, (BarHeight + FrameWidth));
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height - WallThickness, 0, BarHeight);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height, 0, BarHeight);
                Curve Part1Curve = Parts1PL.ToNurbsCurve();
                Part1Curve.Translate(0, -WallThickness / 2.0, 0);
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, Width + WallThickness, 0))).CapPlanarHoles(0));
            }
            {
                Polyline Parts1PL = new Polyline(13);
                Parts1PL.Add(0, 0, 0);
                Parts1PL.Add(BottomLength, 0, 0);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * FrameWidth / Height, 0, FrameWidth);
                Parts1PL.Add(BottomLength + (TopLength - BottomLength) * FrameWidth / Height - WallThickness, 0, FrameWidth);
                Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
                Parts1PL.Add(WallThickness, 0, WallThickness);
                Parts1PL.Add(WallThickness, 0, Height - WallThickness);
                Parts1PL.Add(TopLength - WallThickness, 0, Height - WallThickness);
                Parts1PL.Add(TopLength - (TopLength - BottomLength) * FrameWidth / Height - WallThickness, 0, (Height - FrameWidth));
                Parts1PL.Add(TopLength - (TopLength - BottomLength) * FrameWidth / Height, 0, (Height - FrameWidth));
                Parts1PL.Add(TopLength, 0, Height);
                Parts1PL.Add(0, 0, Height);
                Parts1PL.Add(0, 0, 0);
                Curve Part1Curve = Parts1PL.ToNurbsCurve();
                Part1Curve.Translate(0, -WallThickness / 2.0, 0);
                RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, Width + WallThickness, 0))).CapPlanarHoles(0));
            }
            List&lt;Brep&gt; RetGlass = new List&lt;Brep&gt;();
            {
                Polyline Parts1PL = new Polyline(5);
                Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
                Parts1PL.Add(TopLength - WallThickness, 0, Height - WallThickness);
                Parts1PL.Add(TopLength - WallThickness * 2, 0, Height - WallThickness);
                Parts1PL.Add(BottomLength - WallThickness * 2, 0, WallThickness);
                Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
                Curve Part1Curve = Parts1PL.ToNurbsCurve();
                RetGlass.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, Width, 0))).CapPlanarHoles(0));
            }
            {
                Polyline Parts1PL = new Polyline(5);
                Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
                Parts1PL.Add(TopLength - WallThickness, 0, Height - WallThickness);
                Parts1PL.Add(BottomLength - WallThickness - SideWindowLength, 0, Height - WallThickness);
                Parts1PL.Add(BottomLength - WallThickness - SideWindowLength, 0, WallThickness);
                Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
                Curve Part1Curve = Parts1PL.ToNurbsCurve();
                RetGlass.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, WallThickness, 0))).CapPlanarHoles(0));
                Part1Curve.Translate(0, Width, 0);
                RetGlass.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, -WallThickness, 0))).CapPlanarHoles(0));
            }
            Wall = RetWall.ToArray();
            Glass = RetGlass.ToArray();
        }

        /// &lt;summary&gt;
        /// 手すりを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BaseCurve&quot;&gt;ガイドレール&lt;/param&gt;
        /// &lt;param name=&quot;Height&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;RailHeight&quot;&gt;レールの高さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;半径1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;半径2&lt;/param&gt;
        /// &lt;param name=&quot;Radius3&quot;&gt;半径3&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetHandrailSimple(Curve BaseCurve, double Height, double[] RailHeight, double Space, double Radius1, double Radius2, double Radius3)
        {
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
            {
                Curve TopRailCurve = (Curve)BaseCurve.Duplicate();
                TopRailCurve.Translate(0, 0, Height);
                Result.Add(Brep.CreateFromSweep(TopRailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius2)), TopRailCurve), true, Space / 1000)[0]);
            }
            foreach (double TempHeight in RailHeight)
            {
                Curve TopRailCurve = (Curve)BaseCurve.Duplicate();
                TopRailCurve.Translate(0, 0, TempHeight);
                Result.Add(Brep.CreateFromSweep(TopRailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius3)), TopRailCurve), true, Space / 1000)[0]);
            }
            double Length = BaseCurve.GetLength();
            for (double CurrentLength = 0; CurrentLength &lt; Length; CurrentLength += Space)
            {
                Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(BaseCurve.PointAtLength(CurrentLength), Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
            }
            if (!BaseCurve.IsClosed)
            {
                Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(BaseCurve.PointAtLength(Length), Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
                Result[0] = Result[0].CapPlanarHoles(0);
                for (int i = 0; i &lt; RailHeight.GetLength(0); i++)
                {
                    Result[1 + i] = Result[1 + i].CapPlanarHoles(0);
                }
            }

            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンの回転部分
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Height1&quot;&gt;高さ1&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;半径1&lt;/param&gt;
        /// &lt;param name=&quot;Height2&quot;&gt;高さ2&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;半径2&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep[] GetTowerClaneRotationUnit(double Height1, double Radius1, double Height2, double Radius2)
        {
            Brep Cylinder2 = Brep.CreateFromCylinder(new Cylinder(new Circle(Radius2 / 2.0), Height2), true, true);
            Cylinder2.Translate(0, 0, Height1 - Height2);
            return new Brep[]{
      Brep.CreateFromCylinder(new Cylinder(new Circle(Radius1 / 2.0), Height1), true, false),Cylinder2
      };
        }

        /// &lt;summary&gt;
        /// タワークレーンのリフトフレームを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Size1&quot;&gt;サイズ1&lt;/param&gt;
        /// &lt;param name=&quot;Size2&quot;&gt;サイズ2&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetTowerClaneLiftFrame(double Size1, double Size2)
        {
            Brep[] Parts1;
            Brep[] Parts2;
            Brep[] Parts3;
            GetTowerClaneLiftFrame(Size1, Size2, out Parts1, out Parts2, out Parts3);
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
            Result.AddRange(Parts1);
            Result.AddRange(Parts2);
            Result.AddRange(Parts3);
            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンのリフトフレームを取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Size1&quot;&gt;サイズ1&lt;/param&gt;
        /// &lt;param name=&quot;Size2&quot;&gt;サイズ2&lt;/param&gt;
        /// &lt;param name=&quot;Parts1&quot;&gt;パーツ1&lt;/param&gt;
        /// &lt;param name=&quot;Parts2&quot;&gt;パーツ2&lt;/param&gt;
        /// &lt;param name=&quot;Parts3&quot;&gt;パーツ3&lt;/param&gt;
        public static void GetTowerClaneLiftFrame(double Size1, double Size2, out Brep[] Parts1, out Brep[] Parts2, out Brep[] Parts3)
        {
            double UnitHeight = Size1 * 0.8;
            int UnitCount = 4;
            double TotalHeight = UnitHeight * UnitCount;
            double Elevation = 200;

            Parts1 = GeneralHelper.TranslateBreps(GetTowerClaneBasement(UnitCount, Size1, UnitHeight, 30, 150, 100), new Vector3d(0, 0, -TotalHeight - Elevation));
            double HandrailRadius = 25.0;
            Brep[] HandrailBase = GetHandrailSimple((new Rhino.Geometry.Rectangle3d(Plane.WorldXY, new Interval(-Size2 / 2.0 + HandrailRadius, Size2 / 2.0 - HandrailRadius), new Interval(-Size2 / 2.0 + HandrailRadius, Size2 / 2.0 - HandrailRadius))
              ).ToNurbsCurve(), 800, new double[] { 500 }, 500, HandrailRadius, 15, 10);
            List&lt;Brep&gt; RetParts2 = new List&lt;Brep&gt;();
            RetParts2.AddRange(GeneralHelper.TranslateBreps(HandrailBase, new Vector3d(0, 0, -TotalHeight - Elevation)));
            RetParts2.AddRange(GeneralHelper.TranslateBreps(HandrailBase, new Vector3d(0, 0, -TotalHeight / 2.0 - Elevation)));
            Parts2 = RetParts2.ToArray();

            List&lt;Brep&gt; RetParts3 = new List&lt;Brep&gt;();

            Brep[] FloorBase = new Brep[4];
            {
                double Size3 = Size1 + 30 * 2;
                double Parts3Width = 10.0;
                double Parts3Bending = 50.0;
                Polyline Parts3PL = new Polyline(9);
                Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0, 0);
                Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0, 0);
                Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0, -Parts3Bending);
                Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0 - Parts3Width, -Parts3Bending);
                Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0 - Parts3Width, -Parts3Width);
                Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0 + Parts3Width, -Parts3Width);
                Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0 + Parts3Width, -Parts3Bending);
                Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0, -Parts3Bending);
                Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0, 0);
                Brep FloorBasePart = Brep.CreateFromSurface(Surface.CreateExtrusion(Parts3PL.ToNurbsCurve(), new Vector3d(Size2 / 2.0 + Size3 / 2.0, 0, 0))).CapPlanarHoles(0);

                for (int i = 0; i &lt; 4; i++)
                {
                    Brep TempFloor = (Brep)FloorBasePart.Duplicate();
                    TempFloor.Rotate(Math.PI / 2.0 * i, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                    FloorBase[i] = TempFloor;
                }
            }
            RetParts3.AddRange(GeneralHelper.TranslateBreps(FloorBase, new Vector3d(0, 0, -TotalHeight - Elevation)));
            RetParts3.AddRange(GeneralHelper.TranslateBreps(FloorBase, new Vector3d(0, 0, -TotalHeight / 2.0 - Elevation)));
            Parts3 = RetParts3.ToArray();
        }

        /// &lt;summary&gt;
        /// 単純な梯子を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetLadderSimple(double Length)
        {
            return GetLadderSimple(Length, 300, 400, 25, 15);
        }

        /// &lt;summary&gt;
        /// 単純な梯子を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Length&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;Space&quot;&gt;間隔&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;Radius1&quot;&gt;半径1&lt;/param&gt;
        /// &lt;param name=&quot;Radius2&quot;&gt;半径2&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetLadderSimple(double Length, double Space, double Width, double Radius1, double Radius2)
        {
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
            Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Point3d(-Width / 2.0, 0, 0), Radius1)), new Vector3d(0, 0, Length))).CapPlanarHoles(0));
            Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Point3d(+Width / 2.0, 0, 0), Radius1)), new Vector3d(0, 0, Length))).CapPlanarHoles(0));

            for (double CurrentLength = Space; CurrentLength &lt; Length; CurrentLength += Space)
            {
                Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Plane(new Point3d(-Width / 2.0, 0, CurrentLength), new Vector3d(1, 0, 0)), Radius2)), new Vector3d(Width, 0, 0))).CapPlanarHoles(0));
            }
            return Result.ToArray();
        }

        /// &lt;summary&gt;
        /// タワークレーンの基底部分を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Count&quot;&gt;ブロック数&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetTowerClaneBasement(int Count)
        {
            return GetTowerClaneBasement(Count, 1000, 800, 30, 150, 100);
        }

        /// &lt;summary&gt;
        /// タワークレーンの基底部分を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Count&quot;&gt;ブロック数&lt;/param&gt;
        /// &lt;param name=&quot;UnitWidth&quot;&gt;ブロックの幅&lt;/param&gt;
        /// &lt;param name=&quot;UnitHeight&quot;&gt;ブロックの高さ&lt;/param&gt;
        /// &lt;param name=&quot;Thickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Width1&quot;&gt;幅1&lt;/param&gt;
        /// &lt;param name=&quot;Width2&quot;&gt;幅2&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetTowerClaneBasement(int Count, double UnitWidth, double UnitHeight, double Thickness, double Width1, double Width2)
        {
            double Tr1 = UnitWidth / 2.0 - Width1 / 2.0;
            double Tr2 = UnitHeight - Width2;
            double Tr3 = Math.Sqrt(Tr1 * Tr1 + Tr2 * Tr2);

            Polyline BasePL1 = new Polyline(7);
            BasePL1.Add(0, 0, 0);
            BasePL1.Add(Width1, 0, 0);
            BasePL1.Add(Width1, -Thickness, 0);
            BasePL1.Add(-Thickness, -Thickness, 0);
            BasePL1.Add(-Thickness, Width1, 0);
            BasePL1.Add(0, Width1, 0);
            BasePL1.Add(0, 0, 0);
            Brep Parts1 = Brep.CreateFromSurface(Surface.CreateExtrusion((BasePL1.ToNurbsCurve()), new Vector3d(0, 0, UnitHeight * Count))).CapPlanarHoles(0);
            Parts1.Translate(-UnitWidth / 2.0, -UnitWidth / 2.0, 0);

            Polyline BasePL3 = new Polyline(12);
            BasePL3.Add(Width1 / 2.0, 0, 0);
            BasePL3.Add(UnitWidth / 2.0, 0, UnitHeight - Width2);
            BasePL3.Add(UnitWidth - Width1 / 2.0, 0, 0);
            BasePL3.Add(UnitWidth - Width1 / 2.0, 0, Width2 / Tr1 * Tr3);
            BasePL3.Add(UnitWidth / 2.0 + Width2 / Tr2 * Tr3, 0, UnitHeight - Width2);
            BasePL3.Add(UnitWidth - Width1 / 2.0, 0, UnitHeight - Width2);
            BasePL3.Add(UnitWidth - Width1 / 2.0, 0, UnitHeight);

            BasePL3.Add(Width1 / 2.0, 0, UnitHeight);
            BasePL3.Add(Width1 / 2.0, 0, UnitHeight - Width2);
            BasePL3.Add(UnitWidth / 2.0 - Width2 / Tr2 * Tr3, 0, UnitHeight - Width2);
            BasePL3.Add(Width1 / 2.0, 0, Width2 / Tr1 * Tr3);
            BasePL3.Add(Width1 / 2.0, 0, 0);
            Brep Parts3 = Brep.CreateFromSurface(Surface.CreateExtrusion((BasePL3.ToNurbsCurve()), new Vector3d(0, Thickness, 0))).CapPlanarHoles(0);
            Parts3.Translate(-UnitWidth / 2.0, -UnitWidth / 2.0, 0);

            Brep[] Result = new Brep[4 + Count * 4];
            for (int i = 0; i &lt; 4; i++)
            {
                Brep TempParts1 = (Brep)Parts1.Duplicate();
                TempParts1.Rotate(Math.PI / 2.0 * i, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                Result[i] = TempParts1;

                for (int j = 0; j &lt; Count; j++)
                {
                    Brep TempParts3 = (Brep)Parts3.Duplicate();
                    TempParts3.Rotate(Math.PI / 2.0 * i, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
                    TempParts3.Translate(0, 0, j * UnitHeight);
                    Result[4 + j * 4 + i] = TempParts3;
                }
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// スパンドレル付きのガラス窓を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;WindowWidth&quot;&gt;窓の幅&lt;/param&gt;
        /// &lt;param name=&quot;WindowHeight&quot;&gt;窓の高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSize&quot;&gt;枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness&quot;&gt;枠の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelHeight&quot;&gt;スパンドレルの高さ&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;窓枠&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        /// &lt;param name=&quot;Spandrel&quot;&gt;スパンドレル&lt;/param&gt;
        public static void GetGlassWithSpandrel(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
        {
            double SpandrelSpace = FrameSize;
            double SpandrelSpaceZ = GlassThickness * 2;
            double SpandrelThickness = GlassThickness;

            GetGlassWithSpandrel(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, SpandrelHeight, SpandrelSpace, SpandrelSpaceZ, SpandrelThickness, out Frame, out Glass, out Spandrel);
        }

        /// &lt;summary&gt;
        /// スパンドレル付きのガラス窓を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;WindowWidth&quot;&gt;窓の幅&lt;/param&gt;
        /// &lt;param name=&quot;WindowHeight&quot;&gt;窓の高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSize&quot;&gt;枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness&quot;&gt;枠の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelHeight&quot;&gt;スパンドレルの高さ&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelSpace&quot;&gt;スパンドレルの間隔&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelSpaceZ&quot;&gt;スパンドレルのZ方向間隔&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelThickness&quot;&gt;スパンドレルの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;窓枠&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        /// &lt;param name=&quot;Spandrel&quot;&gt;スパンドレル&lt;/param&gt;
        public static void GetGlassWithSpandrel(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, double SpandrelSpace, double SpandrelSpaceZ, double SpandrelThickness, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
        {
            Brep BaseFrame;
            GetGlassSimple(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, out BaseFrame, out Glass);
            Spandrel = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(SpandrelSpace, SpandrelHeight - SpandrelSpace), new Interval(SpandrelSpace, WindowWidth - SpandrelSpace), new Interval(SpandrelSpaceZ, SpandrelSpaceZ + SpandrelThickness)));
            Brep SpandrelFrame = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(SpandrelHeight - FrameSize, SpandrelHeight), new Interval(FrameSize / 2.0, WindowWidth - FrameSize / 2.0), new Interval(-FrameThickness, GlassThickness)));
            Frame = new Brep[] { BaseFrame, SpandrelFrame };
        }

        /// &lt;summary&gt;
        /// 上側がスパンドレルのスパンドレル付きのガラス窓を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;WindowWidth&quot;&gt;窓の幅&lt;/param&gt;
        /// &lt;param name=&quot;WindowHeight&quot;&gt;窓の高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSize&quot;&gt;枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness&quot;&gt;枠の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelHeight&quot;&gt;スパンドレルの高さ&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;窓枠&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        /// &lt;param name=&quot;Spandrel&quot;&gt;スパンドレル&lt;/param&gt;
        public static void GetGlassWithSpandrelUpsidedown(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
        {
            double SpandrelSpace = FrameSize;
            double SpandrelSpaceZ = GlassThickness * 2;
            double SpandrelThickness = GlassThickness;

            GetGlassWithSpandrelUpsidedown(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, SpandrelHeight, SpandrelSpace, SpandrelSpaceZ, SpandrelThickness, out Frame, out Glass, out Spandrel);
        }

        /// &lt;summary&gt;
        /// スパンドレル付きのガラス窓を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;WindowWidth&quot;&gt;窓の幅&lt;/param&gt;
        /// &lt;param name=&quot;WindowHeight&quot;&gt;窓の高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSize&quot;&gt;枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness&quot;&gt;枠の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelHeight&quot;&gt;スパンドレルの高さ&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelSpace&quot;&gt;スパンドレルの間隔&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelSpaceZ&quot;&gt;スパンドレルのZ方向間隔&lt;/param&gt;
        /// &lt;param name=&quot;SpandrelThickness&quot;&gt;スパンドレルの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;窓枠&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        /// &lt;param name=&quot;Spandrel&quot;&gt;スパンドレル&lt;/param&gt;
        public static void GetGlassWithSpandrelUpsidedown(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, double SpandrelSpace, double SpandrelSpaceZ, double SpandrelThickness, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
        {
            Brep BaseFrame;
            GetGlassSimple(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, out BaseFrame, out Glass);
            Spandrel = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, WindowHeight - SpandrelHeight), new Vector3d(0, 1, 0)), new Interval(SpandrelSpace, SpandrelHeight - SpandrelSpace), new Interval(SpandrelSpace, WindowWidth - SpandrelSpace), new Interval(SpandrelSpaceZ, SpandrelSpaceZ + SpandrelThickness)));
            Brep SpandrelFrame = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(WindowHeight - SpandrelHeight, WindowHeight - SpandrelHeight + FrameSize), new Interval(FrameSize / 2.0, WindowWidth - FrameSize / 2.0), new Interval(-FrameThickness, GlassThickness)));
            Frame = new Brep[] { BaseFrame, SpandrelFrame };
        }

        /// &lt;summary&gt;
        /// 基本的なガラス窓を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;WindowWidth&quot;&gt;窓の幅&lt;/param&gt;
        /// &lt;param name=&quot;WindowHeight&quot;&gt;窓の高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSize&quot;&gt;枠の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness&quot;&gt;枠の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;枠&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        public static void GetGlassSimple(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, out Brep Frame, out Brep Glass)
        {
            GetGlassSimple(WindowWidth, WindowHeight, FrameSize, FrameSize, FrameThickness, GlassThickness, out Frame, out Glass);
        }

        /// &lt;summary&gt;
        /// 基本的なガラス窓を出力します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;WindowWidth&quot;&gt;窓の幅&lt;/param&gt;
        /// &lt;param name=&quot;WindowHeight&quot;&gt;窓の高さ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSizeX&quot;&gt;枠の大きさ(左右)&lt;/param&gt;
        /// &lt;param name=&quot;FrameSizeY&quot;&gt;枠の大きさ(上下)&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness&quot;&gt;枠の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Frame&quot;&gt;枠&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        public static void GetGlassSimple(double WindowWidth, double WindowHeight, double FrameSizeX, double FrameSizeY, double FrameThickness, double GlassThickness, out Brep Frame, out Brep Glass)
        {
            Brep FrameBase = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(0, WindowHeight), new Interval(0, WindowWidth), new Interval(-FrameThickness, GlassThickness)));
            Brep Splitter = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(FrameSizeY, WindowHeight - FrameSizeY), new Interval(FrameSizeX, WindowWidth - FrameSizeX), new Interval(-FrameThickness * 2, GlassThickness * 2)));
            var SplitResult = (FrameBase.Split(Splitter, 0.10));
            Frame = SplitResult[0];
            Glass = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(FrameSizeY, WindowHeight - FrameSizeY), new Interval(FrameSizeX, WindowWidth - FrameSizeX), new Interval(0, GlassThickness)));
        }

        /// &lt;summary&gt;
        /// 上下の枠と左右の枠が独立したガラス窓を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;FrameSizeX&quot;&gt;左右の枠サイズ&lt;/param&gt;
        /// &lt;param name=&quot;FrameSizeY&quot;&gt;上下の枠サイズ&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness1&quot;&gt;枠の厚さ1&lt;/param&gt;
        /// &lt;param name=&quot;FrameThickness2&quot;&gt;枠の厚さ2&lt;/param&gt;
        /// &lt;param name=&quot;UnitSizeX&quot;&gt;ユニットの水平方向の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;UnitSizeY&quot;&gt;ユニットの鉛直方向の大きさ&lt;/param&gt;
        /// &lt;param name=&quot;GlassThickness&quot;&gt;ガラスの厚さ&lt;/param&gt;
        /// &lt;param name=&quot;UnitCountX&quot;&gt;水平方向の個数&lt;/param&gt;
        /// &lt;param name=&quot;UnitCountY&quot;&gt;鉛直方向の個数&lt;/param&gt;
        /// &lt;param name=&quot;Glass&quot;&gt;ガラス&lt;/param&gt;
        /// &lt;param name=&quot;Frame1&quot;&gt;枠1&lt;/param&gt;
        /// &lt;param name=&quot;Frame2&quot;&gt;枠2&lt;/param&gt;
        public static void GetIsolatedWindow(double FrameSizeX, double FrameSizeY, double FrameThickness1, double FrameThickness2, double UnitSizeX, double UnitSizeY, double GlassThickness, int UnitCountX, int UnitCountY, out Brep[] Glass, out Brep[] Frame1, out Brep[] Frame2)
        {
            Frame1 = new Brep[UnitCountY * 2];
            for (int i = 0; i &lt; UnitCountY; i++)
            {
                Frame1[i * 2] = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, UnitSizeY * i), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(0, UnitSizeX * UnitCountX), new Interval(0, FrameSizeY), new Interval(-GlassThickness, FrameThickness1)));
                Frame1[i * 2 + 1] = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, UnitSizeY * (i + 1)), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(0, UnitSizeX * UnitCountX), new Interval(-FrameSizeY, 0), new Interval(-GlassThickness, FrameThickness1)));
            }
            Frame2 = new Brep[UnitCountX * 2];
            for (int i = 0; i &lt; UnitCountX; i++)
            {
                Frame2[i * 2] = Brep.CreateFromBox(new Box(new Plane(new Point3d(UnitSizeX * i, 0, 0), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(0, FrameSizeX), new Interval(0, UnitSizeY * UnitCountY), new Interval(-GlassThickness, FrameThickness2)));
                Frame2[i * 2 + 1] = Brep.CreateFromBox(new Box(new Plane(new Point3d(UnitSizeX * (i + 1), 0, 0), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(-FrameSizeX, 0), new Interval(0, UnitSizeY * UnitCountY), new Interval(-GlassThickness, FrameThickness2)));
            }
            Glass = new Brep[UnitCountX * UnitCountY];
            for (int i = 0; i &lt; UnitCountX; i++)
            {
                for (int j = 0; j &lt; UnitCountY; j++)
                {
                    Glass[i * UnitCountY + j] = Brep.CreateFromBox(new Box(new Plane(new Point3d(UnitSizeX * i, 0, UnitSizeY * j), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(FrameSizeX, UnitSizeX - FrameSizeX), new Interval(FrameSizeY, UnitSizeY - FrameSizeY), new Interval(-GlassThickness, 0)));
                }
            }
        }

        /// &lt;summary&gt;
        /// 全体が結合している階段を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Count&quot;&gt;段数&lt;/param&gt;
        /// &lt;param name=&quot;StairWidth&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;StairHeight&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;StairLength&quot;&gt;長さ&lt;/param&gt;
        /// &lt;param name=&quot;StairThicknss&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;returns&gt;結果(単一のBrep)&lt;/returns&gt;
        public static Brep GetStairsSolid(int Count, double StairWidth, double StairHeight, double StairLength, double StairThicknss)
        {
            StairThicknss = Math.Max(1, Math.Abs(StairThicknss));
            Rhino.Geometry.Polyline pl = new Polyline(4 + Count * 2);
            pl.Add(0, StairLength * (Count), StairHeight * (Count));
            pl.Add(0, StairLength * (Count), StairHeight * (Count) - StairThicknss);
            pl.Add(0, StairLength, StairHeight - StairThicknss);
            pl.Add(0, 0, StairHeight - StairThicknss);
            for (int i = 1; i &lt;= Count; i++)
            {
                pl.Add(0, StairLength * (i - 1), StairHeight * i);
                pl.Add(0, StairLength * (i), StairHeight * i);
            }
            return Brep.CreateFromSurface(Surface.CreateExtrusion((pl.ToNurbsCurve()), new Vector3d(StairWidth, 0, 0))).CapPlanarHoles(0);
        }

        /// &lt;summary&gt;
        /// 単純な階段を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Count&quot;&gt;段数&lt;/param&gt;
        /// &lt;param name=&quot;StairWidth&quot;&gt;幅&lt;/param&gt;
        /// &lt;param name=&quot;StairHeight&quot;&gt;高さ&lt;/param&gt;
        /// &lt;param name=&quot;StairLength1&quot;&gt;長さ1&lt;/param&gt;
        /// &lt;param name=&quot;StairLength2&quot;&gt;長さ2&lt;/param&gt;
        /// &lt;param name=&quot;StairThickness&quot;&gt;厚さ&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Brep[] GetStairsSimple(int Count, double StairWidth, double StairHeight, double StairLength1, double StairLength2, double StairThickness)
        {
            Brep[] result = new Brep[Count];
            for (int i = 1; i &lt;= Count; i++)
            {
                result[i - 1] = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, StairLength2 * (i - 1), StairHeight * i), new Vector3d(1, 0, 0), new Vector3d(0, 1, 0))
                  , new Interval(0, StairWidth), new Interval(0, StairLength1), new Interval(-StairThickness, 0)));
            }
            return result;
        }

        /// &lt;summary&gt;
        /// 基本的な階段を取得します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Count&quot;&gt;段数&lt;/param&gt;
        /// &lt;param name=&quot;StairWidth&quot;&gt;階段の幅&lt;/param&gt;
        /// &lt;param name=&quot;StairHeight&quot;&gt;階段の高さ&lt;/param&gt;
        /// &lt;param name=&quot;StairLength1&quot;&gt;階段の長さ1&lt;/param&gt;
        /// &lt;param name=&quot;StairLength2&quot;&gt;階段の長さ2&lt;/param&gt;
        /// &lt;param name=&quot;StairThickness&quot;&gt;階段の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;OtherThickness&quot;&gt;他の厚さ&lt;/param&gt;
        /// &lt;param name=&quot;Stairs&quot;&gt;階段&lt;/param&gt;
        /// &lt;param name=&quot;Other&quot;&gt;その他&lt;/param&gt;
        public static void GetStairsBasic(int Count, double StairWidth, double StairHeight, double StairLength1, double StairLength2, double StairThickness, double OtherThickness, out Brep[] Stairs, out Brep[] Other)
        {
            Stairs = GetStairsSimple(Count, StairWidth, StairHeight, StairLength1, StairLength2, StairThickness);

            Rhino.Geometry.Polyline pl = new Polyline(7);
            pl.Add(0, 0, StairHeight - StairThickness);
            pl.Add(0, StairLength1, StairHeight - StairThickness);
            pl.Add(0, StairLength1 + StairLength2 * Count, StairHeight * (Count + 1) - StairThickness);
            pl.Add(0, StairLength1 + StairLength2 * Count, StairHeight * (Count + 1));
            pl.Add(0, StairLength2 * Count, StairHeight * (Count + 1));
            pl.Add(0, 0, StairHeight);
            pl.Add(0, 0, StairHeight - StairThickness);

            Curve plc = pl.ToNurbsCurve();
            Brep otherSrf1 = Brep.CreateFromSurface(Surface.CreateExtrusion(plc, new Vector3d(-OtherThickness, 0, 0))).CapPlanarHoles(0);
            Brep otherSrf2 = (Brep)otherSrf1.Duplicate();
            otherSrf2.Translate(StairWidth + OtherThickness, 0, 0);
            Other = new Brep[] { otherSrf1, otherSrf2 };
        }

        /// &lt;summary&gt;
        /// 線に沿って点字ブロック(視覚障害者誘導用ブロック)を配置します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Target&quot;&gt;参照する線&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep[] GetTactilePavingAlongCurve(Curve[] Target)
        {
            double UnitSize = 302.5;
            List&lt;Brep&gt; Result = new List&lt;Brep&gt;();

            Brep TPP = GetTactilePavingPoint();
            Brep TPL = GetTactilePavingLine();

            foreach (Curve cv in Target)
            {
                double length = cv.GetLength();
                double t;
                Vector3d Normal;
                cv.Domain = new Interval(0, 1);
                if (length &lt; UnitSize * 3)
                {
                    Normal = cv.CurvatureAt(0);
                    cv.LengthParameter(length / 2.0, out t);
                    Result.Add(GetTactilePavingAlongCurveHelper1(TPP, cv, t));
                }
                Result.AddRange(GetTactilePavingAlongCurveHelper2(TPP, cv, 0, UnitSize));
                double CurrentLen = 0;
                for (CurrentLen = UnitSize; CurrentLen + UnitSize &lt; length; CurrentLen += UnitSize)
                {
                    cv.LengthParameter(CurrentLen, out t);
                    Result.Add(GetTactilePavingAlongCurveHelper1(TPL, cv, t));
                }
                cv.LengthParameter(CurrentLen, out t);
                Result.AddRange(GetTactilePavingAlongCurveHelper2(TPP, cv, t, UnitSize));
            }
            return Result.ToArray();
        }

        private static Brep GetTactilePavingAlongCurveHelper1(Brep Origin, Curve cv, double t)
        {
            return GetTactilePavingAlongCurveHelper1(Origin, cv, t, GeneralHelper.GetCurvatureAsAngle(cv, t));
        }

        private static Brep GetTactilePavingAlongCurveHelper1(Brep Origin, Curve cv, double t, double angle)
        {
            return GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t), GeneralHelper.GetCurvatureAsAngle(cv, t));
        }

        private static Brep GetTactilePavingAlongCurveHelper1(Brep Origin, Point3d point, double angle)
        {
            Brep TempTP = (Brep)Origin.Duplicate();
            angle += Math.PI / 2.0;
            TempTP.Rotate(angle, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
            TempTP.Translate((Vector3d)point);
            return TempTP;
        }

        private static Brep[] GetTactilePavingAlongCurveHelper2(Brep Origin, Curve cv, double t, double UnitSize)
        {
            double angle = GeneralHelper.GetCurvatureAsAngle(cv, t);
            Vector3d Curvature = cv.CurvatureAt(t);
            Curvature /= Curvature.Length;
            return new Brep[]{ GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t), angle)
                    ,GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t) + (Curvature * UnitSize), angle)
                    ,GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t) - (Curvature * UnitSize), angle)
                };
        }

        /*
        public static double GeneralHelper.GetCurvatureAsAngle(Curve cv, double t)
        {
            Vector3d Curvature = cv.CurvatureAt(t);
            double angle = 0;
            if (Curvature.X == 0) { angle = Math.PI / 2.0; }
            else
            {
                angle = Math.Atan(Curvature.Y / Curvature.X);
            }
            return angle;
        }
         */

        /// &lt;summary&gt;
        /// 点字ブロック(視覚障害者誘導用ブロック)の点ブロックを得ます。
        /// &lt;/summary&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetTactilePavingPoint()
        {
            return GetTactilePavingPoint(300, 5, 12, 22, 5, 60, 5);
        }

        /// &lt;summary&gt;
        /// 点字ブロック(視覚障害者誘導用ブロック)の点ブロックを得ます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BlockSize&quot;&gt;ブロックサイズ&lt;/param&gt;
        /// &lt;param name=&quot;PointCount&quot;&gt;点の数&lt;/param&gt;
        /// &lt;param name=&quot;PointSizeTop&quot;&gt;点の上部での半径&lt;/param&gt;
        /// &lt;param name=&quot;PointSizeBottom&quot;&gt;点の下部での半径&lt;/param&gt;
        /// &lt;param name=&quot;PointHeight&quot;&gt;点の高さ&lt;/param&gt;
        /// &lt;param name=&quot;PointSpace&quot;&gt;点の感覚&lt;/param&gt;
        /// &lt;param name=&quot;BlockThickness&quot;&gt;ブロックの厚さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetTactilePavingPoint(double BlockSize, int PointCount, double PointSizeTop, double PointSizeBottom, double PointHeight, double PointSpace, double BlockThickness)
        {
            Brep[] Result = new Brep[1 + PointCount * PointCount];
            Result[0] = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(0, BlockThickness)));

            Brep BasicShape = (Brep.CreateFromLoft(
              new Curve[]{
                      NurbsCurve.CreateFromCircle(new Circle(new Point3d(0, 0, BlockThickness / 2.0), PointSizeBottom))
                      ,NurbsCurve.CreateFromCircle(new Circle(new Point3d(0, 0, BlockThickness), PointSizeBottom))
                      ,NurbsCurve.CreateFromCircle(new Circle(new Point3d(0, 0, BlockThickness + PointHeight), PointSizeTop))}, new Point3d(0, 0, BlockThickness), new Point3d(0, 0, BlockThickness + PointHeight), LoftType.Straight, false))[0];
            BasicShape.CapPlanarHoles(PointSizeTop / 100.0);

            for (int i = 0; i &lt; PointCount; i++)
            {
                for (int j = 0; j &lt; PointCount; j++)
                {
                    Brep TempShape = (Brep)BasicShape.Duplicate();
                    TempShape.Translate((i - PointCount / 2.0 + 0.5) * PointSpace, (j - PointCount / 2.0 + 0.5) * PointSpace, 0);
                    Result[i * PointCount + j + 1] = TempShape;
                }
            }
            return (Brep.CreateBooleanUnion(Result, PointSizeTop / 100.0))[0];
        }

        /// &lt;summary&gt;
        /// 点字ブロック(視覚障害者誘導用ブロック)の線ブロックを得ます。
        /// &lt;/summary&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetTactilePavingLine()
        {
            return GetTactilePavingLine(300, 4, 17, 27, 270, 5, 75, 5);
        }

        /// &lt;summary&gt;
        /// 点字ブロック(視覚障害者誘導用ブロック)の線ブロックを得ます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;BlockSize&quot;&gt;ブロックサイズ&lt;/param&gt;
        /// &lt;param name=&quot;LineCount&quot;&gt;線の数&lt;/param&gt;
        /// &lt;param name=&quot;LineWidthTop&quot;&gt;線の上部での幅&lt;/param&gt;
        /// &lt;param name=&quot;LineWidthBottom&quot;&gt;線の下部での幅&lt;/param&gt;
        /// &lt;param name=&quot;LineLength&quot;&gt;線の長さ&lt;/param&gt;
        /// &lt;param name=&quot;LineHeight&quot;&gt;線の高さ&lt;/param&gt;
        /// &lt;param name=&quot;LineSpace&quot;&gt;線の間隔&lt;/param&gt;
        /// &lt;param name=&quot;BlockThickness&quot;&gt;ブロックの厚さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Brep GetTactilePavingLine(double BlockSize, int LineCount, double LineWidthTop, double LineWidthBottom, double LineLength, double LineHeight, double LineSpace, double BlockThickness)
        {
            LineLength -= LineWidthTop;

            Brep[] Result = new Brep[1 + LineCount * LineCount];
            Result[0] = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(0, BlockThickness)));

            Curve BottomCurve = Curve.JoinCurves(new Curve[]{
                    NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(-LineLength / 2.0, 0, 0), LineWidthBottom / 2.0), new Interval(Math.PI / 2.0, Math.PI / 2.0 * 3.0))),
                    NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(LineLength / 2.0, 0, 0), LineWidthBottom / 2.0), new Interval(-Math.PI / 2.0, Math.PI / 2.0))),
                    NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, LineWidthBottom / 2.0, 0), new Point3d(LineLength / 2.0, LineWidthBottom / 2.0, 0))),
                    NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, -LineWidthBottom / 2.0, 0), new Point3d(LineLength / 2.0, -LineWidthBottom / 2.0, 0)))})[0];
            Curve MiddleCurve = (Curve)BottomCurve.Duplicate();
            BottomCurve.Translate(0, 0, BlockThickness / 2.0);
            MiddleCurve.Translate(0, 0, BlockThickness);
            Curve TopCurve = Curve.JoinCurves(new Curve[]{
                    NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(-LineLength / 2.0, 0, 0), LineWidthTop / 2.0), new Interval(Math.PI / 2.0, Math.PI / 2.0 * 3.0))),
                    NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(LineLength / 2.0, 0, 0), LineWidthTop / 2.0), new Interval(-Math.PI / 2.0, Math.PI / 2.0))),
                    NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, LineWidthTop / 2.0, 0), new Point3d(LineLength / 2.0, LineWidthTop / 2.0, 0))),
                    NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, -LineWidthTop / 2.0, 0), new Point3d(LineLength / 2.0, -LineWidthTop / 2.0, 0)))})[0];
            TopCurve.Translate(0, 0, BlockThickness + LineHeight);


            Brep BasicShape = (Brep.CreateFromLoft(
              new Curve[] { BottomCurve, MiddleCurve, TopCurve }, new Point3d(0, 0, BlockThickness), new Point3d(0, 0, BlockThickness + LineHeight), LoftType.Straight, false))[0];
            BasicShape.CapPlanarHoles(LineWidthTop / 100.0);

            for (int i = 0; i &lt; LineCount; i++)
            {
                Brep TempShape = (Brep)BasicShape.Duplicate();
                TempShape.Translate(0, (i - LineCount / 2.0 + 0.5) * LineSpace, 0);
                Result[i + 1] = TempShape;
            }
            return (Brep.CreateBooleanUnion(Result, LineWidthTop / 100.0))[0];
        }

        /// &lt;summary&gt;
        /// 線に太さを与えます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;元の線&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;太さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] TrimOutline(Curve[] Origin, double[] Width)
        {
            Curve[] OutlineCurve = new Curve[Origin.GetLength(0)];
            List&lt;List&lt;Curve&gt;&gt; Result = new List&lt;List&lt;Curve&gt;&gt;();
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                OutlineCurve[i] = GetCurveWithWidth(Origin[i], Width[Math.Min(i, Width.GetLength(0) - 1)]);
                Result.Add(new List&lt;Curve&gt;());
                //Result[i].Add((Curve) OutlineCurve[i].Duplicate());
                Result[i].Add((Curve)Origin[i].Duplicate());
            }
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                for (int j = 0; j &lt; Result.Count(); j++)
                {
                    if (i == j) { continue; }
                    for (int k = 0; k &lt; Result[j].Count(); k++)
                    {
                        Curve[] TempRet = TrimCurveByOutline(Result[j][k], OutlineCurve[i]);
                        if (TempRet.GetLength(0) &gt; 1)
                        {
                            Result[j].Remove(Result[j][k]);
                            Result[j].AddRange(TempRet);
                            k--;
                        }
                    }
                }
            }
            List&lt;Curve&gt; TotalResult = new List&lt;Curve&gt;();
            for (int j = 0; j &lt; Result.Count(); j++)
            {
                TotalResult.AddRange(Result[j]);
            }
            return TotalResult.ToArray();
        }

        /// &lt;summary&gt;
        /// 線を線で切断します。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;元の線&lt;/param&gt;
        /// &lt;param name=&quot;Cutter&quot;&gt;切断する線&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] TrimCurveByOutline(Curve Origin, Curve Cutter)
        {
            Origin.Domain = new Interval(0, 1);
            Cutter.Domain = new Interval(0, 1);
            Rhino.Geometry.Intersect.CurveIntersections CurveIntersectRet = Rhino.Geometry.Intersect.Intersection.CurveCurve(Origin, Cutter, 1.0, 1.0);
            double[] SumLength = new double[] { 0.0, 0.0 };
            int cnt = 0;
            double LastPara = 0.0;
            for (int i = 0; i &lt; CurveIntersectRet.Count(); i++)
            {
                if (CurveIntersectRet[i].ParameterA % 1.0 == 0.0) continue;
                if (CurveIntersectRet[i].IsOverlap) continue;
                SumLength[cnt % 2] += CurveIntersectRet[i].ParameterA - LastPara;
                LastPara = CurveIntersectRet[i].ParameterA;
                cnt++;
            }
            int Choice = SumLength[0] &lt; SumLength[1] ? 1 : 0;
            List&lt;Curve&gt; Result = new List&lt;Curve&gt;();
            cnt = 0;
            LastPara = 0.0;
            for (int i = 0; i &lt; CurveIntersectRet.Count(); i++)
            {
                if (CurveIntersectRet[i].ParameterA % 1.0 == 0.0) continue;
                if (CurveIntersectRet[i].IsOverlap) continue;
                if (cnt % 2 == Choice)
                {
                    if (LastPara == 0)
                    {
                        Result.Add((Origin.Split(CurveIntersectRet[i].ParameterA))[0]);
                    }
                    else
                    {
                        Result.Add((Origin.Split(new double[] { LastPara, CurveIntersectRet[i].ParameterA }))[1]);
                    }
                }
                LastPara = CurveIntersectRet[i].ParameterA;
                cnt++;
            }
            if (cnt % 2 == Choice)
            {
                if (LastPara == 0)
                {
                    Result.Add((Curve)Origin.Duplicate());
                }
                else
                {
                    Result.Add((Origin.Split(LastPara))[1]);
                }
            }
            return Result.ToArray();
        }

        public static Curve[] GetOutlineSimple(Curve[] Origin, double Width)
        {
            Curve[] OutlineCurveBase = new Curve[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                OutlineCurveBase[i] = GetCurveWithWidth(Origin[i], Width);
            }
            return Curve.CreateBooleanUnion(OutlineCurveBase);
        }

        /// &lt;summary&gt;
        /// 複数の線に太さを与えます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;線&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;太さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] GetOutlineSimple(Curve[] Origin, double[] Width)
        {
            Curve[] OutlineCurveBase = new Curve[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                OutlineCurveBase[i] = GetCurveWithWidth(Origin[i], Width[Math.Min(i, Width.GetLength(0) - 1)]);
            }
            return Curve.CreateBooleanUnion(OutlineCurveBase);
        }

        /// &lt;summary&gt;
        /// 線に太さを与えます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;線&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;太さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] GetCurveWithWidth(Curve[] Origin, double Width)
        {
            Curve[] Result = new Curve[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                Result[i] = GetCurveWithWidth(Origin[i], Width);
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// 線に太さを与えます。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;線&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;太さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve GetCurveWithWidth(Curve Origin, double Width)
        {
            Width /= 2;
            Curve cv1 = (Origin.Offset(Plane.WorldXY, Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];
            Curve cv2 = (Origin.Offset(Plane.WorldXY, -Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];

            return (Curve.JoinCurves(new Curve[] { cv1, cv2, NurbsCurve.CreateFromLine(new Line(cv1.PointAtEnd, cv2.PointAtEnd)), NurbsCurve.CreateFromLine(new Line(cv1.PointAtStart, cv2.PointAtStart)) }))[0];
        }

        /// &lt;summary&gt;
        /// 線に太さを与えます。端は丸くします。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;線&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;太さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] GetCurveWithWidthRound(Curve[] Origin, double Width)
        {
            Curve[] Result = new Curve[Origin.GetLength(0)];
            for (int i = 0; i &lt; Origin.GetLength(0); i++)
            {
                Result[i] = GetCurveWithWidthRound(Origin[i], Width);
            }
            return Result;
        }

        /// &lt;summary&gt;
        /// 線に太さを与えます。端は丸くします。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;線&lt;/param&gt;
        /// &lt;param name=&quot;Width&quot;&gt;太さ&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve GetCurveWithWidthRound(Curve Origin, double Width)
        {
            Width /= 2;
            Curve cv1 = (Origin.Offset(Plane.WorldXY, Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];
            Curve cv2 = (Origin.Offset(Plane.WorldXY, -Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];
            cv1.Domain = new Interval(0, 1);
            cv2.Domain = new Interval(0, 1);

            return (Curve.JoinCurves(new Curve[] { cv1, cv2, NurbsCurve.CreateFromArc(new Arc(cv1.PointAtEnd, cv1.TangentAt(1.0), cv2.PointAtEnd)), NurbsCurve.CreateFromArc(new Arc(cv1.PointAtStart, cv1.TangentAt(0.0), cv2.PointAtStart)) }))[0];
        }

        /// &lt;summary&gt;
        /// 線を点線にします。
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Origin&quot;&gt;線&lt;/param&gt;
        /// &lt;param name=&quot;SegmentLength&quot;&gt;点線の間隔&lt;/param&gt;
        /// &lt;returns&gt;結果&lt;/returns&gt;
        public static Curve[] GetDashedLine(Curve Origin, double SegmentLength)
        {
            int Count = (int)Math.Floor(Origin.GetLength() / SegmentLength / 2.0);
            Curve[] result = new Curve[Count + 1];

            for (int i = 0; i &lt;= Count; i++)
            {
                Curve TempCurve = (Curve)Origin.Duplicate();
                Point3d a = TempCurve.PointAtLength(i * SegmentLength * 2.0);
                Point3d b = TempCurve.PointAtLength(i * SegmentLength * 2.0 + SegmentLength);
                double at, bt;
                TempCurve.ClosestPoint(a, out at);
                TempCurve.ClosestPoint(b, out bt);
                TempCurve = (TempCurve.Split(new double[] { at, bt }))[i == 0 ? 0 : 1];
                result[i] = TempCurve;
            }
            return result;
        }
    }
#endregion

#region ..\RealObject.cs

    /// &lt;summary&gt;
    /// 3Dモデルを示します。レイヤー付きで出力できます。
    /// &lt;/summary&gt;
    public class RealObject
    {
        /// &lt;summary&gt;
        /// 素材を示します。識別以上の意味はありません。
        /// &lt;/summary&gt;
        public class Material
        {
            /// &lt;summary&gt;
            /// 素材名
            /// &lt;/summary&gt;
            public String[] Name { get; private set; }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;素材名&lt;/param&gt;
            public Material(string name)
            {
                Name = name.Split(&apos;.&apos;);
            }

            public override string ToString()
            {
                return String.Join(&quot;.&quot;, Name);
            }
        }

        /// &lt;summary&gt;
        /// 色を示します。
        /// &lt;/summary&gt;
        public class Color
        {
            /// &lt;summary&gt;
            /// 色の名前を示します。
            /// &lt;/summary&gt;
            public string Name = &quot;&quot;;

            /// &lt;summary&gt;
            /// ランダムであるかを示します。
            /// &lt;/summary&gt;
            public bool IsRandom { get; set; }
            /// &lt;summary&gt;
            /// 未設定であるかを示します。
            /// &lt;/summary&gt;
            public bool IsUndefined { get { return !IsRandom &amp;&amp; _IsUndefined; } }
            private bool _IsUndefined;

            private double[] _ARGBValue;
            /// &lt;summary&gt;
            /// 色の透明度を示します。
            /// &lt;/summary&gt;
            public double Alpha { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[0]; } } }
            /// &lt;summary&gt;
            /// 色の赤成分を示します。
            /// &lt;/summary&gt;
            public double Red { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[1]; } } }
            /// &lt;summary&gt;
            /// 色の緑成分を示します。
            /// &lt;/summary&gt;
            public double Green { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[2]; } } }
            /// &lt;summary&gt;
            /// 色の青成分を示します。
            /// &lt;/summary&gt;
            public double Blue { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[3]; } } }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            public Color()
            {
                _IsUndefined = true;
                _ARGBValue = new double[] { 0.0, 0.0, 0.0, 0.0 };
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;色名&lt;/param&gt;
            public Color(string name) : this() { this.Name = name; }

            /// &lt;summary&gt;
            /// 色を設定します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;A&quot;&gt;アルファ&lt;/param&gt;
            /// &lt;param name=&quot;R&quot;&gt;赤&lt;/param&gt;
            /// &lt;param name=&quot;G&quot;&gt;緑&lt;/param&gt;
            /// &lt;param name=&quot;B&quot;&gt;青&lt;/param&gt;
            public void SetARGB(double A, double R, double G, double B)
            {
                _IsUndefined = false;
                IsRandom = true;
                if (Math.Max(Math.Max(A, R), Math.Max(G, B)) &gt; 1.0)
                {
                    A /= 255.0; R /= 255.0; G /= 255.0; B /= 255.0;
                }
                _ARGBValue[0] = A;
                _ARGBValue[1] = R;
                _ARGBValue[2] = G;
                _ARGBValue[3] = B;
            }

            /// &lt;summary&gt;
            /// 色を設定します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;R&quot;&gt;赤&lt;/param&gt;
            /// &lt;param name=&quot;G&quot;&gt;緑&lt;/param&gt;
            /// &lt;param name=&quot;B&quot;&gt;青&lt;/param&gt;
            public void SetRGB(double R, double G, double B)
            {
                SetARGB(1.0, R, G, B);
                _ARGBValue[0] = 1.0;
            }

            /// &lt;summary&gt;
            /// ランダムに色を設定します。
            /// &lt;/summary&gt;
            public void SetRandomColor()
            {
                _IsUndefined = false;
                IsRandom = true;
                _ARGBValue[0] = rd.NextDouble();
                _ARGBValue[1] = rd.NextDouble();
                _ARGBValue[2] = rd.NextDouble();
                _ARGBValue[3] = rd.NextDouble();
            }

            private Random rd = new Random();

            public static explicit operator System.Drawing.Color(Color cl)
            {
                return System.Drawing.Color.FromArgb((int)(cl.Alpha * 256), (int)(cl.Red * 256), (int)(cl.Green * 256), (int)(cl.Blue * 256));
            }
            public static implicit operator Color(System.Drawing.Color cl)
            {
                Color ret = new Color();
                ret.SetARGB(cl.A / 255.0, cl.R / 255.0, cl.G / 255.0, cl.B / 255.0);
                if (cl.IsKnownColor) { ret.Name = cl.ToKnownColor().ToString(); }
                return ret;
            }

        }

        /// &lt;summary&gt;
        /// 部材(建築の要素)を示します。
        /// &lt;/summary&gt;
        public class Member
        {
            /// &lt;summary&gt;
            /// 部材名
            /// &lt;/summary&gt;
            public String[] Name { get; private set; }
            /// &lt;summary&gt;
            /// Brepを示します。
            /// &lt;/summary&gt;
            public Brep[] Content = new Brep[0];
            /// &lt;summary&gt;
            /// 部材の色。
            /// &lt;/summary&gt;
            public Color Color = new Color();
            /// &lt;summary&gt;
            /// 部材のマテリアル
            /// &lt;/summary&gt;
            public Material Material = new Material(&quot;Undefined&quot;);
            /// &lt;summary&gt;
            /// 詳細レベル。RODを用いる場合を想定しています。
            /// 現時点で余り利用されていません。
            /// &lt;/summary&gt;
            public double DeatailLevel;

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;名前&lt;/param&gt;
            public Member(string name)
            {
                SetName(name);
            }

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;名前&lt;/param&gt;
            /// &lt;param name=&quot;content&quot;&gt;Brep(3Dモデル)&lt;/param&gt;
            public Member(string name, params Brep[] content) : this(name)
            {
                this.Content = content;
            }

            /// &lt;summary&gt;
            /// 名前を設定します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;名前&lt;/param&gt;
            public void SetName(string name)
            {
                Name = name.Split(&apos;.&apos;);
            }

            public static implicit operator Brep[] (Member origin)
            {
                return origin.Content;
            }

            public static implicit operator Member(Brep[] origin)
            {
                return new Member(&quot;BrepMember&quot;, origin);
            }

            public override string ToString()
            {
                return String.Join(&quot;.&quot;, Name);
            }

            /// &lt;summary&gt;
            /// 複製します。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;複製結果&lt;/returns&gt;
            public Member Duplicate()
            {
                return new Member(this.ToString(), GeneralHelper.DuplicateBreps(this.Content)) { Color = this.Color, Material = this.Material, DeatailLevel = this.DeatailLevel };
            }

            /// &lt;summary&gt;
            /// Transformを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Tf&quot;&gt;Transform&lt;/param&gt;
            public void Transform(Transform tf)
            {
                if (Content == null) { return; }
                foreach (Brep bp in Content)
                {
                    bp.Transform(tf);
                }
            }

            /// &lt;summary&gt;
            /// Bake(Rhino Documentに出力)します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;doc&quot;&gt;出力先&lt;/param&gt;
            /// &lt;param name=&quot;LayerName&quot;&gt;レイヤー名&lt;/param&gt;
            public void Bake(RhinoDoc doc, string LayerName)
            {
                if (Content == null) { return; }
                int layerIndex = doc.Layers.Add(LayerName, System.Drawing.Color.Black);
                if (doc.Layers.FindByFullPath(LayerName, true) &gt;= 0) { layerIndex = doc.Layers.FindByFullPath(LayerName, true); }
                int GroupIndex = doc.Groups.Add(this.ToString() + Guid.NewGuid().ToString());
                foreach (Brep bp in Content)
                {
                    ObjectAttributes oba = new ObjectAttributes();
                    oba.LayerIndex = layerIndex;

                    oba.ColorSource = this.Color.IsUndefined ? ObjectColorSource.ColorFromLayer : ObjectColorSource.ColorFromObject;
                    oba.ObjectColor = (System.Drawing.Color)this.Color;
                    oba.AddToGroup(GroupIndex);
                    doc.Objects.AddBrep(bp, oba);
                }
            }
        }

        /// &lt;summary&gt;
        /// 建築全体を示します。レイヤー名付きで出力可能です。
        /// &lt;/summary&gt;
        public class Building
        {
            /// &lt;summary&gt;
            /// 名前
            /// &lt;/summary&gt;
            public String[] Name { get; private set; }
            /// &lt;summary&gt;
            /// 建築に含まれる要素を示します。
            /// &lt;/summary&gt;
            public List&lt;Member&gt; Content;

            /// &lt;summary&gt;
            /// コンストラクタ
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;名前&lt;/param&gt;
            public Building(string name)
            {
                Name = name.Split(&apos;.&apos;);
                Content = new List&lt;Member&gt;();
            }

            public override string ToString()
            {
                return String.Join(&quot;.&quot;, Name);
            }
            /// &lt;summary&gt;
            /// Bake(Rhino Documentに出力)します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rd&quot;&gt;ランダムインスタンス&lt;/param&gt;
            public void Bake(RhinoDoc rd)
            {
                foreach (Member mb in Content)
                {
                    mb.Bake(rd, this.ToString() + &quot;:&quot; + mb.ToString());
                }
            }

            /// &lt;summary&gt;
            /// 部材をつかします。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;追加部材&lt;/param&gt;
            public void Add(params Member[] item)
            {
                Content.AddRange(item);
            }

            /// &lt;summary&gt;
            /// 3Dモデル(Brep)から部材(Member)を作ります。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;部材名&lt;/param&gt;
            /// &lt;param name=&quot;brep&quot;&gt;Brep&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public Member Add(string name, params Brep[] brep)
            {
                Member result = new Member(name, brep);
                this.Add(result);
                return result;
            }

            /// &lt;summary&gt;
            /// Transformを適用します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Tf&quot;&gt;Transform&lt;/param&gt;
            public void Transform(Transform tf)
            {
                foreach (Member m in Content)
                {
                    m.Transform(tf);
                }
            }

            /// &lt;summary&gt;
            /// 他の建築と結合します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;item&quot;&gt;追加する建築&lt;/param&gt;
            public void Add(params Building[] item)
            {
                foreach (Building bd in item)
                {
                    foreach (Member mb in bd.Content)
                    {
                        mb.SetName(bd.ToString() + &quot;.&quot; + mb.ToString());
                        Content.Add(mb);
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// 最低限の補助関数を含みます。
        /// &lt;/summary&gt;
        public static class Helper
        {
            /// &lt;summary&gt;
            /// ランダムな色を取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;rd&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static System.Drawing.Color GetRandomColor(Random rd)
            {
                return System.Drawing.Color.FromArgb(rd.Next(256), rd.Next(256), rd.Next(256));
            }

            /// &lt;summary&gt;
            /// Bake(Rhino Documentに出力)します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;Content&quot;&gt;出力するBrep&lt;/param&gt;
            /// &lt;param name=&quot;doc&quot;&gt;出力先のドキュメント&lt;/param&gt;
            /// &lt;param name=&quot;LayerName&quot;&gt;出力レイヤー名&lt;/param&gt;
            /// &lt;param name=&quot;color&quot;&gt;出力時の色&lt;/param&gt;
            public static void Bake(Brep[] Content, RhinoDoc doc, string LayerName, System.Drawing.Color color)
            {
                int LayerIndex = doc.Layers.Add(LayerName, color);
                foreach (Brep bp in Content)
                {
                    ObjectAttributes oba = new ObjectAttributes();
                    oba.LayerIndex = LayerIndex;
                    doc.Objects.AddBrep(bp, oba);
                }
            }
        }
    }
#endregion

#region ..\Expression.cs

    /// &lt;summary&gt;
    /// 数式表現に関係する機能を含みます。
    /// &lt;/summary&gt;
    public class Expression
    {
        /// &lt;summary&gt;
        /// 数式を意味します。
        /// &lt;/summary&gt;
        public interface ICommand
        {
            /// &lt;summary&gt;
            /// 引数の数を返します。
            /// &lt;/summary&gt;
            int ArgumentCount { get; }
            /// &lt;summary&gt;
            /// 数式を実行します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;arg&quot;&gt;引数&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            double Execute(params double[] arg);
            /// &lt;summary&gt;
            /// 数式をコピーします。
            /// &lt;/summary&gt;
            /// &lt;returns&gt;配列&lt;/returns&gt;
            ICommand Duplicate();
        }

        /// &lt;summary&gt;
        /// 汎用的な数式を示します。
        /// &lt;/summary&gt;
        public class CommandGeneral : ICommand
        {
            /// &lt;summary&gt;
            /// 関数の内容。
            /// &lt;/summary&gt;
            public Func&lt;double[], double&gt; Content { get; private set; }

            /// &lt;summary&gt;
            /// 
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;arg&quot;&gt;&lt;/param&gt;
            /// &lt;param name=&quot;argCount&quot;&gt;&lt;/param&gt;
            public CommandGeneral(Func&lt;double[], double&gt; arg, int argCount)
            {
                this.Content = arg;
                this.ArgumentCount = argCount;
            }

            public int ArgumentCount { get; private set; }

            public double Execute(params double[] arg)
            {
                return Content(arg);
            }

            public ICommand Duplicate()
            {
                return new CommandGeneral(Content, ArgumentCount);
            }
        }

        /// &lt;summary&gt;
        /// 基本的なコマンドを含みます。
        /// &lt;/summary&gt;
        public class Commands
        {
            /// &lt;summary&gt;
            /// 基本的な数式関数を含みます。
            /// &lt;/summary&gt;
            public class Mathematics
            {
                /// &lt;summary&gt;
                /// 加算を示します。
                /// &lt;/summary&gt;
                public class Add : ICommand
                {
                    public int ArgumentCount { get { return 2; } }

                    public ICommand Duplicate()
                    {
                        return new Add();
                    }

                    public double Execute(params double[] arg)
                    {
                        double result = 0;
                        foreach (var item in arg)
                        {
                            result += item;
                        }
                        return result;
                    }
                }

                /// &lt;summary&gt;
                /// 減算を示します。
                /// &lt;/summary&gt;
                public class Subtract : ICommand
                {
                    public int ArgumentCount { get { return 2; } }

                    public ICommand Duplicate()
                    {
                        return new Subtract();
                    }

                    public double Execute(params double[] arg)
                    {
                        return arg[0] - arg[1];

                    }
                }

                /// &lt;summary&gt;
                /// 乗算を示します。
                /// &lt;/summary&gt;
                public class Multiply : ICommand
                {
                    public int ArgumentCount { get { return 2; } }

                    public ICommand Duplicate()
                    {
                        return new Multiply();
                    }

                    public double Execute(params double[] arg)
                    {
                        double result = 1;
                        foreach (var item in arg)
                        {
                            result *= item;
                        }
                        return result;
                    }
                }

                /// &lt;summary&gt;
                /// 除算を示します。
                /// &lt;/summary&gt;
                public class Divide : ICommand
                {
                    public int ArgumentCount { get { return 2; } }

                    public ICommand Duplicate()
                    {
                        return new Divide();
                    }

                    public double Execute(params double[] arg) { return arg[0] / arg[1]; }
                }

                /// &lt;summary&gt;
                /// 値の符号を変換します。
                /// &lt;/summary&gt;
                public class Minus : ICommand
                {
                    public int ArgumentCount { get { return 1; } }

                    public ICommand Duplicate()
                    {
                        return new Minus();
                    }

                    public double Execute(params double[] arg) { return -arg[0]; }
                }
                /// &lt;summary&gt;
                /// Sin関数を示します。
                /// &lt;/summary&gt;
                public class Sin : ICommand
                {
                    public int ArgumentCount { get { return 1; } }

                    public ICommand Duplicate()
                    {
                        return new Sin();
                    }

                    public double Execute(params double[] arg) { return Math.Sin(arg[0]); }
                }
                /// &lt;summary&gt;
                /// Cos関数を示します。
                /// &lt;/summary&gt;
                public class Cos : ICommand
                {
                    public int ArgumentCount { get { return 1; } }

                    public ICommand Duplicate()
                    {
                        return new Cos();
                    }

                    public double Execute(params double[] arg) { return Math.Cos(arg[0]); }
                }
                /// &lt;summary&gt;
                /// Tan関数を示します。
                /// &lt;/summary&gt;
                public class Tan : ICommand
                {
                    public int ArgumentCount { get { return 1; } }

                    public ICommand Duplicate()
                    {
                        return new Tan();
                    }

                    public double Execute(params double[] arg) { return Math.Tan(arg[0]); }
                }
                /// &lt;summary&gt;
                /// 乗算を示します。
                /// &lt;/summary&gt;
                public class Power : ICommand
                {
                    public int ArgumentCount { get { return 2; } }

                    public ICommand Duplicate()
                    {
                        return new Power();
                    }

                    public double Execute(params double[] arg) { return Math.Pow(arg[0], arg[1]); }
                }

            }

            /// &lt;summary&gt;
            /// 関数を組み合わせます。
            /// 関数の実行結果を引数とし、それに対して関数を適用します。
            /// &lt;/summary&gt;
            public class Combined : ICommand
            {
                /// &lt;summary&gt;
                /// 主となる関数。引数に対してこの関数を実行します。
                /// &lt;/summary&gt;
                public ICommand MainCommand { get; private set; }
                /// &lt;summary&gt;
                /// 引数となる関数。
                /// &lt;/summary&gt;
                public ICommand[] Arguments { get; private set; }

                public Combined(ICommand Main, params ICommand[] Args)
                {
                    if (Args.Count() != Main.ArgumentCount)
                    {
                        throw new Exception(&quot;Argument count does not match.&quot;);
                    }
                    this.MainCommand = Main;
                    this.Arguments = Args;
                }


                public int ArgumentCount
                {
                    get
                    {
                        int result = 0;
                        foreach (var item in Arguments)
                        {
                            result += item.ArgumentCount;
                        }
                        return result;
                    }
                }

                public double Execute(params double[] arg)
                {
                    int currentArgCount = 0;
                    double[] argumentsResult = new double[Arguments.Count()];
                    for (int i = 0; i &lt; Arguments.Count(); i++)
                    {
                        int argCnt = Arguments[i].ArgumentCount;
                        double[] tempArg = new double[argCnt];
                        Array.Copy(arg, currentArgCount, tempArg, 0, argCnt);
                        argumentsResult[i] = Arguments[i].Execute(tempArg);

                        currentArgCount += argCnt;
                    }
                    return MainCommand.Execute(argumentsResult);
                }

                public ICommand Duplicate()
                {
                    var args = new ICommand[Arguments.Count()];
                    for (int i = 0; i &lt; Arguments.Count(); i++)
                    {
                        args[i] = Arguments[i].Duplicate();
                    }
                    return new Combined(this.MainCommand.Duplicate(), args);
                }
            }

            /// &lt;summary&gt;
            /// 引数をそのまま結果として返します。
            /// &lt;/summary&gt;
            public class Argument : ICommand
            {
                public int ArgumentCount
                {
                    get { return 1; }
                }

                public ICommand Duplicate()
                {
                    return new Argument();
                }

                public double Execute(params double[] arg)
                {
                    return arg[0];
                }
            }

            /// &lt;summary&gt;
            /// 設定された数値をそのまま返します(即値)。
            /// &lt;/summary&gt;
            public class ImmediateValue : ICommand
            {
                public double Value { get; set; }

                public int ArgumentCount
                {
                    get { return 0; }
                }

                public ImmediateValue(double Value)
                {
                    this.Value = Value;
                }

                public double Execute(params double[] arg)
                {
                    return Value;
                }

                public ICommand Duplicate()
                {
                    return new ImmediateValue(this.Value);
                }
            }
        }

        /// &lt;summary&gt;
        /// 数式の操作に関する機能を含みます。
        /// &lt;/summary&gt;
        public static class Operation
        {
            /// &lt;summary&gt;
            /// 引数が合わない場合にも数式を計算します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;cmd&quot;&gt;数式&lt;/param&gt;
            /// &lt;param name=&quot;args&quot;&gt;引数&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public static double ExecuteCommandWithUnmatchedArgs(ICommand cmd, params double[] args)
            {
                var cnt = cmd.ArgumentCount;
                if (cnt == args.Count()) { return cmd.Execute(args); }
                if (cnt &lt; args.Count())
                {
                    double[] newArg = new double[cnt];
                    Array.Copy(args, newArg, cnt);
                    return cmd.Execute(newArg);
                }
                var targ = new double[cnt];
                for (int i = args.Count(); i &lt; cnt; i++)
                {
                    targ[i] = args[i % args.Count()];
                }
                return cmd.Execute(targ);
            }

            /// &lt;summary&gt;
            /// 関数をLisp風に表示します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;command&quot;&gt;&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static String GetLispLikeText(ICommand command)
            {
                if (command is Commands.Combined)
                {
                    var cm = (Commands.Combined)command;
                    string result = &quot;(&quot; + cm.MainCommand.GetType().Name;
                    foreach (var item in cm.Arguments)
                    {
                        result += &quot; &quot; + GetLispLikeText(item);
                    }
                    return result + &quot;)&quot;;
                }
                else if (command is Commands.ImmediateValue)
                {
                    var cm = (Commands.ImmediateValue)command;
                    return cm.Value.ToString();
                }
                else if (command is Commands.Argument)
                {
                    return &quot;*&quot;;
                }
                else
                {
                    var temporary = &quot;&quot;;
                    for (int i = 0; i &lt; command.ArgumentCount; i++)
                    {
                        temporary += &quot; *&quot;;
                    }
                    return &quot;(&quot; + command.GetType().Name + temporary.ToString() + &quot;)&quot;;
                }
            }

            /// &lt;summary&gt;
            /// 数式にいくつ基本的な関数が含まれるか数えます。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;command&quot;&gt;数式&lt;/param&gt;
            /// &lt;param name=&quot;CountImmediateValue&quot;&gt;即値を数えるか&lt;/param&gt;
            /// &lt;param name=&quot;CountArgument&quot;&gt;引数を数えるか&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public static int CountContainingCommand(ICommand command, bool CountImmediateValue = true, bool CountArgument = true)
            {
                if (command is Commands.Combined)
                {
                    var commandComb = (Commands.Combined)command;
                    int result = 1;
                    for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
                    {
                        result += CountContainingCommand(commandComb.Arguments[i]);
                    }
                    return result;
                }
                else if (command is Commands.ImmediateValue)
                {
                    return CountImmediateValue ? 1 : 0;
                }
                else if (command is Commands.Argument)
                {
                    return CountArgument ? 1 : 0;
                }
                else
                {
                    return 1;
                }
            }

            /// &lt;summary&gt;
            /// 数式に含まれる引数を数えます。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;command&quot;&gt;数式&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public static int CountContainingArgument(ICommand command)
            {
                if (command is Commands.Combined)
                {
                    int result = 0;
                    var commandComb = (Commands.Combined)command;
                    for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
                    {
                        result += (CountContainingArgument(commandComb.Arguments[i]));
                    }
                    return result;
                }
                else if (command is Commands.Argument)
                {
                    return 1;
                }
                else
                {
                    return command.ArgumentCount;
                }
            }

            /// &lt;summary&gt;
            /// 数式に含まれる定数の個数を含みます。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;command&quot;&gt;数式&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public static int CountContainingImmediateValue(ICommand command)
            {
                return GetFixedNumbers(command).Count();
            }

            /// &lt;summary&gt;
            /// 数式に含まれる定数を全て取得します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;command&quot;&gt;数式&lt;/param&gt;
            /// &lt;returns&gt;結果&lt;/returns&gt;
            public static double[] GetFixedNumbers(ICommand command)
            {
                if (command is Commands.Combined)
                {
                    List&lt;double&gt; result = new List&lt;double&gt;();
                    var commandComb = (Commands.Combined)command;
                    for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
                    {
                        result.AddRange(GetFixedNumbers(commandComb.Arguments[i]));
                    }
                    return result.ToArray();
                }
                else if (command is Commands.ImmediateValue)
                {
                    return new double[] { (command as Commands.ImmediateValue).Value };
                }
                else
                {
                    return new double[0];
                }
            }

            /// &lt;summary&gt;
            /// 数式に含まれる定数を変更します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;arg&quot;&gt;数式&lt;/param&gt;
            /// &lt;param name=&quot;numbers&quot;&gt;設定値&lt;/param&gt;
            /// &lt;returns&gt;変更結果&lt;/returns&gt;
            public static ICommand SetFixedNumbers(ICommand arg, params double[] numbers)
            {
                int temp = 0;
                return SetFixedNumbers(arg, ref temp, numbers);
            }

            /// &lt;summary&gt;
            /// 数式に含まれる定数を変更します。(再帰用)
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;arg&quot;&gt;数式&lt;/param&gt;
            /// &lt;param name=&quot;offset&quot;&gt;開始番号&lt;/param&gt;
            /// &lt;param name=&quot;numbers&quot;&gt;設定値&lt;/param&gt;
            /// &lt;returns&gt;変更結果&lt;/returns&gt;
            public static ICommand SetFixedNumbers(ICommand arg, ref int offset, params double[] numbers)
            {
                var command = arg.Duplicate();
                if (command is Commands.Combined)
                {
                    List&lt;double&gt; result = new List&lt;double&gt;();
                    var commandComb = (Commands.Combined)command;
                    for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
                    {
                        commandComb.Arguments[i] = SetFixedNumbers(commandComb.Arguments[i], ref offset, numbers);
                    }
                    return command;
                }
                else if (command is Commands.ImmediateValue)
                {
                    if (offset &lt; numbers.Count())
                    {
                        (command as Commands.ImmediateValue).Value = numbers[offset];
                        offset++;
                    }
                    else
                    {
                    }
                    return command;
                }
                else
                {
                    return command;
                }
            }

            /// &lt;summary&gt;
            /// 数式に含まれる関数を置換します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;arg&quot;&gt;数式&lt;/param&gt;
            /// &lt;param name=&quot;target&quot;&gt;交換される関数の番号&lt;/param&gt;
            /// &lt;param name=&quot;newCommand&quot;&gt;交換後の関数&lt;/param&gt;
            /// &lt;param name=&quot;CountImmediateValue&quot;&gt;即値を含めて数えるか&lt;/param&gt;
            /// &lt;param name=&quot;CountArgument&quot;&gt;引数を含めて数えるか&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static ICommand SwapCommand(ICommand arg, int target, ICommand newCommand, bool CountImmediateValue = true, bool CountArgument = true)
            {
                var command = arg.Duplicate();

                if (target &lt; 0) { return command; }
                if (command is Commands.Combined)
                {
                    if (target == 0)
                    {
                        return newCommand;
                    }
                    var commandComb = (Commands.Combined)command;
                    for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
                    {
                        var count = CountContainingCommand(commandComb.Arguments[i], CountImmediateValue, CountArgument);
                        if (target &lt; count)
                        {
                            commandComb.Arguments[i] = SwapCommand(commandComb.Arguments[i], target, newCommand, CountImmediateValue, CountArgument);
                        }
                        target -= count;
                    }
                    return command;
                }
                else if (command is Commands.ImmediateValue)
                {
                    if (CountImmediateValue &amp;&amp; target == 0)
                    {
                        return newCommand;
                    }
                    return command;
                }
                else if (command is Commands.Argument)
                {
                    if (CountArgument &amp;&amp; target == 0)
                    {
                        return newCommand;
                    }
                    return command;
                }
                else
                {
                    if (target == 0)
                    {
                        return newCommand;
                    }
                    return command;
                }
            }

            /// &lt;summary&gt;
            /// 数式に含まれる関数をランダムに置換します。
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;arg&quot;&gt;数式&lt;/param&gt;
            /// &lt;param name=&quot;newCommand&quot;&gt;交換後の関数&lt;/param&gt;
            /// &lt;param name=&quot;rd&quot;&gt;乱数のインスタンス&lt;/param&gt;
            /// &lt;param name=&quot;CountImmediateValue&quot;&gt;即値を含めて数えるか&lt;/param&gt;
            /// &lt;param name=&quot;CountArgument&quot;&gt;引数を含めて数えるか&lt;/param&gt;
            /// &lt;returns&gt;&lt;/returns&gt;
            public static ICommand SwapCommandRandom(ICommand arg, ICommand newCommand, Random rd, bool CountImmediateValue = true, bool CountArgument = true)
            {
                var count = CountContainingCommand(arg, CountImmediateValue, CountArgument);
                return SwapCommand(arg, rd.Next(count), newCommand, CountImmediateValue, CountArgument);
            }
        }
    }
#endregion

</item>
                    <item name="Description" type_name="gh_string" type_code="10">A C#.NET scriptable component</item>
                    <item name="EditorPosition" type_name="gh_drawing_point" type_code="30">
                      <X>3</X>
                      <Y>75</Y>
                    </item>
                    <item name="InstanceGuid" type_name="gh_guid" type_code="9">71d86f42-d665-448a-a24d-324dd3f9dee0</item>
                    <item name="Name" type_name="gh_string" type_code="10">C# Script</item>
                    <item name="NickName" type_name="gh_string" type_code="10">C#</item>
                    <item name="OutParameter" type_name="gh_bool" type_code="1">true</item>
                    <item name="ReferenceCount" type_name="gh_int32" type_code="3">0</item>
                    <item name="ScriptSource" type_name="gh_string" type_code="10"></item>
                  </items>
                  <chunks count="2">
                    <chunk name="Attributes">
                      <items count="3">
                        <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                          <X>37</X>
                          <Y>26</Y>
                          <W>75</W>
                          <H>44</H>
                        </item>
                        <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                          <X>67</X>
                          <Y>48</Y>
                        </item>
                        <item name="Selected" type_name="gh_bool" type_code="1">true</item>
                      </items>
                    </chunk>
                    <chunk name="ParameterData">
                      <items count="6">
                        <item name="InputCount" type_name="gh_int32" type_code="3">2</item>
                        <item name="InputId" index="0" type_name="gh_guid" type_code="9">84fa917c-1ed8-4db3-8be1-7bdc4a6495a2</item>
                        <item name="InputId" index="1" type_name="gh_guid" type_code="9">84fa917c-1ed8-4db3-8be1-7bdc4a6495a2</item>
                        <item name="OutputCount" type_name="gh_int32" type_code="3">2</item>
                        <item name="OutputId" index="0" type_name="gh_guid" type_code="9">3ede854e-c753-40eb-84cb-b48008f14fd4</item>
                        <item name="OutputId" index="1" type_name="gh_guid" type_code="9">8ec86459-bf01-4409-baee-174d0d2b13d0</item>
                      </items>
                      <chunks count="4">
                        <chunk name="InputParam" index="0">
                          <items count="9">
                            <item name="AllowTreeAccess" type_name="gh_bool" type_code="1">true</item>
                            <item name="Description" type_name="gh_string" type_code="10">Script Variable x</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">13dbe4fc-cdee-42c7-a9ab-7b0781a1fe83</item>
                            <item name="Name" type_name="gh_string" type_code="10">x</item>
                            <item name="NickName" type_name="gh_string" type_code="10">x</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">true</item>
                            <item name="ScriptParamAccess" type_name="gh_int32" type_code="3">0</item>
                            <item name="ShowTypeHints" type_name="gh_bool" type_code="1">true</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="3">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>39</X>
                                  <Y>28</Y>
                                  <W>13</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>47</X>
                                  <Y>38</Y>
                                </item>
                                <item name="Selected" type_name="gh_bool" type_code="1">true</item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                        <chunk name="InputParam" index="1">
                          <items count="9">
                            <item name="AllowTreeAccess" type_name="gh_bool" type_code="1">true</item>
                            <item name="Description" type_name="gh_string" type_code="10">Script Variable y</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">903d88e9-ef74-48ec-95be-afc04d545bac</item>
                            <item name="Name" type_name="gh_string" type_code="10">y</item>
                            <item name="NickName" type_name="gh_string" type_code="10">y</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">true</item>
                            <item name="ScriptParamAccess" type_name="gh_int32" type_code="3">0</item>
                            <item name="ShowTypeHints" type_name="gh_bool" type_code="1">true</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="3">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>39</X>
                                  <Y>48</Y>
                                  <W>13</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>47</X>
                                  <Y>58</Y>
                                </item>
                                <item name="Selected" type_name="gh_bool" type_code="1">true</item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                        <chunk name="OutputParam" index="0">
                          <items count="7">
                            <item name="Access" type_name="gh_int32" type_code="3">1</item>
                            <item name="Description" type_name="gh_string" type_code="10">Print, Reflect and Error streams</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">f45c0d2f-f8dd-4486-984d-995c0fec83c6</item>
                            <item name="Name" type_name="gh_string" type_code="10">out</item>
                            <item name="NickName" type_name="gh_string" type_code="10">out</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">false</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="3">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>82</X>
                                  <Y>28</Y>
                                  <W>28</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>96</X>
                                  <Y>38</Y>
                                </item>
                                <item name="Selected" type_name="gh_bool" type_code="1">true</item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                        <chunk name="OutputParam" index="1">
                          <items count="6">
                            <item name="Description" type_name="gh_string" type_code="10">Output parameter A</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">3985a8c4-2924-4892-892f-b3c149887270</item>
                            <item name="Name" type_name="gh_string" type_code="10">A</item>
                            <item name="NickName" type_name="gh_string" type_code="10">A</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">false</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="3">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>82</X>
                                  <Y>48</Y>
                                  <W>28</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>96</X>
                                  <Y>58</Y>
                                </item>
                                <item name="Selected" type_name="gh_bool" type_code="1">true</item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                      </chunks>
                    </chunk>
                  </chunks>
                </chunk>
              </chunks>
            </chunk>
          </chunks>
        </chunk>
      </chunks>
    </chunk>
    <chunk name="Thumbnail">
      <items count="1">
        <item name="Thumbnail" type_name="gh_drawing_bitmap" type_code="37">
          <bitmap length="3163">iVBORw0KGgoAAAANSUhEUgAAAJYAAABkCAIAAADrOV6nAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAvwSURBVHhe7Zl5UJPXGof7R1u9nVuvvdO6Icq+BILsS8hKNvZdQWURqyJW62BZpFKlgOwECCQQQpBdQBS1Wm3Vti6UoJaqVWtdK0s2khCWoGg196iZQiNYWmc6c+6cZ37zzfkOc95553vyrbyB+H9Ag4CWCYW9CAhBCqEHKYQepBB6kELoQQqhBymcgp6eHrFIPKQc+oejUqj6+/q1TcwYpFCXnt4emVR2/cZ1TgMXhNtUrhNOI5ffyq87XPeK1B6sLd9bwWnUXfuKlNVzq/YJQAMikehFJzMEKdRF1C+6efvWhoz1gi+47R1N+881TE7bufovL7SVHyqKy9iwaXfs1MmIjS/Y3Hau7lBnc9sfl0+bjoaDHc3ZDelJrESZRNbX16ftZgYghboo5cq69ob8lswnmntijVCs6ZocpebHrv4DmzNja1pq+M38yubKl1PdWl1YydpRvlWqOS/RnNepMF1Ems6HmrvxRR93XhRKxBJtNzMAKdRleHC4+WhrcXvmfc2Jyw/3XX7YNjn3NMeSBTHVLXXCn4Snuk59c/6bl3Oy6+RPt67GZ8U3Xcr6RXNYp4I2488zaebSw9Yezbc7eIkXr3RLJVJtNzMAKZwAPMVIpVKgcGdOWm7bjhuats4xvvBBlfCBQDim3V7VNCbviebW83j7eNxm7pQp21vWcrw1KS+Rfz7p0tP6F2u7JhV5tvtQcOFxtXb3eTrHKm9pDm/OX1/bVD8yPNLfP9PnGqRwArFYDCySCKS3/zUr64stR59urh9aXa+MaByKbB2PblBF1A9GHHgas6GaGJe6lRnL9Iz1nDL0dfTI7ZFRyZHpXbTWh2uax6JABbC8ZSyqaVg74N5ZHt9CBfMv/gRSqwo/9fTT6MyQN996M25j3ODg4AzviEjhBKOjo/Hx8dZW2APHD6e2Rzc+DuIOUrlK+mq+xWfnXWPqrXjDjJrfmNEC+/AtUZb+llYBViAYP4ylr6V1oPWLXRALXwvyGsryrSHJXXY1j7xybhJ9swxBsm8Q1jZalyvpW47Yxe7DYvzfi//KgT/KBDMgZUpyy3hEck3cF19++c4777S0tACL2s5eCVI4gVqtxuFwuVm59+WihL1hTY9CyxWMPQ98dwrdDZlz836hCEZ96h77RFc5hG2OtAm2sQu1s/S2xAbZuES4YHytQMCMbYgtNhBLXUsL2RKUInRs1gSGlWJSO93Tu4krSizD2JZ7HvpGVWHjjzpF8q2bNAEVcs8KxbNwFbSWB5Efl0cDERQyJSkpCfSj7eyVIIUTjIyMpKWl6evp8+oEOw5ENI6HcOUM/rDXxlY7arLBpv12glHv2kfeUXz74LiV4LTD+GJ8Erx3tqVsq91C3kAKTPEzoBguC15mHWBNWeMRsMl/u9Ch8alfbKvd6nIMEPbRAftQlvmWgw607QY7OnD0FIPdP5F4g57lciYIR05tfhCRUL2Ox6+a9fasI0eOKJVKbWevBCmcADxByGSy8BXhb82elXJgZeN4MGeAzhbRkr9zqVAyE046c2T0mnGvyEpb//XLwQXT3Ms89LMg7ves6qvlFReLqy9zA5J9rfyeXVqJUSSfWO/tnfZVI17lckbcPtvYFtvKIc+MS4S1tTbbvnIClbcedYw/7sRTMUFZkFIZZf9va0J3UWfNnp3+efrQ0JC2rT8DKZzg2Xc1sXh8bJzNL9/aFFD3ILBUSuXIaLwhJjjilUPMMimt+gFzNW+ZT0wQxh9jyjBdmbmi6kJZqbAg/XAqV1gUmbPKyv/ZvRAfQfBcx0z+3h6sAhWq1J4CtSdYXjHIEIx58keeT456Vg4zyyQ0MA/ClpIb1eFr8v2PfX1CPaqe+ds9UqiLSqFqPdr+cZNfjdqPLfEolVAnRzDGWFVhw4jyA48wIMY04w+L13AvFOWdyGi9U7uRs87Cx8LM28xtJY4WQ03qsOOpGDoVpkuJhFQ3HLqBHdJ9+Qp6tX8tBuWDTe2tmxu99oz4FIvIJSLK5PBHaSu51h6rPM29zYFCQ6ohuCk6rXKkb6HGFIJnHKyVP8bMy8wlzJUSRUo8Z1uupOlUmC5FIlLNUPCHJQFdF35ACl+L5wr3bWpgCIa9ivpJxf3kyakcoYZzrIhhNODJhGHiEukcnrHciGZkSDXySfCifkQBY1NPU8dQZ8JqPFDIVVB1KkwXVj+hWhUQU+yHFL4W4HaoHlYfPnEstt6Dr2Ky+ohFfaTJ4Q17rCjD4ELIpkzThbhFSXvjdx1K0SMs1ictCdkZyDlfuJSy1JhhbB/s4BbmmnB2GUdOYfWSikWkUikZDHSqTU5hH56v8F3L9r1+49aAbAB0ou3pz0AKJwBHTaFQ3L9zf/1HG9fXkSpVjIIePKuXWNRPLOwhgC0Yl6vIy0stnALwwNN8twW5p9LDMkLn2Myd5zIfG2zNv1IKboSGNMNlAbZOoY6fnLEplZHA7yDvDn5XtwsQCepMl4Ied4HKLyDNNTMrFyiUSCQztIgUTiCVSq9du2ZkYPTBgvmbW+kVSjo4rDm3cSBFIkL2TVzeXXfuICmUbW7n42LEMJrvumAde80hSbP/dh9wCa24UFLckbsQt9CAZmDtZ2MXZPvJaSxbSuQoyWsbMeZB7xX24At7CQX38VMm/z5OoPINzsC9++4cJp0JXm9m+JkUKZxArVZHR0fTqfTOyz+sq8Nx5R6Fve47u50D8gzzf3X3z3225SiJwcVmWE8HQ7qRAdVgCWVp+pHU04+PnXlyvP4G3y7MdjFxMVCI8bGy8bfedhpbIiaw+vArOCahbJO4dmu2jAiKTJm8X904Eur6Cr/rP9+a9/48Ho83w1dDpHACoJBIJKbvSu+RSyIFDpwBct49N7aMEFxk7Pn5kpgGS/YAsUxBCCoytaQtA1dLkCWUJQvcFmCDsQ7h9otJi/UIemASqLXwssR4W277DlsmJyafs7eP+cAvw4CcqFemIObdw02Z3HuupRJKZAkViMC741NSUtAHtr8M+NVzudw5/56zPS11fZNb6QAp964rS4RPPG1n6j83+7YbuNaVyvGBLBNTstVSj6W/B5hbhF8EdL7YBQMzprkZ0zT+O2z5EGk523glz3RHpwM5QS/1gmNBDy73rtvLybnrAhRGl9E+SUiePWt2R0eHXC7XdvZKkMIJ+vr6BgcHd6bumvvf96Jr7UtlxJw7LoV9uE2HrUNKjIql7tm3XdkD7gGFRgZ4M+BpuuiT9Y1pJkZUw/hvrVkiXIrQHpxhRRL3z7od0q44gXHOnSmSfceZK6eSEk309PQbGxpVKhV6nPk7AItPHj1pam8Lq7QsFrtn3XLOveeSeNZ2548O4CwBuyUynE+ugZ6rkR5Jb7osIiwy8DDUJ+pvPWmV3+Oa+yvQ82wtGIDfBBhMmd23nFj9uKAcx+7uq+pRNXqp+PuoFKq9B/eHCcxZIrfdN50yf3HMuesMThEwALsssWso1/A/mAX6RIPFhCVTRg+/ZDHOaD7u/e1d2Nx7zmDVTJJ506GwzzU43+HiD+gD2+uhGFAc/fprarZekcw5v9cpvxdsJ1LY75x735GQtMjMd4F50ELzILDVjUXgQhO/eatrjErkri9XmC4FfU6779rQd2B/vnZbLBJru5kBSKEu4FoqEw8kFm+jp5n4F1j45pv/IXnmASyLoFJLRoYxfbqkG3tlm4RwMLprX5mAQkvKp+acJq5SPqN/1v8OUjgF4J1aLlUIu7pPn+k8fW6KnOnoPNspPDd9zn4v1Fny5znTeenSNeXAX/MHQAqnBpyLUolUJpX9k/lLt8DfQQqhBymEHqQQepBC6EEKoQcphB6kEHqQQuhBCqEHKYQepBB6kELoQQqhBymEHqQQepBC6EEKoQcphB6kEHqQQuhBCqEHKYQepBB6kELoQQqhBymEHqQQepBC6EEKoQcphB6kEHqQQuhBCqEHKYQepBB6kELoQQqhBymEHqQQepBC6EEKoQcphB6kEHqQQuhBCqEHKYQepBB6kELoQQqhBymEHqQQepBC6EEKoQcphB6kEHqQQuhBCqEHKYQepBB6kELoQQqhBymEnj8oRECKViECYt54438jeUxl/PImMgAAAABJRU5ErkJggg==</bitmap>
        </item>
      </items>
    </chunk>
  </chunks>
</Archive>