<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<Archive name="Root">
  <!--Grasshopper archive-->
  <!--Grasshopper and GH_IO.dll are copyrighted by Robert McNeel & Associates-->
  <!--Archive generated by GH_IO.dll file utility library {0.2.0002}-->
  <items count="1">
    <item name="ArchiveVersion" type_name="gh_version" type_code="80">
      <Major>0</Major>
      <Minor>2</Minor>
      <Revision>2</Revision>
    </item>
  </items>
  <chunks count="2">
    <chunk name="Definition">
      <items count="1">
        <item name="plugin_version" type_name="gh_version" type_code="80">
          <Major>0</Major>
          <Minor>9</Minor>
          <Revision>76</Revision>
        </item>
      </items>
      <chunks count="5">
        <chunk name="DocumentHeader">
          <items count="5">
            <item name="DocumentID" type_name="gh_guid" type_code="9">69d9911e-a464-4365-bb27-73977a7052fc</item>
            <item name="Preview" type_name="gh_string" type_code="10">Shaded</item>
            <item name="PreviewMeshType" type_name="gh_int32" type_code="3">1</item>
            <item name="PreviewNormal" type_name="gh_drawing_color" type_code="36">
              <ARGB>100;150;0;0</ARGB>
            </item>
            <item name="PreviewSelected" type_name="gh_drawing_color" type_code="36">
              <ARGB>100;0;150;0</ARGB>
            </item>
          </items>
        </chunk>
        <chunk name="DefinitionProperties">
          <items count="3">
            <item name="Date" type_name="gh_date" type_code="8">636140903519571247</item>
            <item name="Description" type_name="gh_string" type_code="10"></item>
            <item name="Name" type_name="gh_string" type_code="10">out.ghx</item>
          </items>
          <chunks count="3">
            <chunk name="Revisions">
              <items count="1">
                <item name="RevisionCount" type_name="gh_int32" type_code="3">0</item>
              </items>
            </chunk>
            <chunk name="Projection">
              <items count="2">
                <item name="Target" type_name="gh_drawing_point" type_code="30">
                  <X>424</X>
                  <Y>92</Y>
                </item>
                <item name="Zoom" type_name="gh_single" type_code="5">3.23886371</item>
              </items>
            </chunk>
            <chunk name="Views">
              <items count="1">
                <item name="ViewCount" type_name="gh_int32" type_code="3">0</item>
              </items>
            </chunk>
          </chunks>
        </chunk>
        <chunk name="RcpLayout">
          <items count="1">
            <item name="GroupCount" type_name="gh_int32" type_code="3">0</item>
          </items>
        </chunk>
        <chunk name="GHALibraries">
          <items count="1">
            <item name="Count" type_name="gh_int32" type_code="3">0</item>
          </items>
        </chunk>
        <chunk name="DefinitionObjects">
          <items count="1">
            <item name="ObjectCount" type_name="gh_int32" type_code="3">1</item>
          </items>
          <chunks count="1">
            <chunk name="Object" index="0">
              <items count="2">
                <item name="GUID" type_name="gh_guid" type_code="9">a9a8ebd2-fff5-4c44-a8f5-739736d129ba</item>
                <item name="Name" type_name="gh_string" type_code="10">C# Script</item>
              </items>
              <chunks count="1">
                <chunk name="Container">
                  <items count="8">
                    <item name="AdditionalSource" type_name="gh_string" type_code="10">  #region ..\BuildingObject.cs

  public class BuildingObject
  {
    public interface BuildingObjectProvider
    {
      RealObject.Building GetBuilding();
    }


    public interface Building : BuildingObjectProvider
    {
      PlanObject.Building GetPlan();
    }

    public class BuildingMultipleFloor : Building
    {
      public List&lt;FloorGeneral&gt; Content = new List&lt;FloorGeneral&gt;();
      public string Name = "Building";

      public BuildingMultipleFloor(string Name)
      {
        this.Name = Name;
      }

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building(this.Name);
        double Height = 0;
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          FloorGeneral item = Content[i];

          RealObject.Building Body = item.GetBuilding();
          Body.Transform(Transform.Translation(0, 0, Height));
          Result.Add(Body);

          RealObject.Member Floor = item.GetFloor();
          Floor.Transform(Transform.Translation(0, 0, Height));
          Result.Add(Floor);

          RealObject.Member Ceiling = item.GetCeiling();
          Ceiling.Transform(Transform.Translation(0, 0, Height));
          Result.Add(Ceiling);

          RealObject.Member Loof = item.GetLoof();
          Loof.Transform(Transform.Translation(0, 0, Height));
          Result.Add(Loof);

          Height += item.Height;
        }
        return Result;
      }

      public RealObject.Building GetBuildingLight()
      {
        RealObject.Building Result = new RealObject.Building(this.Name);
        double Height = 0;
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          FloorGeneral item = Content[i];


          List&lt;Brep&gt; Exts = new List&lt;Brep&gt;();
          Curve[] Cvs = item.GetOuterLine();
          foreach (Curve Cv in Cvs)
          {
            Exts.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Cv, Vector3d.ZAxis * item.Height)));
          }
          RealObject.Member Wall = new RealObject.Member("Wall", Exts.ToArray());
          Wall.Transform(Transform.Translation(0, 0, Height));
          Result.Add(Wall);


          RealObject.Member Loof = item.GetLoof();
          Loof.Transform(Transform.Translation(0, 0, Height));
          Result.Add(Loof);

          Height += item.Height;

        }
        return Result;
      }

      public PlanObject.Floor GetSection(Line l)
      {
        Curve IntersectLine = l.ToNurbsCurve();
        Point3d Start = l.From;
        PlanObject.Floor Result = new PlanObject.Floor("Section");
        double CurrentHeight = 0;

        for (int i = 0; i &lt; Content.Count(); i++)
        {
          FloorGeneral item = Content[i];
          double FloorHeight = item.Height;
          List&lt;Point3d&gt; TPoints = new List&lt;Point3d&gt;();

          Curve[] OCurves = item.GetOuterLine();

          foreach (Curve Curve in OCurves)
          {
            var intersects = Rhino.Geometry.Intersect.Intersection.CurveCurve(Curve, IntersectLine, 100, 100);
            foreach (var intersect in intersects)
            {
              TPoints.Add(intersect.PointA);
            }
          }

          List&lt;double&gt; Distances = new List&lt;double&gt;();
          foreach (Point3d TPoint in TPoints)
          {
            Distances.Add(Start.DistanceTo(TPoint));
          }
          Distances.Sort();

          PlanObject.Member Wall = new PlanObject.Member("Wall");
          PlanObject.Member Loof = new PlanObject.Member("Loof");
          PlanObject.Member Floor = new PlanObject.Member("Floor");
          for (int j = 0; j &lt; Distances.Count() - 1; j += 2)
          {
            Wall.Content.Add(new Line(Distances[j], CurrentHeight, 0, Distances[j], CurrentHeight + FloorHeight, 0).ToNurbsCurve());
            Wall.Content.Add(new Line(Distances[j + 1], CurrentHeight, 0, Distances[j + 1], CurrentHeight + FloorHeight, 0).ToNurbsCurve());

            Floor.Content.Add(new Line(Distances[j], CurrentHeight, 0, Distances[j + 1], CurrentHeight, 0).ToNurbsCurve());
            Loof.Content.Add(new Line(Distances[j], CurrentHeight + FloorHeight, 0, Distances[j + 1], CurrentHeight + FloorHeight, 0).ToNurbsCurve());
          }
          Result.Content.Add(Wall);
          Result.Content.Add(Loof);
          Result.Content.Add(Floor);

          CurrentHeight += FloorHeight;
        }
        return Result;
      }


      public PlanObject.Building GetPlan()
      {
        PlanObject.Building Result = new PlanObject.Building(this.Name);
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          FloorGeneral item = Content[i];

          Result.Content.Add(item.GetPlan());
        }
        return Result;
      }
    }

    public class FloorGeneral : BuildingObjectProvider
    {
      public List&lt;Wall&gt; Walls = new List&lt;Wall&gt;();
      public List&lt;RealObject.Building&gt; Objects = new List&lt;RealObject.Building&gt;();
      public double Height = 0;
      public string Name = "Floor";
      public double CeilingThick = 300;
      public double GroundOffset = 200;

      public FloorGeneral(string Name)
      {
        this.Name = Name;
      }

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building(this.Name);
        foreach (Wall w in Walls)
        {
          Result.Add(w.GetBuilding());
        }
        Result.Add(Objects.ToArray());
        return Result;
      }

      public RealObject.Member GetCeiling()
      {
        Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
        return new RealObject.Member("Ceiling", GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height - CeilingThick)));
      }
      public RealObject.Member GetFloor()
      {
        Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
        return new RealObject.Member("Floor", GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, 1)));
      }
      public RealObject.Member GetLoof()
      {
        Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
        return new RealObject.Member("Loof", GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height)));
      }

      public Curve[] GetOuterLine()
      {
        List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
        foreach (Wall w in Walls)
        {
          Curve cv = w.GetLineOut();
          if (cv != null) { cvs.Add(cv); }
        }
        return Curve.JoinCurves(cvs);
      }

      public PlanObject.Floor GetPlan()
      {
        PlanObject.Floor Result = new PlanObject.Floor("Floor");
        foreach (Wall w in this.Walls)
        {
          Result.Content.AddRange(w.GetPlan());
        }
        return Result;
      }

      public void Add(params Wall[] item)
      {
        Walls.AddRange(item);
      }

      public void Add(params RealObject.Building[] item)
      {
        Objects.AddRange(item);
      }
    }

    public class BuildingSingleFloor : Building
    {
      public List&lt;Wall&gt; Walls = new List&lt;Wall&gt;();
      public List&lt;RealObject.Building&gt; Objects = new List&lt;RealObject.Building&gt;();
      public int Floor = 1;
      public double Height;
      public string Name = "Building";
      public double CeilingThick = 300;
      public double GroundOffset = 200;

      public BuildingSingleFloor(string Name)
      {
        this.Name = Name;
      }
      public BuildingSingleFloor()
      {
      }

      public RealObject.Building GetBuilding()
      {
        List&lt;RealObject.Building&gt; BldBase = new List&lt;RealObject.Building&gt;();
        List&lt;RealObject.Building&gt; BldBaseTop = new List&lt;RealObject.Building&gt;();
        foreach (Wall w in Walls)
        {
          BldBase.Add(w.GetBuilding());
          BldBaseTop.Add(w.GetBuildingTop());
        }
        RealObject.Building Ceiling = new RealObject.Building("Ceiling");
        Brep[] CeilBase = Brep.CreatePlanarBreps(GetOuterLine());
        Ceiling.Add("Ceiling", GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height - CeilingThick)));
        BldBase.Add(Ceiling);

        BldBase.AddRange(Objects);

        RealObject.Member Loof = new RealObject.Member("Floor", GeneralHelper.TranslateBreps(CeilBase, new Vector3d(0, 0, Height)));

        RealObject.Building Result = new RealObject.Building(Name);
        for (int i = 0; i &lt; Floor; i++)
        {
          foreach (RealObject.Building bld in BldBase)
          {
            foreach (RealObject.Member mb in bld.Content)
            {
              RealObject.Member newMem = mb.Duplicate();
              newMem.Transform(Transform.Translation(0, 0, GroundOffset + Height * i));
              Result.Add(newMem);
            }
          }

          RealObject.Member newLoof = Loof.Duplicate();
          newLoof.Transform(Transform.Translation(0, 0, GroundOffset + Height * i));
          if (i + 1 == Floor)
          {
            newLoof.SetName("Loof");
          }
          Result.Add(newLoof);
        }
        {
          RealObject.Member newLoof = Loof.Duplicate();
          newLoof.Transform(Transform.Translation(0, 0, GroundOffset - Height));
          Result.Add(newLoof);
        }
        if (GroundOffset != 0)
        {
          Curve[] cvs = GetOuterLine();
          foreach (Curve cv in cvs)
          {
            Result.Add("Basement", Brep.CreateFromSurface(Surface.CreateExtrusion(cv, Vector3d.ZAxis * GroundOffset)));
          }
        }
        foreach (RealObject.Building bld in BldBaseTop)
        {
          foreach (RealObject.Member mb in bld.Content)
          {
            RealObject.Member newMem = mb.Duplicate();
            newMem.Transform(Transform.Translation(0, 0, GroundOffset + Height * (Floor - 1)));
            Result.Add(newMem);
          }
        }

        return Result;
      }

      public PlanObject.Building GetPlan()
      {
        PlanObject.Floor ResultF = new PlanObject.Floor("Floor");
        foreach (Wall w in this.Walls)
        {
          ResultF.Content.AddRange(w.GetPlan());
        }

        PlanObject.Building ResultB = new PlanObject.Building("Building");
        for (int i = 0; i &lt; this.Floor; i++)
        {
          ResultB.Content.Add(ResultF);
        }
        return ResultB;
      }


      public void Add(params Wall[] item)
      {
        Walls.AddRange(item);
      }

      public void Add(params RealObject.Building[] item)
      {
        Objects.AddRange(item);
      }

      public Curve[] GetOuterLine()
      {
        List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
        foreach (Wall w in Walls)
        {
          Curve cv = w.GetLineOut();
          if (cv != null) { cvs.Add(cv); }
        }
        return Curve.JoinCurves(cvs);
      }
    }


    public static class BuildingProvider
    {
      public static BuildingObject.Building GetApartment(double UnitX, double UnitY, double UnitZ, int UnitCountX, int UnitCountZ, double CeilingThick = 300, double WallThick = 0)
      {
        BuildingObject.BuildingSingleFloor Result = new BuildingObject.BuildingSingleFloor();
        Result.Height = UnitZ;
        Result.Name = "Apartment";
        Result.CeilingThick = CeilingThick;
        Result.Floor = UnitCountZ;

        WallGeneral WallSouth = new WallGeneral(Point3d.Origin, new Vector2d(UnitX, 0), UnitZ, WallThick);
        WallSouth.Add(new VerandaSimple(new Interval(0, UnitX), 100, 2000, 100, 1000, 150) { SideHeight1 = UnitZ, SideHeight2 = UnitZ });
        WallSouth.AttachmentsTop.Add(new Eaves(new Interval(0, UnitX), 2000, 300, UnitZ));
        for (double WindowX = 1000; WindowX + 2000 + 500 &lt; UnitX; WindowX += 3000)
        {
          WallSouth.Add(new BuildingObject.WindowGlassSimpleDouble(new Point2d(WindowX, 0), 2000, 2500));
        }
        Result.Add(new WallRepeat(WallSouth, UnitCountX));

        Result.Add(new WallGeneral(new Point3d(0, UnitY, 0), new Vector2d(0, -UnitY), UnitZ, WallThick));
        for (int i = 1; i &lt; UnitCountX; i++)
        {
          Result.Add(new WallGeneral(new Point3d(UnitX * i, 0, 0), new Vector2d(0, UnitY), UnitZ, WallThick));
        }
        Result.Add(new WallGeneral(new Point3d(UnitX * UnitCountX, 0, 0), new Vector2d(0, UnitY), UnitZ, WallThick));


        WallGeneral WallNorth = new WallGeneral(new Point3d(UnitX * UnitCountX, UnitY, 0), new Vector2d(-UnitX * UnitCountX, 0), UnitZ, WallThick);
        WallNorth.Add(new VerandaSimple(new Interval(0, UnitX * UnitCountX), 100, 2000, 100, 1000, 100));
        for (int i = 0; i &lt; UnitCountX; i++)
        {
          WallNorth.Add(new DoorSimple(new Point2d(UnitX * i + 500, 0), 1000, 2500, DoorSimple.Side.FrontRight));
        }
        Result.Add(WallNorth);

        return Result;
      }
    }

    public interface Stair : BuildingObjectProvider
    {
    }


    public interface Wall : BuildingObjectProvider
    {
      RealObject.Building GetBuildingTop();
      void Translate(Vector3d v3d);
      void Rotate(double angle);
      Curve[] GetCurves();
      Curve GetLineIn();
      Curve GetLineOut();
      Wall Duplicate();
      PlanObject.Member[] GetPlan();
    }

    public class WallRepeat : Wall
    {
      public Wall Content;
      public int Count;
      public Vector3d Direction { get { if (Content is WallGeneral) { Vector2d v2d = ((WallGeneral) Content).Direction; return new Vector3d(v2d.X, v2d.Y, 0); } else { return _Direction; } } set { if (!(Content is WallGeneral)) { _Direction = value; } } }
      private Vector3d _Direction;

      public WallRepeat(WallGeneral Content, int Count)
      {
        this.Content = Content;
        this.Count = Count;
      }

      public WallRepeat(Wall Content, int Count, Vector3d Direction)
      {
        this.Content = Content;
        this.Count = Count;
        this.Direction = Direction;
      }

      public Wall[] GetWalls()
      {
        List&lt;Wall&gt; w = new List&lt;Wall&gt;();
        for (int i = 0; i &lt; Count; i++)
        {
          Wall tmpw = Content.Duplicate();
          tmpw.Translate(Direction * i);
          w.Add(tmpw);
        }
        return w.ToArray();
      }

      public RealObject.Building GetBuilding()
      {
        Wall[] ws = GetWalls();
        RealObject.Building Result = new RealObject.Building("WallRepeat");
        foreach (Wall w in ws)
        {
          Result.Add(w.GetBuilding());
        }
        return Result;
      }

      public RealObject.Building GetBuildingTop()
      {
        Wall[] ws = GetWalls();
        RealObject.Building Result = new RealObject.Building("WallRepeat");
        foreach (Wall w in ws)
        {
          Result.Add(w.GetBuildingTop());
        }
        return Result;
      }

      public void Translate(Vector3d v3d)
      {
        Content.Translate(v3d);
      }

      public void Rotate(double angle)
      {
        Content.Rotate(angle);
      }

      public Curve[] GetCurves()
      {
        Wall[] ws = GetWalls();
        List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
        foreach (Wall w in ws)
        {
          cvs.AddRange(w.GetCurves());
        }
        return cvs.ToArray();
      }

      public Curve GetLineIn()
      {
        Wall[] ws = GetWalls();
        List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
        foreach (Wall w in ws)
        {
          cvs.Add(w.GetLineIn());
        }
        return Curve.JoinCurves(cvs.ToArray())[0];
      }
      public Curve GetLineOut()
      {
        Wall[] ws = GetWalls();
        List&lt;Curve&gt; cvs = new List&lt;Curve&gt;();
        foreach (Wall w in ws)
        {
          cvs.Add(w.GetLineOut());
        }
        return Curve.JoinCurves(cvs.ToArray())[0];
      }

      public Wall Duplicate()
      {
        return new WallRepeat(this.Content, this.Count, this.Direction);
      }

      public PlanObject.Member[] GetPlan()
      {
        Wall[] ws = GetWalls();
        List&lt;PlanObject.Member&gt; Result = new List&lt;PlanObject.Member&gt;();
        foreach (Wall w in ws)
        {
          Result.AddRange(w.GetPlan());
        }
        return Result.ToArray();
      }

    }

    public class WallGeneral : Wall
    {
      public Point3d StartPoint;
      public Vector2d Direction;
      public double Height;
      public double Thickness;
      public Point3d EndPoint { get { return StartPoint + new Vector3d(Direction.X, Direction.Y, Height); } set { Vector3d v3d = value - StartPoint; Direction = new Vector2d(v3d.X, v3d.Y); Height = v3d.Z; } }
      public bool ApplyZeroThicknessToBrep = false;
      public bool OmitFromFloorLine = false;

      public List&lt;BuildingObject.Window&gt; Windows = new List&lt;BuildingObject.Window&gt;();
      public List&lt;BuildingObject.WallAttachment&gt; Attachments = new List&lt;BuildingObject.WallAttachment&gt;();
      public List&lt;BuildingObject.WallAttachment&gt; AttachmentsTop = new List&lt;BuildingObject.WallAttachment&gt;();

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("Wall");
        if (Thickness == 0 || ApplyZeroThicknessToBrep)
        {
          Result.Add("Wall", Brep.CreatePlanarBreps(GetCurves()));
        }
        else
        {
          Result.Add("Wall", GeneralHelper.CreateExtrusionCaped(GetCurves(), Vector3d.YAxis * Thickness));
        }

        foreach (BuildingObject.Window w in Windows)
        {
          Result.Add(w.GetBuilding());
        }
        foreach (BuildingObject.WallAttachment at in Attachments)
        {
          Result.Add(at.GetBuilding());
        }
        Result.Transform(GeneralHelper.FitTwoPoint(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)));
        return Result;
      }

      public RealObject.Building GetBuildingTop()
      {
        RealObject.Building Result = new RealObject.Building("Wall.AttachmentTop");

        foreach (BuildingObject.WallAttachment at in AttachmentsTop)
        {
          Result.Add(at.GetBuilding());
        }
        Result.Transform(GeneralHelper.FitTwoPoint(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)));
        return Result;
      }

      public Wall Duplicate()
      {
        WallGeneral Result = new WallGeneral(this.StartPoint, this.Direction, this.Height, this.Thickness);

        foreach (BuildingObject.Window item in Windows)
        {
          Result.Add(item.Duplicate());
        }
        foreach (BuildingObject.WallAttachment item in Attachments)
        {
          Result.Add(item.Duplicate());
        }
        foreach (BuildingObject.WallAttachment item in AttachmentsTop)
        {
          Result.AttachmentsTop.Add(item.Duplicate());
        }
        return Result;
      }

      public Curve GetLineOut()
      {
        if (OmitFromFloorLine)
        {
          return null;
        }
        else
        {
          return new Line(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)).ToNurbsCurve();
        }
      }

      public Curve GetLineIn()
      {
        Vector3d V3dNormal = new Vector3d(-Direction.Y, Direction.X, 0);
        V3dNormal.Unitize();

        Vector3d V3dBase = new Vector3d(Direction.X, Direction.Y, 0);
        double BaseLen = V3dBase.Length;
        V3dBase.Unitize();

        return new Line(StartPoint + V3dNormal * Thickness, StartPoint + V3dNormal * Thickness + V3dBase * BaseLen).ToNurbsCurve();
      }

      public Curve[] GetCurves()
      {
        List&lt;Curve&gt; Result = new List&lt;Curve&gt;();

        Result.Add(new Rectangle3d(Plane.WorldZX, Point3d.Origin, new Point3d(Direction.Length, 0, Height)).ToNurbsCurve());

        foreach (BuildingObject.Window w in Windows)
        {
          Result.Add(new Rectangle3d(new Plane(new Point3d(w.StartPoint.X, 0, w.StartPoint.Y + 0.1), Vector3d.XAxis, Vector3d.ZAxis), w.Width, w.Height).ToNurbsCurve());
        }
        return Result.ToArray();
      }

      public WallGeneral(Point3d StartPoint, Vector2d Direction, double Height, double Thickness = 0)
      {
        this.StartPoint = StartPoint;
        this.Direction = Direction;
        this.Height = Height;
        this.Thickness = Thickness;
      }

      public void Add(params Window[] item)
      {
        Windows.AddRange(item);
      }

      public void Add(params WallAttachment[] item)
      {
        Attachments.AddRange(item);
      }

      public void Translate(Vector3d v3d)
      {
        StartPoint += v3d;
      }

      public void Rotate(double angle)
      {
        Point3d p3d = new Point3d(Direction.X, Direction.Y, 0);
        p3d.Transform(Transform.Rotation(angle, Point3d.Origin));
        Direction.X = p3d.X;
        Direction.Y = p3d.Y;
      }

            /*
            public void Transform(Transform tf)
            {
                Point3d a = Point3d.Origin;
                Point3d b = Point3d.Origin + Vector3d.YAxis;
                a.Transform(tf);
                b.Transform(tf);
                Thickness = (a - b).Length;

                Point3d End = EndPoint;
                End.Transform(tf);
                EndPoint = End;
                StartPoint.Transform(tf);

            }*/

      public PlanObject.Member[] GetPlan()
      {
        List&lt;PlanObject.Member&gt; Result = new List&lt;PlanObject.Member&gt;();

        foreach (BuildingObject.WallAttachment item in Attachments)
        {
          Result.AddRange(item.GetPlan());
        }
        List&lt;double&gt; PointList = new List&lt;double&gt;() { 0, Direction.Length };
        foreach (BuildingObject.Window item in Windows)
        {
          Result.AddRange(item.GetPlan(this.Thickness));
          PointList.Add(item.StartPoint.X);
          PointList.Add(item.StartPoint.X + item.Width);
        }
        PointList.Sort();

        PlanObject.Member WallResult = new PlanObject.Member("Wall");
        for (int i = 0; i &lt; PointList.Count / 2; i++)
        {
          WallResult.Content.Add(Providers.GetRectangle3d(new Point3d(PointList[i * 2], 0, 0), PointList[i * 2 + 1] - PointList[i * 2], this.Thickness));
        }
        Result.Add(WallResult);
        foreach (var item in Result)
        {
          item.Transform(GeneralHelper.FitTwoPoint(StartPoint, StartPoint + new Vector3d(Direction.X, Direction.Y, 0)));
        }
        return Result.ToArray();
      }
    }

    public interface WallAttachment : BuildingObjectProvider
    {
      WallAttachment Duplicate();
      PlanObject.Member[] GetPlan();

    }

    public class Eaves : WallAttachment
    {
      public Interval Domain;
      public double Length;
      public double Thickness;
      public double Height;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("Eaves");
        Result.Add("Body", Brep.CreateFromBox(new Box(Plane.WorldXY, this.Domain, new Interval(-Length, 0), new Interval(Height - Thickness, Height))));
        return Result;
      }

      public PlanObject.Member[] GetPlan()
      {
        return new PlanObject.Member[0];
      }

      public WallAttachment Duplicate()
      {
        return new Eaves(this.Domain, this.Length, this.Thickness, this.Height);
      }

      public Eaves(Interval Domain, double Length, double Thickness, double Height)
      {
        this.Domain = Domain;
        this.Length = Length;
        this.Thickness = Thickness;
        this.Height = Height;
      }

    }

    public class VerandaSimple : WallAttachment
    {
      public Interval Domain;
      public double FloorThickness;
      public double FloorLength;
      public double HandrailThickness;
      public double HandrailHeight;
      public double SideThickness1;
      public double SideHeight1;
      public double SideThickness2;
      public double SideHeight2;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("VerandaSimple");
        Result.Add("Floor", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min + SideThickness1, Domain.Max - SideThickness2), new Interval(-FloorLength, 0), new Interval(-FloorThickness, 0))) });
        Result.Add("Handrail", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, Domain, new Interval(-HandrailThickness - FloorLength, -FloorLength), new Interval(-FloorThickness, HandrailHeight))) });
        if (SideThickness1 != 0)
        {
          Result.Add("Side", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min, Domain.Min + SideThickness1), new Interval(-FloorLength, 0), new Interval(0, SideHeight1))) });
        }
        if (SideThickness2 != 0)
        {
          Result.Add("Side", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Max - SideThickness2, Domain.Max), new Interval(-FloorLength, 0), new Interval(0, SideHeight2))) });
        }
        return Result;
      }

      public VerandaSimple(Interval Domain, double FloorThickness, double FloorLength, double HandrailThickness, double HandrailHeight, double SideThickness = 0)
      {
        this.Domain = Domain;
        this.FloorLength = FloorLength;
        this.FloorThickness = FloorThickness;
        this.HandrailThickness = HandrailThickness;
        this.HandrailHeight = HandrailHeight;
        this.SideThickness1 = SideThickness;
        this.SideHeight1 = HandrailHeight;
        this.SideThickness2 = SideThickness;
        this.SideHeight2 = HandrailHeight;
      }

      public WallAttachment Duplicate()
      {
        return new VerandaSimple(this.Domain, this.FloorThickness, this.FloorLength, this.HandrailThickness, this.HandrailHeight, 0) { SideThickness1 = this.SideThickness1, SideThickness2 = this.SideThickness2, SideHeight1 = this.SideHeight1, SideHeight2 = this.SideHeight2 };
      }

      public PlanObject.Member[] GetPlan()
      {
        PlanObject.Member Result = new PlanObject.Member("Veranda");
        Polyline PL = new Polyline(4);
        PL.Add(Domain.Min, 0, 0);
        PL.Add(Domain.Min, -FloorLength, 0);
        PL.Add(Domain.Max, -FloorLength, 0);
        PL.Add(Domain.Max, 0, 0);
        Result.Content.Add(PL.ToNurbsCurve());
        return new[] { Result };
      }
    }

    public class VerandaGlass : WallAttachment
    {
      public Interval Domain;
      public double FloorThickness;
      public double FloorLength;
      public double SideThickness;
      public double SideHeight;
      public double HandrailHeight = 1200;
      public double HandrailSpace = 1000;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("VerandaGlass");
        Result.Add("Floor", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, Domain, new Interval(-FloorLength, 0), new Interval(-FloorThickness, 0))) });
        Result.Add(Providers.GetHandrailGlass(new Line(Domain.Min, -FloorLength, 0, Domain.Max, -FloorLength, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
        if (SideThickness != 0 &amp;&amp; SideHeight != 0)
        {
          Result.Add("Side", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min, Domain.Min + SideThickness), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
          Result.Add("Side", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Max - SideThickness, Domain.Max), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
        }
        return Result;
      }

      public VerandaGlass(Interval Domain, double FloorThickness, double FloorLength, double SideThickness = 0, double SideHeight = 0)
      {
        this.Domain = Domain;
        this.FloorLength = FloorLength;
        this.FloorThickness = FloorThickness;
        this.SideThickness = SideThickness;
        this.SideHeight = SideHeight;
      }

      public WallAttachment Duplicate()
      {
        return new VerandaGlass(this.Domain, this.FloorThickness, this.FloorLength, this.SideThickness, this.SideHeight);
      }

      public PlanObject.Member[] GetPlan()
      {
        PlanObject.Member Result = new PlanObject.Member("Veranda");
        Polyline PL = new Polyline(4);
        PL.Add(Domain.Min, 0, 0);
        PL.Add(Domain.Min, -FloorLength, 0);
        PL.Add(Domain.Max, -FloorLength, 0);
        PL.Add(Domain.Max, 0, 0);
        Result.Content.Add(PL.ToNurbsCurve());
        return new[] { Result };
      }

    }

    public class VerandaGlassSimple : WallAttachment
    {
      public Interval Domain;
      public double FloorThickness;
      public double FloorLength;
      public double SideThickness;
      public double SideHeight;
      public double HandrailHeight = 1200;
      public double HandrailSpace = 1000;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("VerandaGlass");
        Result.Add("Floor", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, Domain, new Interval(-FloorLength, 0), new Interval(-FloorThickness, 0))) });
        Result.Add(Providers.GetHandrailGlassSimple(new Line(Domain.Min, -FloorLength, 0, Domain.Max, -FloorLength, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
        if (SideThickness != 0 &amp;&amp; SideHeight != 0)
        {
          Result.Add("Side", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Min, Domain.Min + SideThickness), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
          Result.Add("Side", new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(Domain.Max - SideThickness, Domain.Max), new Interval(-FloorLength, 0), new Interval(0, SideHeight))) });
        }
        return Result;
      }

      public VerandaGlassSimple(Interval Domain, double FloorThickness, double FloorLength, double SideThickness = 0, double SideHeight = 0)
      {
        this.Domain = Domain;
        this.FloorLength = FloorLength;
        this.FloorThickness = FloorThickness;
        this.SideThickness = SideThickness;
        this.SideHeight = SideHeight;
      }

      public WallAttachment Duplicate()
      {
        return new VerandaGlass(this.Domain, this.FloorThickness, this.FloorLength, this.SideThickness, this.SideHeight);
      }

      public PlanObject.Member[] GetPlan()
      {
        PlanObject.Member Result = new PlanObject.Member("Veranda");
        Polyline PL = new Polyline(4);
        PL.Add(Domain.Min, 0, 0);
        PL.Add(Domain.Min, -FloorLength, 0);
        PL.Add(Domain.Max, -FloorLength, 0);
        PL.Add(Domain.Max, 0, 0);
        Result.Content.Add(PL.ToNurbsCurve());
        return new[] { Result };
      }

    }

    public class VerandaGlassSimpleWide : WallAttachment
    {
      public Interval Domain;
      public double FloorThickness;
      public double FloorLength;
      public Interval DomainVeranda;
      public bool SideExist1;
      public bool SideExist2;
      public double HandrailHeight = 1200;
      public double HandrailSpace = 1000;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("VerandaGlass");

        Polyline FloorBase = new Polyline();
        FloorBase.Add(Domain.Min, 0, 0);
        FloorBase.Add(DomainVeranda.Min, -FloorLength, 0);
        FloorBase.Add(DomainVeranda.Max, -FloorLength, 0);
        FloorBase.Add(Domain.Max, 0, 0);
        FloorBase.Add(Domain.Min, 0, 0);


        Result.Add("Floor", GeneralHelper.CreateExtrusionCaped(new Curve[] { FloorBase.ToNurbsCurve() }, -Vector3d.ZAxis * FloorThickness));
        Result.Add(Providers.GetHandrailGlassSimple(new Line(DomainVeranda.Min, -FloorLength, 0, DomainVeranda.Max, -FloorLength, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
        if (SideExist1)
        {
          Result.Add(Providers.GetHandrailGlassSimple(new Line(DomainVeranda.Min, -FloorLength, 0, Domain.Min, 0, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
        }
        if (SideExist2)
        {
          Result.Add(Providers.GetHandrailGlassSimple(new Line(DomainVeranda.Max, -FloorLength, 0, Domain.Max, 0, 0).ToNurbsCurve(), HandrailHeight, HandrailSpace));
        }
        return Result;
      }

      public VerandaGlassSimpleWide(Interval Domain, Interval DomainVeranda, double FloorThickness, double FloorLength, bool SideExist1 = true, bool SideExist2 = true)
      {
        this.Domain = Domain;
        this.DomainVeranda = DomainVeranda;
        this.FloorLength = FloorLength;
        this.FloorThickness = FloorThickness;
        this.SideExist1 = SideExist1;
        this.SideExist2 = SideExist2;
      }

      public WallAttachment Duplicate()
      {
        return new VerandaGlassSimpleWide(this.Domain, this.DomainVeranda, this.FloorThickness, this.FloorLength, this.SideExist1, this.SideExist2);
      }

      public PlanObject.Member[] GetPlan()
      {
        PlanObject.Member Result = new PlanObject.Member("Veranda");
        Polyline PL = new Polyline();
        if (SideExist1) { PL.Add(Domain.Min, 0, 0); }
        PL.Add(DomainVeranda.Min, -FloorLength, 0);
        PL.Add(DomainVeranda.Max, -FloorLength, 0);
        if (SideExist2) { PL.Add(Domain.Max, 0, 0); }
        Result.Content.Add(PL.ToNurbsCurve());
        return new[] { Result };
      }

    }


    public interface Window
    {
      Point2d StartPoint { get; set; }
      double Width { get; set; }
      double Height { get; set; }

      RealObject.Building GetBuilding();
      Window Duplicate();
      PlanObject.Member[] GetPlan(double WallThickness);

    }

    public class ElevatorSimple : Window
    {
      public Point2d StartPoint { get; set; }
      public double Width { get; set; }
      public double Height { get; set; }
      public double ElevatorWidth { get; set; }
      public double ElevatorLength { get; set; }
      public double ElevatorHeight { get; set; }

      public bool IsFront = true;

      public ElevatorSimple(Point2d StartPoint, double Width, double Height, bool IsFrone, double ElevatorWidth, double ElevatorLength, double ElevatorHeight)
      {
        this.StartPoint = StartPoint;
        this.Width = Width;
        this.Height = Height;
        this.IsFront = IsFrone;
        this.ElevatorWidth = ElevatorWidth;
        this.ElevatorLength = ElevatorLength;
        this.ElevatorHeight = ElevatorHeight;
      }

      public Window Duplicate()
      {
        ElevatorSimple Result = new ElevatorSimple(StartPoint, Width, Height, IsFront, ElevatorWidth, ElevatorLength, ElevatorHeight);
        return Result;
      }

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("Elevator");

        if (IsFront)
        {
          Result.Add("Door", Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X, StartPoint.X + Width / 2), new Interval(-100, 0), new Interval(StartPoint.Y, StartPoint.Y + Height))));
          Result.Add("Door", Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X + Width / 2, StartPoint.X + Width), new Interval(-100, 0), new Interval(StartPoint.Y, StartPoint.Y + Height))));
        }
        else
        {
          Result.Add("Door", Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X, StartPoint.X + Width / 2), new Interval(0, 100), new Interval(StartPoint.Y, StartPoint.Y + Height))));
          Result.Add("Door", Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(StartPoint.X + Width / 2, StartPoint.X + Width), new Interval(0, 100), new Interval(StartPoint.Y, StartPoint.Y + Height))));
        }
        return Result;
      }

      public PlanObject.Member[] GetPlan(double WallThickness)
      {
        PlanObject.Member Result = new PlanObject.Member("Elevator");
        if (IsFront)
        {
          Point3d A = new Point3d(StartPoint.X + Width / 2 - ElevatorWidth / 2, -WallThickness * 1.5, 0);
          Point3d B = A + Vector3d.XAxis * ElevatorWidth;
          Point3d C = A - Vector3d.YAxis * ElevatorLength;
          Point3d D = B - Vector3d.YAxis * ElevatorLength;
          Point3d E = A + Vector3d.XAxis * ElevatorWidth / 2 - Vector3d.YAxis * ElevatorLength / 2;
          Result.Content.Add(Providers.GetRectangle3d(A, ElevatorWidth, ElevatorLength));
          Result.Content.Add(new Line(A, A + Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
          Result.Content.Add(new Line(B, B - Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
          Result.Content.Add(new Line(C, C + Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
          Result.Content.Add(new Line(D, D - Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());

          Curve[] Cvs = GetEVText();
          double ScaleFactor = Math.Min(ElevatorWidth / 3 / 3.0, ElevatorLength / 3 / 2);
          foreach (Curve cv in Cvs)
          {
            cv.Rotate(Math.PI, Vector3d.ZAxis, Point3d.Origin);
            cv.Scale(ScaleFactor);
            cv.Translate((Vector3d) E);
            Result.Content.Add(cv);
          }

        }
        else
        {
          Point3d A = new Point3d(StartPoint.X + Width / 2 - ElevatorWidth / 2, WallThickness * 1.5, 0);
          Point3d B = A + Vector3d.XAxis * ElevatorWidth;
          Point3d C = A + Vector3d.YAxis * ElevatorLength;
          Point3d D = B + Vector3d.YAxis * ElevatorLength;
          Point3d E = A + Vector3d.XAxis * ElevatorWidth / 2 + Vector3d.YAxis * ElevatorLength / 2;
          Result.Content.Add(Providers.GetRectangle3d(A, ElevatorWidth, ElevatorLength));
          Result.Content.Add(new Line(A, A + Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
          Result.Content.Add(new Line(B, B - Vector3d.XAxis * ElevatorWidth / 4 + Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
          Result.Content.Add(new Line(C, C + Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());
          Result.Content.Add(new Line(D, D - Vector3d.XAxis * ElevatorWidth / 4 - Vector3d.YAxis * ElevatorLength / 4).ToNurbsCurve());

          Curve[] Cvs = GetEVText();
          double ScaleFactor = Math.Min(ElevatorWidth / 3 / 3.0, ElevatorLength / 3 / 2);
          foreach (Curve cv in Cvs)
          {
            cv.Scale(ScaleFactor);
            cv.Translate((Vector3d) E);
            Result.Content.Add(cv);
          }
        }
        return new[] { Result };

      }

      public static Curve[] GetEVText()
      {
        var pls = new List&lt;Curve&gt;();
        {
          Polyline pl = new Polyline();
          pl.Add(-0.5, -1, 0);
          pl.Add(-1.5, -1, 0);
          pl.Add(-1.5, 1, 0);
          pl.Add(-0.5, 1, 0);
          pls.Add(pl.ToNurbsCurve());
        }
        {
          Polyline pl = new Polyline();
          pl.Add(-1.5, 0, 0);
          pl.Add(-0.5, 0, 0);
          pls.Add(pl.ToNurbsCurve());
        }

        {
          Polyline pl = new Polyline();
          pl.Add(0.5, 1, 0);
          pl.Add(1, -1, 0);
          pl.Add(1.5, 1, 0);
          pls.Add(pl.ToNurbsCurve());
        }
        return pls.ToArray();
      }

    }

    public class DoorSimple : Window
    {
      public Point2d StartPoint { get; set; }
      public double Width { get; set; }
      public double Height { get; set; }
      public Side OpenSide = Side.FrontRight;

      public DoorSimple(Point2d StartPoint, double Width, double Height, Side OpenSide)
      {
        this.StartPoint = StartPoint;
        this.Width = Width;
        this.Height = Height;
        this.OpenSide = OpenSide;
      }

      public enum Side
      {
        FrontRight, FrontLeft, BackRight, BackLeft

      }

      public Window Duplicate()
      {
        DoorSimple Result = new DoorSimple(StartPoint, Width, Height, OpenSide);
        return Result;
      }

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Door = new RealObject.Building("Door");

        Polyline PL = new Polyline(5);
        PL.Add(StartPoint.X, 0, StartPoint.Y);
        PL.Add(StartPoint.X + Width, 0, StartPoint.Y);
        PL.Add(StartPoint.X + Width, 0, StartPoint.Y + Height);
        PL.Add(StartPoint.X, 0, StartPoint.Y + Height);
        PL.Add(StartPoint.X, 0, StartPoint.Y);

        Door.Add("Body", Brep.CreatePlanarBreps(PL.ToNurbsCurve()));

        return Door;
      }
      public PlanObject.Member[] GetPlan(double WallThickness)
      {
        PlanObject.Member Result = new PlanObject.Member("Door");
        switch (this.OpenSide)
        {
          case Side.FrontLeft:
            Result.Content.Add(new Line(StartPoint.X, 0, 0, StartPoint.X, -Width, 0).ToNurbsCurve());
            Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X, 0, 0), Width), new Interval(-Math.PI / 2, 0)).ToNurbsCurve());
            return new[] { Result };
          case Side.FrontRight:
            Result.Content.Add(new Line(StartPoint.X + Width, 0, 0, StartPoint.X + Width, -Width, 0).ToNurbsCurve());
            Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X + Width, 0, 0), Width), new Interval(-Math.PI, -Math.PI / 2)).ToNurbsCurve());
            return new[] { Result };
          case Side.BackLeft:
            Result.Content.Add(new Line(StartPoint.X, WallThickness, 0, StartPoint.X, WallThickness + Width, 0).ToNurbsCurve());
            Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X, WallThickness, 0), Width), new Interval(0, Math.PI / 2)).ToNurbsCurve());
            return new[] { Result };
          case Side.BackRight:
            Result.Content.Add(new Line(StartPoint.X + Width, WallThickness, 0, StartPoint.X + Width, WallThickness + Width, 0).ToNurbsCurve());
            Result.Content.Add(new Arc(new Circle(new Point3d(StartPoint.X + Width, WallThickness, 0), Width), new Interval(Math.PI / 2, Math.PI)).ToNurbsCurve());
            return new[] { Result };
          default:
            return new[] { Result };
        }
      }


    }


    public class WindowGlassSimpleSingle : Window
    {
      public Point2d StartPoint { get; set; }
      public double Width { get; set; }
      public double Height { get; set; }

      public double FrameWidth = 30;
      public double FrameThickness = 30;
      public double GlassThickness = 5;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("WindowSingle");
        Brep[] breps = new Brep[2];

        Providers.GetGlassSimple(Width, Height, FrameWidth, FrameThickness, GlassThickness, out breps[0], out breps[1]);
        Result.Add("Glass", new Brep[] { breps[1] });
        Result.Add("Frame", new Brep[] { breps[0] });

        Result.Transform(Transform.Translation(StartPoint.X, FrameThickness, StartPoint.Y));

        return Result;
      }

      public WindowGlassSimpleSingle(Point2d StartPoint, double Width, double Height)
      {
        this.StartPoint = StartPoint;
        this.Width = Width;
        this.Height = Height;
      }

      public Window Duplicate()
      {
        return new WindowGlassSimpleSingle(this.StartPoint, this.Width, this.Height)
          {
            FrameWidth = this.FrameWidth,
            FrameThickness = this.FrameThickness,
            GlassThickness = this.GlassThickness
            };
      }

      public PlanObject.Member[] GetPlan(double WallThickness)
      {
        PlanObject.Member Result = new PlanObject.Member("WindowSingle");
        Result.Content.Add(new Line(StartPoint.X, 0, 0, StartPoint.X, WallThickness, 0).ToNurbsCurve());
        Result.Content.Add(new Line(StartPoint.X + Width, 0, 0, StartPoint.X + Width, WallThickness, 0).ToNurbsCurve());
        return new[] { Result };
      }

    }

    public class WindowGlassSimpleDouble : Window
    {
      public Point2d StartPoint { get; set; }
      public double Width { get; set; }
      public double Height { get; set; }

      public double FrameWidth = 30;
      public double FrameThickness = 30;
      public double GlassThickness = 5;

      public RealObject.Building GetBuilding()
      {
        RealObject.Building Result = new RealObject.Building("WindowDouble");
        Brep[] breps = new Brep[2];

        Providers.GetGlassSimple(Width / 2.0, Height, FrameWidth, FrameThickness, GlassThickness, out breps[0], out breps[1]);
        Result.Add("Glass", new Brep[] { breps[1] });
        Result.Add("Glass", GeneralHelper.TranslateBreps(new Brep[] { breps[1] }, new Point3d(Width / 2.0, FrameThickness, 0)));
        Result.Add("Frame", new Brep[] { breps[0] });
        Result.Add("Frame", GeneralHelper.TranslateBreps(new Brep[] { breps[0] }, new Point3d(Width / 2.0, FrameThickness, 0)));

        Result.Transform(Transform.Translation(StartPoint.X, FrameThickness, StartPoint.Y));

        return Result;
      }

      public WindowGlassSimpleDouble(Point2d StartPoint, double Width, double Height)
      {
        this.StartPoint = StartPoint;
        this.Width = Width;
        this.Height = Height;
      }

      public Window Duplicate()
      {
        return new WindowGlassSimpleDouble(this.StartPoint, this.Width, this.Height)
          {
            FrameWidth = this.FrameWidth,
            FrameThickness = this.FrameThickness,
            GlassThickness = this.GlassThickness
            };
      }

      public PlanObject.Member[] GetPlan(double WallThickness)
      {
        PlanObject.Member Result = new PlanObject.Member("WindowDouble");
        Result.Content.Add(new Line(StartPoint.X, 0, 0, StartPoint.X, WallThickness, 0).ToNurbsCurve());
        Result.Content.Add(new Line(StartPoint.X + Width, 0, 0, StartPoint.X + Width, WallThickness, 0).ToNurbsCurve());
        Result.Content.Add(new Line(StartPoint.X, WallThickness / 3, 0, StartPoint.X + Width * 3 / 4, WallThickness / 3, 0).ToNurbsCurve());
        Result.Content.Add(new Line(StartPoint.X + Width / 4, WallThickness * 2 / 3, 0, StartPoint.X + Width, WallThickness * 2 / 3, 0).ToNurbsCurve());
        Result.Content.Add(new Line(StartPoint.X + Width / 2, -WallThickness / 2, 0, StartPoint.X + Width / 2, WallThickness * 3 / 2, 0).ToNurbsCurve());
        return new[] { Result };
      }
    }

  }
  #endregion

  #region ..\CellObject.cs

  public class CellObject
  {
    //Magic number
    // 0 : No object.
    // -1: No result. This should not be used in IBoxel.
    // -2: Out of range.
    public interface IBoxel
    {
      void Init(int x, int y, int z);
      NeighborStatus GetNeighbor(int x, int y, int z);
      void Apply(IRule rule);
      IBoxel Duplicate();
    }

    public class Boxel : IBoxel
    {
      private int[,,] Content;
      private int X { get { return Content.GetLength(0) - 2; } }
      private int Y { get { return Content.GetLength(1) - 2; } }
      private int Z { get { return Content.GetLength(2) - 2; } }

      public void Init(int x, int y, int z)
      {
        Content = new int[x + 2, y + 2, z + 2];
        for (int cntx = 0; cntx &lt; x + 2; cntx++)
        {
          for (int cnty = 0; cnty &lt; y + 2; cnty++)
          {
            for (int cntz = 0; cntz &lt; z + 2; cntz++)
            {
              if (cntx &gt;= 1 &amp;&amp; cnty &gt;= 1 &amp;&amp; cntz &gt;= 1 &amp;&amp; cntx &lt; 1 + x &amp;&amp; cnty &lt; 1 + y &amp;&amp; cntz &lt; 1 + z)
              {
                Content[cntx, cnty, cntz] = 0;
              }
              else
              {
                Content[cntx, cnty, cntz] = -2;
              }

            }
          }
        }
      }

      public NeighborStatus GetNeighbor(int x, int y, int z)
      {
        NeighborStatus result = new NeighborStatus();
        int floor = z;
        result.LowerNeighbor = new int[] { Content[x, y, floor], Content[x + 1, y, floor], Content[x + 2, y, floor]
          , Content[x, y + 1, floor], Content[x + 2, y + 1, floor]
          , Content[x, y + 2, floor], Content[x + 1, y + 2, floor], Content[x + 2, y + 2, floor] };
        result.Lower = Content[x + 1, y + 1, floor];
        floor++;
        result.Neighbor = new int[] { Content[x, y, floor], Content[x + 1, y, floor], Content[x + 2, y, floor]
          , Content[x, y + 1, floor], Content[x + 2, y + 1, floor]
          , Content[x, y + 2, floor], Content[x + 1, y + 2, floor], Content[x + 2, y + 2, floor] };
        result.Self = Content[x + 1, y + 1, floor];
        floor++;
        result.UpperNeighbor = new int[] { Content[x, y, floor], Content[x + 1, y, floor], Content[x + 2, y, floor]
          , Content[x, y + 1, floor], Content[x + 2, y + 1, floor]
          , Content[x, y + 2, floor], Content[x + 1, y + 2, floor], Content[x + 2, y + 2, floor] };
        result.Upper = Content[x + 1, y + 1, floor];
        return result;
      }

      public int GetValue(int x, int y, int z)
      {
        return Content[x + 1, y + 1, z + 1];
      }

      public void SetValue(int x, int y, int z, int Value)
      {
        if (Value != -1)
        {
          Content[x + 1, y + 1, z + 1] = Value;
        }
      }

      public void Apply(IRule rule)
      {
        Boxel Origin = (Boxel) this.Duplicate();
        for (int cntx = 0; cntx &lt; X; cntx++)
        {
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntz = 0; cntz &lt; Z; cntz++)
            {
              this.SetValue(cntx, cnty, cntz, rule.GetStatus(Origin.GetNeighbor(cntx, cnty, cntz), cntx, cnty, cntz));
            }
          }
        }
      }

      public Boxel(int x, int y, int z)
      {
        this.Init(x, y, z);
      }

      public IBoxel Duplicate()
      {
        Boxel Result = new Boxel(X, Y, Z);
        for (int cntx = 0; cntx &lt; X; cntx++)
        {
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntz = 0; cntz &lt; Z; cntz++)
            {
              Result.SetValue(cntx, cnty, cntz, this.GetValue(cntx, cnty, cntz));
            }
          }
        }
        return Result;
      }

    }



    public class Honeycomb : IBoxel
    {
      private int[,,] Content;
      public int X { get { return Content.GetLength(0) - 2; } }
      public int Y { get { return Content.GetLength(1) - 2; } }
      public int Z { get { return Content.GetLength(2) - 2; } }

      public void Init(int x, int y, int z)
      {
        Content = new int[x + 2, y + 2, z + 2];
        for (int cntx = 0; cntx &lt; x + 2; cntx++)
        {
          for (int cnty = 0; cnty &lt; y + 2; cnty++)
          {
            for (int cntz = 0; cntz &lt; z + 2; cntz++)
            {
              if (cntx &gt;= 1 &amp;&amp; cnty &gt;= 1 &amp;&amp; cntz &gt;= 1 &amp;&amp; cntx &lt; 1 + x &amp;&amp; cnty &lt; 1 + y &amp;&amp; cntz &lt; 1 + z)
              {
                Content[cntx, cnty, cntz] = 0;
              }
              else
              {
                Content[cntx, cnty, cntz] = -2;
              }

            }
          }
        }
      }

      public NeighborStatus GetNeighbor(int x, int y, int z)
      {
        NeighborStatus result = new NeighborStatus();
        int shift = y % 2;
        int floor = z;
        result.LowerNeighbor = new int[] {Content[x + 1 + shift, y + 2, floor],Content[x + 2, y + 1, floor],Content[x + 1 + shift, y, floor]
          , Content[x + shift, y, floor], Content[x, y + 1, floor], Content[x + shift, y + 2, floor]
          };
        result.Lower = Content[x + 1, y + 1, floor];
        floor++;
        result.Neighbor = new int[] { Content[x + 1 + shift, y + 2, floor],Content[x + 2, y + 1, floor],Content[x + 1 + shift, y, floor]
          , Content[x + shift, y, floor], Content[x, y + 1, floor], Content[x + shift, y + 2, floor] };
        result.Self = Content[x + 1, y + 1, floor];
        floor++;
        result.UpperNeighbor = new int[] { Content[x + 1 + shift, y + 2, floor],Content[x + 2, y + 1, floor],Content[x + 1 + shift, y, floor]
          , Content[x + shift, y, floor], Content[x, y + 1, floor], Content[x + shift, y + 2, floor] };
        result.Upper = Content[x + 1, y + 1, floor];
        return result;
      }

      public int GetValue(int x, int y, int z)
      {
        return Content[x + 1, y + 1, z + 1];
      }

      public void SetValue(int x, int y, int z, int Value)
      {
        if (Value != -1)
        {
          Content[x + 1, y + 1, z + 1] = Value;
        }
      }

      public void Apply(IRule rule)
      {
        Honeycomb Origin = (Honeycomb) this.Duplicate();
        for (int cntx = 0; cntx &lt; X; cntx++)
        {
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntz = 0; cntz &lt; Z; cntz++)
            {
              this.SetValue(cntx, cnty, cntz, rule.GetStatus(Origin.GetNeighbor(cntx, cnty, cntz), cntx, cnty, cntz));
            }
          }
        }
      }

      public Honeycomb(int x, int y, int z)
      {
        this.Init(x, y, z);
      }

      public IBoxel Duplicate()
      {
        Honeycomb Result = new Honeycomb(X, Y, Z);
        for (int cntx = 0; cntx &lt; X; cntx++)
        {
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntz = 0; cntz &lt; Z; cntz++)
            {
              Result.SetValue(cntx, cnty, cntz, this.GetValue(cntx, cnty, cntz));
            }
          }
        }
        return Result;
      }

      public RealObject.Building GetBuildingSimple(double BuildingHeight = 1.0)
      {
        RealObject.Building Result = new RealObject.Building("HoneycombBuilding");

        Brep[] HexagonBase = GeneralHelper.CreateExtrusionCaped(new[] { GetHexagon().ToNurbsCurve() }, new Vector3d(0, 0, BuildingHeight));

        for (int cntx = 0; cntx &lt; X; cntx++)
        {
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntz = 0; cntz &lt; Z; cntz++)
            {
              int tmpnum = GetValue(cntx, cnty, cntz);
              if (tmpnum &gt; 0)
              {
                RealObject.Member ToAdd = new RealObject.Member("Type" + tmpnum);
                Brep[] NewHouse = GeneralHelper.TranslateBreps(HexagonBase, GetCenterPoint(cntx, cnty, BuildingHeight * cntz));
                ToAdd.Content = NewHouse;
                Result.Add(ToAdd);
              }
            }
          }
        }
        return Result;
      }

      public PlanObject.Building GetPlanSimple()
      {
        PlanObject.Building Result = new PlanObject.Building("HoneycombBuilding");
        Curve HexagonBase = GetHexagon().ToNurbsCurve();
        for (int cntz = 0; cntz &lt; Z; cntz++)
        {
          PlanObject.Floor FloorTmp = new PlanObject.Floor("F" + cntz);
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntx = 0; cntx &lt; X; cntx++)
            {
              int tmpnum = GetValue(cntx, cnty, cntz);
              if (tmpnum &gt; 0)
              {
                PlanObject.Member item = new PlanObject.Member("Type" + tmpnum);
                Curve cv = (Curve) HexagonBase.Duplicate();
                cv.Translate((Vector3d) GetCenterPoint(cntx, cnty, 0));
                item.Content.Add(cv);
                FloorTmp.Content.Add(item);
              }
            }
          }
          Result.Content.Add(FloorTmp);
        }
        return Result;
      }

      public int CountCellType(int target)
      {
        int Result = 0;
        for (int cntz = 0; cntz &lt; Z; cntz++)
        {
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntx = 0; cntx &lt; X; cntx++)
            {
              if (GetValue(cntx, cnty, cntz) == target) Result++;
            }
          }
        }
        return Result;

      }

      public string GetStatistics()
      {
        String Result = "";
        for (int cntz = 0; cntz &lt; Z; cntz++)
        {
          int[] FloorResult = new int[5];
          for (int i = 0; i &lt; FloorResult.GetLength(0); i++)
          {
            FloorResult[i] = 0;
          }
          for (int cnty = 0; cnty &lt; Y; cnty++)
          {
            for (int cntx = 0; cntx &lt; X; cntx++)
            {
              FloorResult[GetValue(cntx, cnty, cntz)]++;
            }
          }
          for (int i = 0; i &lt; FloorResult.GetLength(0); i++)
          {
            Result += FloorResult[i] + ",";
          }
          Result += "\n\r";
        }
        return Result;
      }

      public static Point2d GetCenterPoint(int x, int y)
      {
        return new Point2d(Math.Cos(Math.PI / 6.0) * (x * 2 + (y % 2)), (1 + Math.Cos(Math.PI / 3.0)) * y);
      }

      public static Point3d GetCenterPoint(int x, int y, double Height)
      {
        return new Point3d(Math.Cos(Math.PI / 6.0) * (x * 2 + (y % 2)), (1 + Math.Cos(Math.PI / 3.0)) * y, Height);
      }

      public static Vector2d GetVertex(int cnt)
      {
        return new Vector2d(Math.Sin(Math.PI / 3.0 * cnt), Math.Cos(Math.PI / 3.0 * cnt));
      }

      public static Polyline GetHexagon()
      {
        Polyline result = new Polyline();
        for (int i = 0; i &lt;= 6; i++)
        {
          Vector2d vrx = GetVertex(i);
          result.Add(vrx.X, vrx.Y, 0);
        }
        return result;
      }
    }


    public class NeighborStatus
    {
      public int[] Neighbor;
      public int Self;
      public int[] UpperNeighbor;
      public int Upper;
      public int[] LowerNeighbor;
      public int Lower;

      public int CountNeighbor(int target)
      {
        int result = 0;
        for (int i = 0; i &lt; Neighbor.GetLength(0); i++)
        {
          if (Neighbor[i] == target)
          {
            result++;
          }
        }
        return result;
      }

      public int[] GetNeighborByFloor(int cnt)
      {
        if (cnt == -1) { return LowerNeighbor; }
        else if (cnt == 1) { return UpperNeighbor; }
        else { return Neighbor; }
      }

      public int GetSelfByFloor(int cnt)
      {
        if (cnt == -1) { return Lower; }
        else if (cnt == 1) { return Upper; }
        else { return Self; }
      }

      public void SetNeighborByFloor(int cnt, int[] value)
      {
        if (cnt == -1) { LowerNeighbor = value; }
        else if (cnt == 1) { UpperNeighbor = value; }
        else { Neighbor = value; }
      }

      public void SetSelfByFloor(int cnt, int value)
      {
        if (cnt == -1) { Lower = value; }
        else if (cnt == 1) { Upper = value; }
        else { Self = value; }
      }

      public void SwapFloor(int A, int B)
      {
        int[] ANb = GetNeighborByFloor(A);
        int ASf = GetSelfByFloor(A);
        SetNeighborByFloor(A, GetNeighborByFloor(B));
        SetSelfByFloor(A, GetSelfByFloor(B));
        SetNeighborByFloor(B, ANb);
        SetSelfByFloor(B, ASf);
      }

      public NeighborStatus Duplicate()
      {
        NeighborStatus Result = new NeighborStatus();
        Result.Neighbor = this.Neighbor;
        Result.Self = this.Self;
        Result.UpperNeighbor = this.UpperNeighbor;
        Result.Upper = this.Upper;
        Result.LowerNeighbor = this.LowerNeighbor;
        Result.Lower = this.Lower;

        return Result;
      }
    }

    public interface IRule
    {
      int[] Paramater { get; set; }
      int GetStatus(NeighborStatus neighbor, int x, int y, int z);
    }

    public class Rules
    {
      public class Count : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int tmpnc = 0;
          for (int i = 3; i &lt; this.Paramater.GetLength(0); i++)
          {
            tmpnc += neighbor.CountNeighbor(this.Paramater[i]);
          }
          if (tmpnc &gt;= Paramater[1] &amp;&amp; tmpnc &lt;= this.Paramater[2])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public Count(int TargetNumber, int Result, int Min, int Max)
        {
          Paramater = new int[4] { Result, Min, Max, TargetNumber };
        }
        public Count(int[] TargetNumbers, int Result, int Min, int Max)
        {
          List&lt;int&gt; Results = new List&lt;int&gt;() { Result, Min, Max };
          foreach (int num in TargetNumbers)
          {
            Results.Add(num);
          }
          Paramater = Results.ToArray();

        }

      }

      public class CountRange : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int result = 0;
          for (int i = 1; i &lt; neighbor.Neighbor.GetLength(0); i++)
          {
            if (neighbor.Neighbor[i] &gt;= Paramater[0] &amp;&amp; neighbor.Neighbor[i] &lt;= Paramater[0])
            {
              result++;
            }
          }
          if (result &gt;= Paramater[2] &amp;&amp; result &lt;= this.Paramater[3])
          {
            return Paramater[1];
          }
          else
          {
            return -1;
          }
        }

        public CountRange(int TargetNumberMin, int TargetNumberMax, int Result, int Min, int Max)
        {
          Paramater = new int[5] { TargetNumberMin, TargetNumberMax, Result, Min, Max };
        }

      }


      public class CountOdd : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int tmpnc = 0;

          for (int i = 3; i &lt; this.Paramater.GetLength(0); i++)
          {
            int result = 0;
            for (int j = 1; j &lt; neighbor.Neighbor.GetLength(0); j += 2)
            {
              if (neighbor.Neighbor[j] == this.Paramater[i])
              {
                result++;
              }
            }

            tmpnc += result;
          }
          if (tmpnc &gt;= Paramater[1] &amp;&amp; tmpnc &lt;= this.Paramater[2])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public CountOdd(int TargetNumber, int Result, int Min, int Max)
        {
          Paramater = new int[4] { Result, Min, Max, TargetNumber };
        }
        public CountOdd(int[] TargetNumbers, int Result, int Min, int Max)
        {
          List&lt;int&gt; Results = new List&lt;int&gt;() { Result, Min, Max };
          foreach (int num in TargetNumbers)
          {
            Results.Add(num);
          }
          Paramater = Results.ToArray();

        }

      }


      public class CountEven : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int tmpnc = 0;

          for (int i = 3; i &lt; this.Paramater.GetLength(0); i++)
          {
            int result = 0;
            for (int j = 0; j &lt; neighbor.Neighbor.GetLength(0); j += 2)
            {
              if (neighbor.Neighbor[j] == this.Paramater[i])
              {
                result++;
              }
            }

            tmpnc += result;
          }
          if (tmpnc &gt;= Paramater[1] &amp;&amp; tmpnc &lt;= this.Paramater[2])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public CountEven(int TargetNumber, int Result, int Min, int Max)
        {
          Paramater = new int[4] { Result, Min, Max, TargetNumber };
        }
        public CountEven(int[] TargetNumbers, int Result, int Min, int Max)
        {
          List&lt;int&gt; Results = new List&lt;int&gt;() { Result, Min, Max };
          foreach (int num in TargetNumbers)
          {
            Results.Add(num);
          }
          Paramater = Results.ToArray();

        }

      }

      public class Max : IRule
      {
        public int[] Paramater { get; set; }
        public IRule[] Rules;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int lastResult = -1;
          foreach (IRule ir in Rules)
          {
            lastResult = Math.Max(lastResult, ir.GetStatus(neighbor, x, y, z));

          }
          return lastResult;
        }

        public Max(params IRule[] rules)
        {
          this.Rules = rules;
        }
      }

      public class Min : IRule
      {
        public int[] Paramater { get; set; }
        public IRule[] Rules;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int lastResult = int.MaxValue;
          foreach (IRule ir in Rules)
          {
            lastResult = Math.Min(lastResult, ir.GetStatus(neighbor, x, y, z));

          }
          return lastResult;
        }

        public Min(params IRule[] rules)
        {
          this.Rules = rules;
        }
      }

      public class Add : IRule
      {
        public int[] Paramater { get; set; }
        public IRule[] Rules;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int lastResult = 0;
          foreach (IRule ir in Rules)
          {
            lastResult = (lastResult + ir.GetStatus(neighbor, x, y, z));

          }
          return lastResult;
        }

        public Add(params IRule[] rules)
        {
          this.Rules = rules;
        }
      }

      public class ReplaceRange : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (neighbor.Self &gt;= Paramater[0] &amp;&amp; neighbor.Self &lt;= Paramater[1])
          {
            return Paramater[2];
          }
          else
          {
            return -1;
          }
        }

        public ReplaceRange(int Min, int Max, int Result)
        {
          Paramater = new int[] { Min, Max, Result };
        }
      }

      public class And : IRule
      {
        public int[] Paramater { get; set; }
        public IRule[] Rules;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int lastResult = -1;
          foreach (IRule ir in Rules)
          {
            if ((lastResult = ir.GetStatus(neighbor, x, y, z)) == -1)
            {
              return -1;
            }
          }
          return lastResult;
        }

        public And(params IRule[] rules)
        {
          this.Rules = rules;
        }

      }

      public class Or : IRule
      {
        public int[] Paramater { get; set; }
        public IRule[] Rules;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int tmpResult = -1;
          int Result = -1;
          foreach (IRule ir in Rules)
          {
            tmpResult = ir.GetStatus(neighbor, x, y, z);
            Result = tmpResult == -1 ? Result : tmpResult;
          }
          return Result;
        }

        public Or(params IRule[] rules)
        {
          this.Rules = rules;
        }

      }

      public class Swap : IRule
      {
        public int[] Paramater { get; set; }
        public IRule Rule;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          int Result = -1;
          if (Rule == null)
          {
            Result = neighbor.Self;
          }
          else
          {
            Result = Rule.GetStatus(neighbor, x, y, z);
          }

          if (Result == Paramater[0])
          {
            return Paramater[1];
          }
          else if (Result == Paramater[1])
          {
            return Paramater[0];
          }

          return Result;
        }

        public Swap(int A, int B, IRule rule)
        {
          this.Paramater = new int[] { A, B };
          this.Rule = rule;
        }

        public Swap(int A, int B)
        {
          this.Paramater = new int[] { A, B };
          this.Rule = null;
        }
      }

      public class CopyLowerFloor : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          return neighbor.Lower == -2 ? -1 : neighbor.Lower;
        }

        public CopyLowerFloor()
        {
        }

      }

      public class CopyUpperFloor : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          return neighbor.Upper == -2 ? -1 : neighbor.Upper;
        }

        public CopyUpperFloor()
        {
        }

      }

      public class BuildCylinder : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (x == Paramater[1] &amp;&amp; y == Paramater[2] &amp;&amp; z &lt; Paramater[3])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public BuildCylinder(int result, int x, int y, int height)
        {
          Paramater = new int[] { result, x, y, height };
        }

      }

      public class BuildCylinderRadius : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (Math.Pow(x - Paramater[1], 2) + Math.Pow(y - Paramater[2], 2) &lt;= Math.Pow(Paramater[4], 2) &amp;&amp; z &lt; Paramater[3])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public BuildCylinderRadius(int result, int x, int y, int height, int Radius)
        {
          Paramater = new int[] { result, x, y, height, Radius };
        }

      }

      public class BuildCylinderRadiusHoneycomb : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          Point2d current = Honeycomb.GetCenterPoint(x, y);
          Point2d target = Honeycomb.GetCenterPoint(Paramater[1], Paramater[2]);

          if (current.DistanceTo(target) &lt;= Paramater[4] &amp;&amp; z &lt; Paramater[3])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public BuildCylinderRadiusHoneycomb(int result, int x, int y, int height, int Radius)
        {
          Paramater = new int[] { result, x, y, height, Radius };
        }

      }

      public class BuildBox : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (x &gt;= Paramater[1] &amp;&amp; y &gt;= Paramater[2] &amp;&amp; z &gt;= Paramater[3] &amp;&amp;
            x &lt; Paramater[4] &amp;&amp; y &lt; Paramater[5] &amp;&amp; z &lt; Paramater[6])
          {
            return Paramater[0];
          }
          else
          {
            return -1;
          }
        }

        public BuildBox(int result, int x, int y, int z, int xLength, int yLength, int zLength)
        {
          Paramater = new int[] { result, x, y, z, x + xLength, y + yLength, z + zLength };
        }

      }

      public class Init : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          return Paramater[0];
        }

        public Init(int result)
        {
          Paramater = new int[] { result };
        }

      }

      public class Const : Init
      {
        public Const(int Result) : base(Result) { }
      }

      public class Self : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          foreach (int num in this.Paramater)
          {
            if (neighbor.Self == num) { return Paramater[0]; }
          }
          return -1;
        }

        public Self(params int[] result)
        {
          Paramater = result;
        }

      }

      public class Replace : IRule
      {
        public int[] Paramater { get; set; }

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (neighbor.Self == Paramater[0]) { return Paramater[1]; } else { return -1; }
        }

        public Replace(int origin, int result)
        {
          Paramater = new int[] { origin, result };
        }

      }

      public class Keep : IRule
      {
        public int[] Paramater { get; set; }
        public IRule Content;


        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          foreach (int num in Paramater)
          {
            if (neighbor.Self == num)
            {
              return -1;
            }
          }

          {
            if (Content != null)
            {
              return Content.GetStatus(neighbor, x, y, z);
            }
            else
            {
              return neighbor.Self;
            }
          }
        }

        public Keep(int target)
        {
          Paramater = new[] { target };
          this.Content = null;
        }

        public Keep(int target, IRule Content)
        {
          Paramater = new[] { target };
          this.Content = Content;
        }

        public Keep(int[] target, IRule Content)
        {
          Paramater = target;
          this.Content = Content;
        }

      }

      public class SwapFloor : IRule
      {
        public int[] Paramater { get; set; }
        public IRule Content;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          NeighborStatus newNeighbor = neighbor.Duplicate();
          newNeighbor.SwapFloor(Paramater[0], Paramater[1]);
          return Content.GetStatus(newNeighbor, x, y, z);
        }

        public SwapFloor(int A, int B, IRule Content)
        {
          this.Content = Content;
          Paramater = new[] { A, B };
        }
        public SwapFloor(int A, IRule Content) : this(A, 0, Content)
        {
        }
      }

      public class TargetFloor : IRule
      {
        public int[] Paramater { get; set; }
        public IRule Content;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (z == Paramater[0])
          {
            return Content.GetStatus(neighbor, x, y, z);
          }
          else
          {
            return -1;
          }

        }

        public TargetFloor(int target, IRule Content)
        {
          this.Content = Content;
          Paramater = new[] { target };
        }
      }

      public class Random : IRule
      {
        public int[] Paramater { get; set; }
        public IRule Content;
        public System.Random Rand;

        public int GetStatus(NeighborStatus neighbor, int x, int y, int z)
        {
          if (Rand.Next(100) &lt; Paramater[0])
          {
            return Content.GetStatus(neighbor, x, y, z);
          }
          else
          {
            return -1;
          }

        }

        public Random(int Probability, IRule rule) : this(Probability, rule, new System.Random()) { }

        public Random(int Probability, IRule rule, System.Random rd)
        {
          Paramater = new int[] { Probability };
          Content = rule;
          Rand = new System.Random(rd.Next());
        }

      }
    }
  }
  #endregion

  #region ..\GeneralHelper.cs

  public static class GeneralHelper
  {
    public static Brep FitTwoPoint(Brep Origin, Point3d Point1, Point3d Point2)
    {
      Vector3d Direction = Point2 - Point1;
      Brep Result = (Brep) Origin.Duplicate();
      double Angle;
      if (Direction.X == 0) { Angle = Direction.Y &gt; 0 ? Math.PI / 2.0 : -Math.PI / 2.0; }
      else
      {
        Angle = Math.Atan(Direction.Y / Direction.X);
        if (Direction.X &lt; 0) { Angle += Math.PI; }
      }

      Result.Rotate(Angle, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
      Result.Translate((Vector3d) Point1);
      return Result;
    }

    public static Transform FitTwoPoint(Point3d Point1, Point3d Point2)
    {
      Vector3d Direction = Point2 - Point1;
      Transform tf = Transform.Identity;
      double Angle;
      if (Direction.X == 0) { Angle = Direction.Y &gt; 0 ? Math.PI / 2.0 : -Math.PI / 2.0; }
      else
      {
        Angle = Math.Atan(Direction.Y / Direction.X);
        if (Direction.X &lt; 0) { Angle += Math.PI; }
      }
      tf *= Transform.Translation((Vector3d) Point1);
      tf *= Transform.Rotation(Angle, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
      return tf;
    }

    public static Brep[] CreateExtrusionCaped(Curve[] Section, Vector3d Direction)
    {
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();

      Brep[] BaseBrep = Brep.CreatePlanarBreps(Section);
      Result.AddRange(BaseBrep);
      foreach (Brep bp in BaseBrep)
      {
        Brep TempBrep = (Brep) bp.Duplicate();
        TempBrep.Translate(Direction);
        Result.Add(TempBrep);
      }
      foreach (Curve cv in Section)
      {
        Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(cv, Direction)));
      }
      //return Brep.CreateSolid(Result, Direction.Length/100.0);
      return Result.ToArray();
    }

    public static Brep[] DuplicateBreps(Brep[] Origin)
    {
      Brep[] Result = new Brep[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        if (Origin[i] == null) continue;
        Result[i] = (Brep) Origin[i].Duplicate();
      }
      return Result;
    }

    public static Brep CreateSweepCircle(Curve RailCurve, double Radius)
    {
      return CreateSweep(RailCurve, NurbsCurve.CreateFromCircle(new Circle(Radius)));
    }

    public static Brep CreateSweep(Curve RailCurve, Curve BaseShape)
    {
      Brep result = Brep.CreateFromSweep(RailCurve, GetCurveForSweep(BaseShape, RailCurve), true, 1e-2)[0];
      if (!RailCurve.IsClosed)
      {
        result.CapPlanarHoles(0);
      }
      return result;
    }
    public static Curve GetCurveForSweep(Curve Shape, Curve Rail)
    {
      Rail.Domain = new Interval(0, 1);
      Shape.Rotate(Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
      Shape.Rotate(GeneralHelper.GetCurvatureAsAngle(Rail, 0), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
      Shape.Translate((Vector3d) Rail.PointAtStart);
      return Shape;
    }

    public static double GetCurvatureAsAngle(Curve cv, double t)
    {
      Vector3d Curvature = cv.TangentAt(t);

      double angle = 0;
      if (Curvature.Y == 0) { angle = Math.PI / 2.0; }
      else
      {
        angle = -Math.Atan(Curvature.X / Curvature.Y);
        if (Curvature.X &lt; 0) { angle += Math.PI; }
      }
      return angle;
    }
    public static Brep[] TranslateBreps(Brep[] Origin, Point3d To)
    {
      return TranslateBreps(Origin, (Vector3d) To);
    }
    public static Brep[] TranslateBreps(Brep[] Origin, Vector3d To)
    {
      if (Origin == null) { return null; }
      Brep[] Result = new Brep[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        Brep TempBrep = (Brep) Origin[i].Duplicate();
        TempBrep.Translate(To);
        Result[i] = TempBrep;
      }
      return Result;
    }

    public static Brep[] RotateBreps(Brep[] Origin, double AngleRadians, Vector3d rotationAxis)
    {
      return RotateBreps(Origin, AngleRadians, rotationAxis, new Point3d(0, 0, 0));
    }

    public static Brep[] RotateBreps(Brep[] Origin, double AngleRadians, Vector3d rotationAxis, Point3d rotationCenter)
    {
      Brep[] Result = new Brep[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        Brep TempBrep = (Brep) Origin[i].Duplicate();
        TempBrep.Rotate(AngleRadians, rotationAxis, rotationCenter);
        Result[i] = TempBrep;
      }
      return Result;
    }

    public static Brep[] RepeatBrep(Brep Origin, Vector3d Vector, int Count)
    {
      return RepeatBrep(Origin, Vector, new Vector3d(0, 0, 0), Count, 1);
    }

    public static Brep[] RepeatBrep(Brep Origin, Vector3d Vector1, Vector3d Vector2, int CountX, int CountY)
    {
      return RepeatBrep(Origin, Vector1, Vector2, new Vector3d(0, 0, 0), CountX, CountY, 1);
    }

    public static Brep[] RepeatBrep(Brep[] Origin, Vector3d Vector, int Count)
    {
      return RepeatBrep(Origin, Vector, new Vector3d(0, 0, 0), Count, 1);
    }

    public static Brep[] RepeatBrep(Brep[] Origin, Vector3d Vector1, Vector3d Vector2, int CountX, int CountY)
    {
      return RepeatBrep(Origin, Vector1, Vector2, new Vector3d(0, 0, 0), CountX, CountY, 1);
    }

    public static Brep[] RepeatBrep(Brep Origin, Vector3d Vector1, Vector3d Vector2, Vector3d Vector3, int CountX, int CountY, int CountZ)
    {
      return RepeatBrep(new Brep[] { Origin }, Vector1, Vector2, Vector3, CountX, CountY, CountZ);
    }

    public static Brep[] RepeatBrep(Brep[] Origin, Vector3d Vector1, Vector3d Vector2, Vector3d Vector3, int CountX, int CountY, int CountZ)
    {
      Brep[] Result = new Brep[CountX * CountY * CountZ * Origin.GetLength(0)];
      for (int i = 0; i &lt; CountZ; i++)
      {
        for (int j = 0; j &lt; CountY; j++)
        {
          for (int k = 0; k &lt; CountX; k++)
          {
            for (int l = 0; l &lt; Origin.GetLength(0); l++)
            {
              Brep tempBrep = (Brep) Origin[l].Duplicate();
              tempBrep.Translate(Vector1 * k + Vector2 * j + Vector3 * i);
              Result[i * CountX * CountY * Origin.GetLength(0) + j * CountX * Origin.GetLength(0) + k * Origin.GetLength(0) + l] = tempBrep;
            }
          }
        }
      }
      return Result;
    }

    public static Brep[] RotateBrep(Brep[] origin, double angleRadians, Vector3d rotationAxis, Point3d rotationCenter)
    {
      Brep[] Result = new Brep[origin.GetLength(0)];
      for (int i = 0; i &lt; origin.GetLength(0); i++)
      {
        Brep bp = (Brep) origin[i].Duplicate();
        bp.Rotate(angleRadians, rotationAxis, rotationCenter);
        Result[i] = bp;
      }
      return Result;
    }

    public static Brep[] DuplicateBrep(Brep[] origin)
    {
      Brep[] result = new Brep[origin.GetLength(0)];
      for (int i = 0; i &lt; origin.GetLength(0); i++)
      {
        result[i] = (Brep) origin[i].Duplicate();
      }
      return result;
    }
  }
  #endregion

  #region ..\GraphObject.cs

  public class GraphObject
  {
    public class Path
    {
      public string Name { get { return ContentMember.ToString(); } set { ContentMember.SetName(value); } }
      public RealObject.Member ContentMember;
      public double Length;

      public static Path CreateFromPipeSimple(double[] Distance, double[] Radius)
      {
        return new Path() { ContentMember = new Brep[] { Providers.GetPipeSimple(Distance, Radius) }, Length = Distance[Distance.GetLength(0) - 1] - Distance[0] };
      }

      public static Path CreateFromPipeHead(double[] Distance, double[] Radius)
      {
        return new Path() { ContentMember = new Brep[] { Providers.GetPipeHead(Distance, Radius) }, Length = Distance[Distance.GetLength(0) - 1] - Distance[0] };
      }

      public static Path CreateFromRegularPolygonTower(int count, double Radius, double Height)
      {
        Brep bp = Providers.GetRegularPolygonTower(count, Radius, Height, true);
        bp.Transform(Transform.ChangeBasis(Plane.WorldYZ, Plane.WorldXY));
        return new Path() { ContentMember = new Brep[] { bp }, Length = Height };
      }
    }

    public class Node
    {
      public string Name { get { return ContentMember.ToString(); } set { ContentMember.SetName(value); } }
      public Path Target1;
      public Path Target2;
      public Point3d Target1ConnectionPoint = new Point3d(0, 0, 0);
      public Point3d Target2ConnectionPoint = new Point3d(0, 0, 0);
      public double Radius;
      public RealObject.Member ContentMember;

      public double RotationAngleX { get { return _RotationAngleX; } set { _RotationAngleX = Math.Max(RotationAngleXLimitation.Min, Math.Min(RotationAngleXLimitation.Max, value % (Math.PI * 2.0))); } }
      private double _RotationAngleX = 0;
      public Interval RotationAngleXLimitation = new Interval(0, Math.PI * 2.0);

      public double RotationAngleY { get { return _RotationAngleY; } set { _RotationAngleY = Math.Max(RotationAngleYLimitation.Min, Math.Min(RotationAngleYLimitation.Max, value % (Math.PI * 2.0))); } }
      private double _RotationAngleY = 0;
      public Interval RotationAngleYLimitation = new Interval(0, Math.PI * 2.0);

      public double RotationAngleZ { get { return _RotationAngleZ; } set { _RotationAngleZ = Math.Max(RotationAngleZLimitation.Min, Math.Min(RotationAngleZLimitation.Max, value % (Math.PI * 2.0))); } }
      private double _RotationAngleZ = 0;
      public Interval RotationAngleZLimitation = new Interval(0, Math.PI * 2.0);

      public Path GetPathOtherThan(Path that)
      {
        if (that == Target1) { return Target2; }
        else if (that == Target2) { return Target1; }
        else { return new Path(); }
      }

      public Point3d GetConnectionPoint(Path that)
      {
        if (that == Target1) { return new Point3d(Target1ConnectionPoint); }
        else if (that == Target2) { return new Point3d(Target2ConnectionPoint); }
        else { return new Point3d(0, 0, 0); }
      }

      public static Node CreateFromSphere(double rad, double len)
      {
        if (len &gt; 0)
        {
          return new Node() { Radius = len / 2.0, ContentMember = new Brep[] { Brep.CreateFromSphere(new Sphere(new Point3d(0, 0, 0), rad)) } };
        }
        else
        {
          return new Node() { Radius = 0, ContentMember = new Brep[0] };
        }
      }
    }

    public class Graph
    {
      public Path RootPath;//You can set this length to zero to set Node as root.
      private Dictionary&lt;Path, List&lt;Node&gt;&gt; NodesDic = new Dictionary&lt;Path, List&lt;Node&gt;&gt;();
      public Point3d Position;
      public double RotationAngleX = 0;
      public double RotationAngleY = 0;
      public double RotationAngleZ = 0;
      public double AddScale = 1.0;


      public Path[] Paths
      {
        get
        {
          List&lt;Path&gt; Result = new List&lt;Path&gt;();
          Result.Add(RootPath);
          foreach (KeyValuePair&lt;Path, List&lt;Node&gt;&gt; kvp in NodesDic)
          {
            foreach (Node nd in kvp.Value)
            {
              Path pathtoadd = nd.GetPathOtherThan(kvp.Key);
              if (!Result.Contains(pathtoadd)) Result.Add(pathtoadd);
            }
          }
          return Result.ToArray();
        }
      }
      public Node[] Nodes
      {
        get
        {
          List&lt;Node&gt; Result = new List&lt;Node&gt;();
          foreach (KeyValuePair&lt;Path, List&lt;Node&gt;&gt; kvp in NodesDic)
          {
            foreach (Node nd in kvp.Value)
            {
              Result.Add(nd);
            }
          }
          return Result.ToArray();
        }
      }

      public Node Add(Path PathToConnect, Path PathToAdd)
      {
        return Add(PathToConnect, new Point3d(PathToConnect.Length / AddScale, 0, 0), PathToAdd, new Node() { ContentMember = new Brep[0], Radius = 0 });
      }

      public Node Add(Path PathToConnect, Path PathToAdd, double rad, double len)
      {
        return Add(PathToConnect, new Point3d(PathToConnect.Length / AddScale, 0, 0), PathToAdd, Node.CreateFromSphere(rad, len));
      }

      public Node Add(Path PathToConnect, Point3d ConnectionPoint, Path PathToAdd, Node node)
      {
        node.Target1 = PathToConnect;
        node.Target1ConnectionPoint = ConnectionPoint * AddScale;
        node.Target2 = PathToAdd;

        Brep[] newbp;
        newbp = new Brep[PathToAdd.ContentMember.Content.GetLength(0)];
        for (int i = 0; i &lt; PathToAdd.ContentMember.Content.GetLength(0); i++)
        {
          newbp[i] = (Brep) PathToAdd.ContentMember.Content[i].Duplicate();
          newbp[i].Scale(AddScale);
        }
        PathToAdd.ContentMember.Content = newbp;
        PathToAdd.Length *= AddScale;

        newbp = new Brep[PathToConnect.ContentMember.Content.GetLength(0)];
        for (int i = 0; i &lt; node.ContentMember.Content.GetLength(0); i++)
        {
          newbp[i] = (Brep) node.ContentMember.Content[i].Duplicate();
          newbp[i].Scale(AddScale);
        }
        node.ContentMember.Content = newbp;

        node.Radius *= AddScale;

        NodesDic[PathToConnect].Add(node);
        NodesDic.Add(PathToAdd, new List&lt;Node&gt;());
        return node;
      }

      public void MoveRandom()
      {
        MoveRandom(new Random());
      }


      public void MoveRandom(Random rd)
      {
        foreach (Node nd in Nodes)
        {
          nd.RotationAngleX = nd.RotationAngleXLimitation.Min + nd.RotationAngleXLimitation.Length * rd.NextDouble();
          nd.RotationAngleY = nd.RotationAngleYLimitation.Min + nd.RotationAngleYLimitation.Length * rd.NextDouble();
          nd.RotationAngleZ = nd.RotationAngleZLimitation.Min + nd.RotationAngleZLimitation.Length * rd.NextDouble();
        }
      }

      public Graph(Path Root, Point3d Position)
        : this(Root, Position, false)
      {
      }

      public Graph(Path Root, Point3d ObjectPosition, bool CanRootMoveFreely)
        : this(Root, ObjectPosition, CanRootMoveFreely, 1.0)
      {
      }

      public Graph(Path Root, Point3d ObjectPosition, bool CanRootMoveFreely, double Scale)
      {
        this.AddScale = Scale;
        this.Position = ObjectPosition * AddScale;

        Brep[] newbp;
        newbp = new Brep[Root.ContentMember.Content.GetLength(0)];
        for (int i = 0; i &lt; Root.ContentMember.Content.GetLength(0); i++)
        {
          newbp[i] = (Brep) Root.ContentMember.Content[i].Duplicate();
          newbp[i].Scale(AddScale);
        }
        Root.ContentMember.Content = newbp;
        Root.Length *= AddScale;

        if (CanRootMoveFreely)
        {
          RootPath = new Path() { Length = 0 };
          NodesDic.Add(RootPath, new List&lt;Node&gt;() { new Node() { Target1 = RootPath, Target2 = Root, Radius = 0, ContentMember = new Brep[0] } });
        }
        else
        {
          RootPath = Root;
          NodesDic.Add(Root, new List&lt;Node&gt;());
        }
      }

      public Brep[] GetBrep()
      {
        Plane newpl = Plane.WorldXY;
        newpl.Transform(Transform.Rotation(RotationAngleX, newpl.XAxis, newpl.Origin));
        newpl.Transform(Transform.Rotation(RotationAngleY, newpl.YAxis, newpl.Origin));
        newpl.Transform(Transform.Rotation(RotationAngleZ, newpl.ZAxis, newpl.Origin));
        newpl.Origin = this.Position;
        List&lt;Brep[]&gt; ResultPre = GetBrepFromPath(this.RootPath, newpl);
        List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
        foreach (Brep[] bps in ResultPre)
        {
          Result.AddRange(bps);
        }
        return Result.ToArray();
      }

      [System.Obsolete("This is old version. Use same function with Plane.")]
      private List&lt;Brep[]&gt; GetBrepFromPath(Path p, Point3d crtpos, double crtangx, double crtangy, double crtangz)
      {
        List&lt;Brep[]&gt; Result = new List&lt;Brep[]&gt;();
        Brep[] TempBreps = new Brep[p.ContentMember.Content.GetLength(0)];
        int cnt = 0;
        foreach (Brep bp in p.ContentMember.Content)
        {
          Brep tempbp = (Brep) bp.Duplicate();
          tempbp.Rotate(crtangx, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
          tempbp.Rotate(crtangy, new Vector3d(0, 1, 0), new Point3d(0, 0, 0));
          tempbp.Rotate(crtangz, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
          tempbp.Translate((Vector3d) crtpos);
          TempBreps[cnt] = tempbp;
          cnt++;
        }
        Result.Add(TempBreps);
        foreach (Node nd in this.NodesDic[p])
        {
          Point3d cntpt = nd.GetConnectionPoint(p) + new Point3d(nd.Radius, 0, 0);
          cntpt.Transform(Transform.Rotation(crtangx, new Vector3d(1, 0, 0), new Point3d(0, 0, 0)));
          cntpt.Transform(Transform.Rotation(crtangy, new Vector3d(0, 1, 0), new Point3d(0, 0, 0)));
          cntpt.Transform(Transform.Rotation(crtangz, new Vector3d(0, 0, 1), new Point3d(0, 0, 0)));

          Point3d ndpt = new Point3d(nd.Radius, 0, 0);
          ndpt.Transform(Transform.Rotation(crtangx + nd.RotationAngleX, new Vector3d(1, 0, 0), new Point3d(0, 0, 0)));
          ndpt.Transform(Transform.Rotation(crtangy + nd.RotationAngleY, new Vector3d(0, 1, 0), new Point3d(0, 0, 0)));
          ndpt.Transform(Transform.Rotation(crtangz + nd.RotationAngleZ, new Vector3d(0, 0, 1), new Point3d(0, 0, 0)));

          Brep[] NodeBrep = new Brep[nd.ContentMember.Content.GetLength(0)];
          for (int i = 0; i &lt; nd.ContentMember.Content.GetLength(0); i++)
          {
            if (nd.ContentMember.Content[i] == null) { continue; }
            Brep tbp = (Brep) nd.ContentMember.Content[i].Duplicate();
            tbp.Translate((Vector3d) (crtpos + cntpt));
            NodeBrep[i] = tbp;
          }
          Result.Add(NodeBrep);

          Result.AddRange(GetBrepFromPath(nd.GetPathOtherThan(p), crtpos + cntpt + ndpt, crtangx + nd.RotationAngleX, crtangy + nd.RotationAngleY, crtangz + nd.RotationAngleZ));
        }
        return Result;
      }

      private List&lt;Brep[]&gt; GetBrepFromPath(Path p, Plane pl)
      {
        List&lt;Brep[]&gt; Result = new List&lt;Brep[]&gt;();
        Brep[] TempBreps = new Brep[p.ContentMember.Content.GetLength(0)];
        int cnt = 0;
        foreach (Brep bp in p.ContentMember.Content)
        {
          Brep tempbp = (Brep) bp.Duplicate();
          tempbp.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));
          TempBreps[cnt] = tempbp;
          cnt++;
        }
        Result.Add(TempBreps);
        foreach (Node nd in this.NodesDic[p])
        {
          Point3d cntpt = nd.GetConnectionPoint(p) + new Point3d(nd.Radius, 0, 0);
          cntpt.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));

          Plane newpl = new Plane(pl);
          newpl.Transform(Transform.Rotation(nd.RotationAngleX, newpl.XAxis, newpl.Origin));
          newpl.Transform(Transform.Rotation(nd.RotationAngleY, newpl.YAxis, newpl.Origin));
          newpl.Transform(Transform.Rotation(nd.RotationAngleZ, newpl.ZAxis, newpl.Origin));
          newpl.Origin = cntpt;

          Point3d ndpt = (Point3d) (newpl.XAxis * nd.Radius);

          Brep[] NodeBrep = new Brep[nd.ContentMember.Content.GetLength(0)];
          for (int i = 0; i &lt; nd.ContentMember.Content.GetLength(0); i++)
          {
            if (nd.ContentMember.Content[i] == null) { continue; }
            Brep tbp = (Brep) nd.ContentMember.Content[i].Duplicate();
            tbp.Transform(Transform.ChangeBasis(newpl, Plane.WorldXY));
            NodeBrep[i] = tbp;
          }
          Result.Add(NodeBrep);

          Result.AddRange(GetBrepFromPath(nd.GetPathOtherThan(p), newpl));
        }
        return Result;
      }

      public RealObject.Building GetMember()
      {
        RealObject.Building Result = new RealObject.Building("Graph");
        Plane newpl = Plane.WorldXY;
        newpl.Transform(Transform.Rotation(RotationAngleX, newpl.XAxis, newpl.Origin));
        newpl.Transform(Transform.Rotation(RotationAngleY, newpl.YAxis, newpl.Origin));
        newpl.Transform(Transform.Rotation(RotationAngleZ, newpl.ZAxis, newpl.Origin));
        newpl.Origin = this.Position;
        Result.Add(GetMemberFromPath(this.RootPath, newpl).ToArray());
        return Result;
      }

      private List&lt;RealObject.Member&gt; GetMemberFromPath(Path p, Plane pl)
      {
        List&lt;RealObject.Member&gt; Result = new List&lt;RealObject.Member&gt;();

        int cnt = 0;
        RealObject.Member newmember = p.ContentMember.Duplicate();
        foreach (Brep bp in newmember.Content)
        {
          bp.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));
          newmember.Content[cnt] = bp;
          cnt++;
        }
        Result.Add(newmember);

        foreach (Node nd in this.NodesDic[p])
        {
          Point3d cntpt = nd.GetConnectionPoint(p) + new Point3d(nd.Radius, 0, 0);
          cntpt.Transform(Transform.ChangeBasis(pl, Plane.WorldXY));

          Plane newpl = new Plane(pl);
          newpl.Transform(Transform.Rotation(nd.RotationAngleX, newpl.XAxis, newpl.Origin));
          newpl.Transform(Transform.Rotation(nd.RotationAngleY, newpl.YAxis, newpl.Origin));
          newpl.Transform(Transform.Rotation(nd.RotationAngleZ, newpl.ZAxis, newpl.Origin));
          newpl.Origin = cntpt;

          Point3d ndpt = (Point3d) (newpl.XAxis * nd.Radius);

          RealObject.Member newmember2 = nd.ContentMember.Duplicate();
          for (int i = 0; i &lt; nd.ContentMember.Content.GetLength(0); i++)
          {
            if (nd.ContentMember.Content[i] == null) { continue; }
            Brep tbp = (Brep) nd.ContentMember.Content[i].Duplicate();
            tbp.Transform(Transform.ChangeBasis(newpl, Plane.WorldXY));
            newmember2.Content[i] = tbp;
          }
          Result.Add(newmember2);

          Result.AddRange(GetMemberFromPath(nd.GetPathOtherThan(p), newpl));
        }
        return Result;
      }


      public static Graph GetHumanBody(double Height)
      {
        Graph Result = new Graph(Path.CreateFromPipeSimple(new double[] { 0, 15, 30 }, new double[] { 20, 20, 15 }), new Point3d(0, 0, 165), false, Height / 260.0);
        Result.RotationAngleY = -Math.PI / 2.0;
        List&lt;Node&gt; HumanNodes = new List&lt;Node&gt;();

        Path chest = Path.CreateFromPipeSimple(new double[] { 0, 40, 50 }, new double[] { 15, 20, 10 });
        HumanNodes.Add(Result.Add(Result.RootPath, chest, 15, 15));
        HumanNodes[0].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);
        HumanNodes[0].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);
        HumanNodes[0].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);

        Path head = Path.CreateFromPipeHead(new double[] { 0, 30, 45 }, new double[] { 12, 15 });
        HumanNodes.Add(Result.Add(chest, head, 7.5, 7.5));
        HumanNodes[1].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 80, Math.PI / 180.0 * 80);
        HumanNodes[1].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);
        HumanNodes[1].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 15, Math.PI / 180.0 * 15);

        Path handR1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 30, 45 }, new double[] { 7.5, 9.0, 7, 6 });
        HumanNodes.Add(Result.Add(chest, new Point3d(40, 23, 0), handR1, Node.CreateFromSphere(8, 6)));
        HumanNodes[2].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

        Path handR2 = Path.CreateFromPipeSimple(new double[] { 0, 20, 40 }, new double[] { 7, 8.0, 7 });
        HumanNodes.Add(Result.Add(handR1, handR2, 7.5, 4.0));
        HumanNodes[3].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

        Path handR3 = new Path() { ContentMember = new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, 20), new Interval(-6, 6), new Interval(-1.5, 1.5))) } };
        HumanNodes.Add(Result.Add(handR2, handR3, 4, 3));
        HumanNodes[4].RotationAngleZLimitation = new Interval(0, 0);
        HumanNodes[4].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);
        HumanNodes[4].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);

        Path handL1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 30, 45 }, new double[] { 7.5, 9.0, 7, 6 });
        HumanNodes.Add(Result.Add(chest, new Point3d(40, -23, 0), handL1, Node.CreateFromSphere(8, 6)));
        HumanNodes[5].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

        Path handL2 = Path.CreateFromPipeSimple(new double[] { 0, 20, 40 }, new double[] { 7, 8.0, 7 });
        HumanNodes.Add(Result.Add(handL1, handL2, 7.5, 4.0));
        HumanNodes[6].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);

        Path handL3 = new Path() { ContentMember = new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, 20), new Interval(-6, 6), new Interval(-1.5, 1.5))) } };
        HumanNodes.Add(Result.Add(handL2, handL3, 4, 3));
        HumanNodes[7].RotationAngleZLimitation = new Interval(0, 0);
        HumanNodes[7].RotationAngleYLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);
        HumanNodes[7].RotationAngleXLimitation = new Interval(-Math.PI / 180.0 * 45, Math.PI / 180.0 * 45);

        Path legR1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 40, 60 }, new double[] { 7.5, 10.0, 7.5, 7.0 });
        HumanNodes.Add(Result.Add(Result.RootPath, new Point3d(-1.5, 15, 0), legR1, Node.CreateFromSphere(7.5, 6)));
        HumanNodes[8].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);
        HumanNodes[8].RotationAngleYLimitation = new Interval(Math.PI * 0.5, Math.PI * 1.5);
        HumanNodes[8].RotationAngleXLimitation = new Interval(0, 0);

        Path legR2 = Path.CreateFromPipeSimple(new double[] { 0, 15.0, 45, 65 }, new double[] { 7.5, 8.5, 7.5, 6.5 });
        HumanNodes.Add(Result.Add(legR1, legR2, 6, 5));
        HumanNodes[9].RotationAngleZLimitation = new Interval(0, 0);
        HumanNodes[9].RotationAngleYLimitation = new Interval(-Math.PI, 0);
        HumanNodes[9].RotationAngleXLimitation = new Interval(-Math.PI, 0);

        Brep shoes = Providers.GetPipeHalf(new double[] { -10, 20, 30 }, new double[] { 9, 9, 0 });
        shoes.Rotate(-Math.PI / 2.0, new Vector3d(0, 1, 0), new Point3d(0, 0, 0));
        shoes.Translate(11, 0, 0);

        Path legR3 = new Path() { ContentMember = new Brep[] { (Brep) shoes.Duplicate() } };
        HumanNodes.Add(Result.Add(legR2, legR3, 4, 2.5));
        HumanNodes[10].RotationAngleZLimitation = new Interval(0, 0);
        HumanNodes[10].RotationAngleYLimitation = new Interval(-Math.PI / 4.0, Math.PI / 4.0);
        HumanNodes[10].RotationAngleXLimitation = new Interval(-Math.PI / 2.0, Math.PI / 2.0);

        Path legL1 = Path.CreateFromPipeSimple(new double[] { 0, 15, 40, 60 }, new double[] { 7.5, 10.0, 7.5, 7.0 });
        HumanNodes.Add(Result.Add(Result.RootPath, new Point3d(-1.5, -15, 0), legL1, Node.CreateFromSphere(7.5, 6)));
        HumanNodes[11].RotationAngleZLimitation = new Interval(-Math.PI / 180.0 * 40, Math.PI / 180.0 * 40);
        HumanNodes[11].RotationAngleYLimitation = new Interval(Math.PI * 0.5, Math.PI * 1.5);
        HumanNodes[11].RotationAngleXLimitation = new Interval(0, 0);

        Path legL2 = Path.CreateFromPipeSimple(new double[] { 0, 15.0, 45, 65 }, new double[] { 7.5, 8.5, 7.5, 6.5 });
        HumanNodes.Add(Result.Add(legL1, legL2, 6, 5));
        HumanNodes[12].RotationAngleZLimitation = new Interval(0, 0);
        HumanNodes[12].RotationAngleYLimitation = new Interval(-Math.PI, 0);
        HumanNodes[12].RotationAngleXLimitation = new Interval(-Math.PI, 0);

        Path legL3 = new Path() { ContentMember = new Brep[] { (Brep) shoes.Duplicate() } };
        HumanNodes.Add(Result.Add(legL2, legL3, 4, 2.5));
        HumanNodes[13].RotationAngleZLimitation = new Interval(0, 0);
        HumanNodes[13].RotationAngleYLimitation = new Interval(-Math.PI / 4.0, Math.PI / 4.0);
        HumanNodes[13].RotationAngleXLimitation = new Interval(-Math.PI / 2.0, Math.PI / 2.0);

        return Result;

      }

    }
  }
  #endregion

  #region ..\LSystem.cs

  public class LSystem
  {
    public Rule[] Rules;
    public Sequence Tree;
    public Sequence InitialState;
    public int Generation { get; private set; }
    public Dictionary&lt;string, BodyType&gt; BodyTypes { get; private set; }

    public void ApplyRules(int cnt)
    {
      for (int i = 0; i &lt; cnt; i++)
      {
        ApplyRules();
      }
    }

    public void ApplyRules()
    {
      Generation++;
      foreach (Rule rl in Rules)
      {
        Tree = Tree.ApplyRule(rl, Generation);
      }
    }

    public LSystem(Sequence Initial, Rule[] Rules)
    {
      InitialState = Initial.Duplicate();
      Tree = Initial.Duplicate();
      this.Rules = Rules;
      Generation = 0;
      BodyTypes = new Dictionary&lt;string, BodyType&gt;();
    }

    public void RegisterBodyType(params BodyType[] bts)
    {
      foreach (BodyType bt in bts)
      {
        BodyTypes.Add(bt.Name, bt);
      }
    }

    public class BodyType
    {
      public readonly string Name;
      public BodyType(string name) { Name = name; }
      public override string ToString() { return Name; }
    }

    public class Sequence
    {
      public List&lt;Body&gt; Content = new List&lt;Body&gt;();

      public Sequence()
      {
      }

      public Sequence(params BodyType[] BodyTypes)
      {
        for (int i = 0; i &lt; BodyTypes.Count(); i++)
        {
          Content.Add(new Body(BodyTypes[i]));
        }
      }

      public Sequence Duplicate(int Gen)
      {
        List&lt;Body&gt; Result = new List&lt;Body&gt;();
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.Add(Content[i].Duplicate(Gen));
        }
        return new Sequence() { Content = Result };
      }

      public Sequence Duplicate()
      {
        List&lt;Body&gt; Result = new List&lt;Body&gt;();
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.Add(Content[i].Duplicate());
        }
        return new Sequence() { Content = Result };
      }

      public Sequence ApplyRule(Rule rl, int CurrentGeneration)
      {
        List&lt;Body&gt; Result = new List&lt;Body&gt;();
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          if (Content[i].BodyType == rl.Target)
          {
            Result.AddRange(rl.Result.Duplicate(CurrentGeneration).Content);
          }
          else
          {
            Result.Add(Content[i].ApplyRule(rl, CurrentGeneration));
          }
        }
        return new Sequence() { Content = Result };
      }

      public override string ToString()
      {
        string result = "";
        for (int i = 0; i + 1 &lt; Content.Count(); i++)
        {
          result += Content[i].ToString();
          result += ",";
        }
        result += Content[Content.Count() - 1].ToString();
        return result;
      }

    }

    public class Body
    {
      public int Generation;
      public Sequence[] Child = new Sequence[0];
      public BodyType BodyType;

      public Body(BodyType type) { this.BodyType = type; }

      public Body Duplicate()
      {
        return Duplicate(this.Generation);
      }


      public Body Duplicate(int Gen)
      {
        Sequence[] NewChild = new Sequence[Child.GetLength(0)];
        for (int i = 0; i &lt; Child.GetLength(0); i++)
        {
          NewChild[i] = Child[i].Duplicate(Gen);
        }
        return new Body(this.BodyType) { Child = NewChild, Generation = Gen };
      }

      public Body ApplyRule(Rule rl, int CurrentGeneration)
      {
        Sequence[] NewChild = new Sequence[Child.GetLength(0)];
        for (int i = 0; i &lt; Child.GetLength(0); i++)
        {
          NewChild[i] = Child[i].ApplyRule(rl, CurrentGeneration);
        }
        return new Body(this.BodyType) { Child = NewChild, Generation = this.Generation };
      }

      public override string ToString()
      {
        string result = "";
        result += BodyType.ToString();
        for (int i = 0; i &lt; Child.GetLength(0); i++)
        {
          result += "[";
          result += Child[i].ToString();
          result += "]";
        }
        result += "" + this.Generation;
        return result;
      }

    }

    public interface Rule
    {
      BodyType Target { get; set; }
      Sequence Result { get; }
    }

    public class RuleSimple : Rule
    {
      public BodyType Target { get; set; }
      public Sequence Result { get; set; }
    }

    public class RuleProbability : Rule
    {
      public BodyType Target { get; set; }
      public Sequence Result { get { return GetResult(); } }

      private Dictionary&lt;Sequence, double&gt; Rules;
      private Random rand;

      public RuleProbability()
        : this(new Random())
      {
      }

      public RuleProbability(Random rd)
      {
        rand = rd;
        Rules = new Dictionary&lt;Sequence, double&gt;();
      }
      public void AddSequence(Sequence Content, double Rate)
      {
        Rules.Add(Content.Duplicate(), Rate);
      }

      private Sequence GetResult()
      {
        double randResult = rand.NextDouble();
        double PosSum = 0.0;

        foreach (var kvp in Rules)
        {
          if (PosSum &lt;= randResult &amp;&amp; randResult &lt; PosSum + kvp.Value)
          {
            return kvp.Key;
          }
          PosSum += kvp.Value;
        }
        return new Sequence() { Content = new List&lt;Body&gt;() { new Body(Target) } };
      }
    }
  }
  #endregion

  #region ..\PanelBuilder.cs

  public class PanelBuilder
  {
    public Rhino.RhinoDoc Document;
    public Random Rand;
    public string CurrentDirectory;
    public int CurrentLayer = 0;

    public PanelBuilder(RhinoDoc Doc, string currentDirectory)
    {
      Document = Doc;
      Rand = new Random();
      this.CurrentDirectory = currentDirectory;
    }

    public void Add(string name, Color col, params Brep[] content)
    {
      int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
      if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
      int GroupIndex = Document.Groups.Add(name + Rand.Next(100000));

      Material m = new Material();
      m.DiffuseColor = col;
      int matidx = Document.Materials.Add(m);

      foreach (Brep bp in content)
      {
        ObjectAttributes oba = new ObjectAttributes();
        oba.LayerIndex = layerIndex;
        oba.AddToGroup(GroupIndex);
        oba.MaterialIndex = matidx;
        oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
        Document.Objects.AddBrep(bp, oba);
      }
    }

    public void AddPaperSizeA(int a, bool Landscape)
    {
      AddPaperSizeA(a, Landscape, Color.White);
    }

    public void AddPaperSizeA(int a, bool Landscape, Color col)
    {
      this.Add("Paper:A" + a, col, Providers.GetPaperSizeA(a, Landscape));
    }

    public void Pin(Point2d point)
    {
      RealObject.Building pin = Providers.GetThumbtack();
      pin.Transform(Transform.Rotation(-Math.PI / 2.0, Point3d.Origin));

      double AngleDifference = Math.PI / 12.0;
      Random rd = new Random();
      pin.Transform(Transform.Rotation(-AngleDifference / 2.0 + Rand.NextDouble() * AngleDifference / 2.0, new Vector3d(0, 0, 1), Point3d.Origin));
      pin.Transform(Transform.Rotation(-AngleDifference / 2.0 + Rand.NextDouble() * AngleDifference / 2.0, new Vector3d(1, 0, 0), Point3d.Origin));
      pin.Transform(Transform.Translation(point.X, -5.0, point.Y));

      pin.Bake(Document);
    }


    public void AddColorPaper(Color col, Point2d point, double width, double height)
    {
      Brep paper = Brep.CreatePlanarBreps(new Rectangle3d(new Plane(new Point3d(point.X, -0.5, point.Y), Vector3d.XAxis, Vector3d.ZAxis), width, height).ToNurbsCurve())[0];
      Material m = new Material();
      m.DiffuseColor = col;
      int matidx = Document.Materials.Add(m);

      string name = "ColorPaper";
      int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
      if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
      ObjectAttributes oba = new ObjectAttributes();
      oba.LayerIndex = layerIndex;
      oba.MaterialIndex = matidx;
      oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
      Document.Objects.AddBrep(paper, oba);
    }

    public void AddText3d(string text, double height, double thickness, Point2d point, Color cl)
    {
      Brep[] texts = Providers.GetTextBrep(text, height, thickness);
      texts = GeneralHelper.RotateBreps(texts, Math.PI / 2.0, Vector3d.XAxis);
      texts = GeneralHelper.TranslateBreps(texts, new Point3d(point.X, 0, point.Y));
      this.Add("Text3d", cl, texts);
    }
    public void AddText3d(string text, double height, double thickness, Point2d point, Color cl, string fontname)
    {
      Brep[] texts = Providers.GetTextBrep(text, height, thickness, fontname, false, false, this.Document);
      texts = GeneralHelper.RotateBreps(texts, Math.PI / 2.0, Vector3d.XAxis);
      texts = GeneralHelper.TranslateBreps(texts, new Point3d(point.X, 0, point.Y));
      this.Add("Text3d", cl, texts);
    }

    public void AddPhoto(string url, double dpi, Point2d point)
    {
      System.Drawing.Bitmap bmp = new Bitmap(url);
      double inchToMm = 25.4;

      Brep paper = Brep.CreatePlanarBreps(new Rectangle3d(new Plane(new Point3d(0, 0, 0), Vector3d.XAxis, Vector3d.ZAxis), new Point3d(-bmp.Width / dpi * inchToMm / 2.0, 0, 0), new Point3d(bmp.Width / dpi * inchToMm / 2.0, 0, -bmp.Height / dpi * inchToMm)).ToNurbsCurve())[0];

      Material m = new Material();
      m.SetBitmapTexture(url);
      int matidx = Document.Materials.Add(m);

      paper.Translate(point.X, -2.5 + CurrentLayer * 0.1, point.Y);

      string name = "Photo";
      int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
      if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
      ObjectAttributes oba = new ObjectAttributes();
      oba.LayerIndex = layerIndex;
      oba.MaterialIndex = matidx;
      oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
      Document.Objects.AddBrep(paper, oba);

      this.Pin(point + new Vector2d(0, -10));

      CurrentLayer++;
    }

    public void AddTextXml(string url, Point2d point)
    {
      AddTextXml(Generator.ReadTextXml(url), System.IO.Path.GetFileNameWithoutExtension(url), point);
    }

    public void AddTextXml(Schemas.text xmlobj, string filename, Point2d point)
    {
      double scale = 5.0;
      Bitmap bp = Generator.CreateTextBitmap(xmlobj, scale);
      string fn = GetImageSavePath(filename);
      if (!System.IO.Directory.Exists(System.IO.Path.GetDirectoryName(fn))) { System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(fn)); }
      bp.Save(fn);

      this.AddPhoto(fn, 72 * scale, point);
    }

    public string GetImageSavePath(string filename)
    {
      return CurrentDirectory + @"\Texture\" + filename + ".png";
    }

    public void AddText(string head, string Content, double width, double height, Point2d point)
    {
      Schemas.text txt = new Schemas.text();
      txt.width = width;
      txt.height = height;
      string[] SeparetedContent = Content.Split('\n');
      List&lt;Object&gt; Body = new List&lt;object&gt;();
      Body.Add(head);

      foreach (string st in SeparetedContent)
      {
        Schemas.textParagraph1 tp1 = new Schemas.textParagraph1();
        tp1.Items = new string[] { st };
        tp1.ItemsElementName = new Schemas.ItemsChoiceType[] { Schemas.ItemsChoiceType.plain };
        Body.Add(tp1);
      }
      txt.body = Body.ToArray();

      AddTextXml(txt, Rand.Next(0, (int) 1e5).ToString(), point);
    }

    public void AddTextSimple(string text, string fontname, float fontsize, Point2d point, double marginh, double marginv)
    {
      AddTextSimple(text, fontname, fontsize, new FontStyle(), point, marginh, marginv, Color.White, Color.Black);
    }

    public void AddTextSimple(string text, string fontname, float fontsize, FontStyle fs, Point2d point, double marginh, double marginv, Color Background, Color ForeGround)
    {
      float scale = 5;
      Bitmap bp = new Bitmap(640, 480);
      System.Drawing.Font f = new System.Drawing.Font(fontname, fontsize * scale, fs);
      Graphics g = Graphics.FromImage(bp);
      SizeF size = g.MeasureString(text, f);
      int pwidth = (int) ((size.Width + marginh * 2 * scale));
      int pheight = (int) ((size.Height + marginv * 2 * scale));
      bp = new Bitmap(pwidth, pheight);
      g = Graphics.FromImage(bp);
      g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
      g.DrawString(text, f, new SolidBrush(ForeGround), new PointF((int) (marginh * scale), (int) (marginv * scale)));
      string filename = GetImageSavePath("TextSimple" + text);
      bp.Save(filename);

      Brep paper = Brep.CreatePlanarBreps(new Rectangle3d(new Plane(new Point3d(point.X - pwidth / scale / 2.0, -1.0, point.Y - pheight / scale / 2.0), Vector3d.XAxis, Vector3d.ZAxis), pwidth / scale, pheight / scale).ToNurbsCurve())[0];

      Material m = new Material();
      m.SetBitmapTexture(filename);
      m.DiffuseColor = Background;
      int matidx = Document.Materials.Add(m);

      string name = "Tag";
      int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
      if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
      ObjectAttributes oba = new ObjectAttributes();
      oba.LayerIndex = layerIndex;
      oba.MaterialIndex = matidx;
      oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
      Document.Objects.AddBrep(paper, oba);
    }

    public void AddTag(string text, string fontname, double fontSize, double width, double height, Color cl, Point2d point, double yvalue)
    {
      Curve cv = Curve.JoinCurves(new Curve[] { new Line(0, 0, 0, width / 2.5, 0, 0).ToNurbsCurve(), new Arc(new Point3d(width / 2.5, 0, 0), Vector3d.XAxis, new Point3d(width, -10, 0)).ToNurbsCurve() })[0];
      //Curve cv = Curve.CreateInterpolatedCurve(new Point3d[] { new Point3d(0, 0, 0), new Point3d(width / 2.5, 0, 0), }, 5);
      cv = cv.Rebuild(10, 5, true);
      Surface ExtSrf = Surface.CreateExtrusion(cv, new Vector3d(0, 0, height));
      ExtSrf = ExtSrf.Transpose();
      ExtSrf.Translate(point.X, -yvalue, point.Y);

      double scale = 3.0;
      Bitmap bp = new Bitmap((int) (scale * cv.GetLength()), (int) (scale * height));
      Graphics g = Graphics.FromImage(bp);
      g.FillRectangle(new SolidBrush(cl), new Rectangle(0, 0, (int) (height * scale), (int) (height * scale)));
      System.Drawing.Font font = new System.Drawing.Font(fontname, (float) (fontSize * scale));
      g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
      g.DrawString(text, font, Brushes.Black, new PointF((float) (scale * height), (float) ((scale * height - font.GetHeight(72)) / 2.0)));

      string filenamebody = text;
      char[] invalidchar = Path.GetInvalidFileNameChars();
      foreach (char c in invalidchar)
      {
        filenamebody = filenamebody.Replace(c, '_');
      }
      string filename = GetImageSavePath("Tag" + filenamebody);
      bp.Save(filename);

      Material m = new Material();
      m.SetBitmapTexture(filename);
      m.DiffuseColor = Color.White;
      int matidx = Document.Materials.Add(m);

      string name = "Tag";
      int layerIndex = Document.Layers.Add(name, System.Drawing.Color.Black);
      if (Document.Layers.FindByFullPath(name, true) &gt;= 0) { layerIndex = Document.Layers.FindByFullPath(name, true); }
      ObjectAttributes oba = new ObjectAttributes();
      oba.LayerIndex = layerIndex;
      oba.MaterialIndex = matidx;
      oba.MaterialSource = ObjectMaterialSource.MaterialFromObject;
      Document.Objects.AddBrep(Brep.CreateFromSurface(ExtSrf), oba);
    }



    public class Schemas
    {
      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      [System.Xml.Serialization.XmlRootAttribute(Namespace = "kurema/PanelLayout/0.0", IsNullable = false)]
      public partial class text
      {

        private textHeading headingField;

        private textParagraph paragraphField;

        private object[] bodyField;

        private double widthField;

        private double heightField;

        public text()
        {
          this.widthField = 640D;
          this.heightField = 480D;
        }

        /// &lt;remarks/&gt;
        public textHeading heading
        {
          get
          {
            return this.headingField;
          }
          set
          {
            this.headingField = value;
          }
        }

        /// &lt;remarks/&gt;
        public textParagraph paragraph
        {
          get
          {
            return this.paragraphField;
          }
          set
          {
            this.paragraphField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlArrayItemAttribute("heading", typeof(string), IsNullable = false)]
        [System.Xml.Serialization.XmlArrayItemAttribute("paragraph", typeof(textParagraph1), IsNullable = false)]
        public object[] body
        {
          get
          {
            return this.bodyField;
          }
          set
          {
            this.bodyField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(640D)]
        public double width
        {
          get
          {
            return this.widthField;
          }
          set
          {
            this.widthField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(480D)]
        public double height
        {
          get
          {
            return this.heightField;
          }
          set
          {
            this.heightField = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      public partial class textHeading
      {

        private style styleField;

        /// &lt;remarks/&gt;
        public style style
        {
          get
          {
            return this.styleField;
          }
          set
          {
            this.styleField = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      public partial class style
      {

        private styleFont fontField;

        private styleMargin marginField;

        /// &lt;remarks/&gt;
        public styleFont font
        {
          get
          {
            return this.fontField;
          }
          set
          {
            this.fontField = value;
          }
        }

        /// &lt;remarks/&gt;
        public styleMargin margin
        {
          get
          {
            return this.marginField;
          }
          set
          {
            this.marginField = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      public partial class styleFont
      {

        private string nameField;

        private double sizeField;

        private bool sizeFieldSpecified;

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name
        {
          get
          {
            return this.nameField;
          }
          set
          {
            this.nameField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public double size
        {
          get
          {
            return this.sizeField;
          }
          set
          {
            this.sizeField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool sizeSpecified
        {
          get
          {
            return this.sizeFieldSpecified;
          }
          set
          {
            this.sizeFieldSpecified = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      public partial class styleMargin
      {

        private double leftField;

        private double rightField;

        private double topField;

        private double bottomField;

        public styleMargin()
        {
          this.leftField = 0D;
          this.rightField = 0D;
          this.topField = 0D;
          this.bottomField = 0D;
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(0D)]
        public double left
        {
          get
          {
            return this.leftField;
          }
          set
          {
            this.leftField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(0D)]
        public double right
        {
          get
          {
            return this.rightField;
          }
          set
          {
            this.rightField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(0D)]
        public double top
        {
          get
          {
            return this.topField;
          }
          set
          {
            this.topField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(0D)]
        public double bottom
        {
          get
          {
            return this.bottomField;
          }
          set
          {
            this.bottomField = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      public partial class textParagraph
      {

        private style styleField;

        /// &lt;remarks/&gt;
        public style style
        {
          get
          {
            return this.styleField;
          }
          set
          {
            this.styleField = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Diagnostics.DebuggerStepThroughAttribute()]
      [System.ComponentModel.DesignerCategoryAttribute("code")]
      [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "kurema/PanelLayout/0.0")]
      public partial class textParagraph1
      {

        private string[] itemsField;

        private ItemsChoiceType[] itemsElementNameField;

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlElementAttribute("bold", typeof(string))]
        [System.Xml.Serialization.XmlElementAttribute("plain", typeof(string))]
        [System.Xml.Serialization.XmlElementAttribute("underline", typeof(string))]
        [System.Xml.Serialization.XmlChoiceIdentifierAttribute("ItemsElementName")]
        public string[] Items
        {
          get
          {
            return this.itemsField;
          }
          set
          {
            this.itemsField = value;
          }
        }

        /// &lt;remarks/&gt;
        [System.Xml.Serialization.XmlElementAttribute("ItemsElementName")]
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public ItemsChoiceType[] ItemsElementName
        {
          get
          {
            return this.itemsElementNameField;
          }
          set
          {
            this.itemsElementNameField = value;
          }
        }
      }

      /// &lt;remarks/&gt;
      [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
      [System.SerializableAttribute()]
      [System.Xml.Serialization.XmlTypeAttribute(Namespace = "kurema/PanelLayout/0.0", IncludeInSchema = false)]
      public enum ItemsChoiceType
      {

        /// &lt;remarks/&gt;
        bold,

        /// &lt;remarks/&gt;
        plain,

        /// &lt;remarks/&gt;
        underline,
      }


    }

    public class Generator
    {
      public static Schemas.text ReadTextXml(string fileName)
      {
        System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(Schemas.text));
        System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));
        Schemas.text text = (Schemas.text) serializer.Deserialize(sr);
        sr.Close();
        return text;
      }

      public static Bitmap CreateTextBitmap(Schemas.text text, double zoom = 1.0)
      {

        int x = (int) (text.width * zoom);
        int y = (int) (text.height * zoom);

        double mainMarginT = 0, mainMarginL = 0, mainMarginR = 0, mainMarginB = 0;
        double headMarginT = 0, headMarginL = 0, headMarginR = 0, headMarginB = 0;

        System.Drawing.Font HeadingFont;
        System.Drawing.Font MainFont;
        System.Drawing.Font MainFontBold;
        System.Drawing.Font MainFontUnderline;

        string fontnamedefault = "�����";
        {
          float fontsizedefault = (float) (12);
          string fontname = "";
          float fontsize = fontsizedefault;
          if (text.paragraph == null)
          {
            fontname = fontnamedefault;
            fontsize = fontsizedefault;

            mainMarginT = mainMarginL = mainMarginR = mainMarginT = 0.0;
          }
          else
          {
            fontname = text.paragraph.style.font.name == "" ? fontnamedefault : text.paragraph.style.font.name;
            fontsize = text.paragraph.style.font.size &lt;= 0 ? fontsizedefault : (float) text.paragraph.style.font.size;

            mainMarginT = text.paragraph.style.margin.top * zoom;
            mainMarginL = text.paragraph.style.margin.left * zoom;
            mainMarginR = text.paragraph.style.margin.right * zoom;
            mainMarginB = text.paragraph.style.margin.bottom * zoom;
          }
          MainFont = new System.Drawing.Font(fontname, fontsize * (float) zoom);
          MainFontBold = new System.Drawing.Font(fontname, fontsize * (float) zoom, FontStyle.Bold);
          MainFontUnderline = new System.Drawing.Font(fontname, fontsize * (float) zoom, FontStyle.Underline);
        }
        {
          float fontsizedefault = 25;
          string fontname = "";
          float fontsize = fontsizedefault;
          if (text.heading == null)
          {
            fontname = fontnamedefault;
            fontsize = fontsizedefault;

            headMarginT = headMarginL = headMarginR = headMarginT = 0.0;
          }
          else
          {
            fontname = text.heading.style.font.name == "" ? fontnamedefault : text.heading.style.font.name;
            fontsize = text.heading.style.font.size &lt;= 0 ? fontsizedefault : (float) text.heading.style.font.size;

            headMarginT = text.heading.style.margin.top * zoom;
            headMarginL = text.heading.style.margin.left * zoom;
            headMarginR = text.heading.style.margin.right * zoom;
            headMarginB = text.heading.style.margin.bottom * zoom;
          }
          HeadingFont = new System.Drawing.Font(fontname, fontsize * (float) zoom);
        }

        Bitmap img = new Bitmap(x, y);
        Graphics g = Graphics.FromImage(img);
        g.FillRectangle(Brushes.White, 0, 0, x, y);
        double CurrentY = 0;
        double CurrentX = 0;

        g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;

        for (int i = 0; i &lt; text.body.GetLength(0); i++)
        {
          if (text.body[i] is string)
          {
            CurrentX = headMarginL;
            CurrentY += headMarginT;

            g.DrawString((string) text.body[i], HeadingFont, Brushes.Black, new PointF((int) CurrentX, (int) CurrentY));
            CurrentY += HeadingFont.Height;

            CurrentY += headMarginB;
          }
          else
          {
            CurrentX = mainMarginL;
            CurrentY += mainMarginT;
            for (int j = 0; j &lt; ((Schemas.textParagraph1) text.body[i]).Items.GetLength(0); j++)
            {
              System.Drawing.Font font;
              if (((Schemas.textParagraph1) text.body[i]).ItemsElementName[j] == Schemas.ItemsChoiceType.bold)
              {
                font = MainFontBold;
              }
              else if (((Schemas.textParagraph1) text.body[i]).ItemsElementName[j] == Schemas.ItemsChoiceType.underline)
              {
                font = MainFontUnderline;
              }
              else
              {
                font = MainFont;
              }

              string baseText = ((Schemas.textParagraph1) text.body[i]).Items[j];
              while (CurrentX + g.MeasureString(baseText, font).Width &gt; x - mainMarginR &amp;&amp; baseText.Length &gt; 0)
              {
                string currentText = baseText;
                int SubTxtCount = 0;
                while (CurrentX + g.MeasureString(currentText, font).Width &gt; x - mainMarginR &amp;&amp; currentText.Length &gt; 0)
                {
                  SubTxtCount++;
                  currentText = baseText.Substring(0, baseText.Length - SubTxtCount);
                }
                if (SubTxtCount &gt; 0)
                {
                  g.DrawString(currentText, font, Brushes.Black, new PointF((int) CurrentX, (int) CurrentY));
                  CurrentY += MainFont.Height;
                  CurrentX = mainMarginR;
                  baseText = baseText.Substring(baseText.Length - SubTxtCount);
                  //g.DrawString(baseText.Substring(SubTxtCount+2), font, Brushes.Black, new PointF((int)CurrentX, (int)CurrentY));

                }
                else
                {
                  break;
                }
              }
              g.DrawString(baseText, font, Brushes.Black, new PointF((int) CurrentX, (int) CurrentY));
              CurrentX += g.MeasureString(baseText, font).Width;
            }
            CurrentY += MainFont.Height;
            CurrentY += mainMarginB;
          }
        }
        g.Dispose();
        return img;
      }
    }

  }
  #endregion

  #region ..\PlanObject.cs

  public class PlanObject
  {
    public class Building
    {
      public String Name;
      public List&lt;Floor&gt; Content = new List&lt;Floor&gt;();

      public Curve[] GetCurve()
      {
        List&lt;Curve&gt; Result = new List&lt;Curve&gt;();
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.AddRange(Content[i].GetCurve());
        }
        return Result.ToArray();
      }

      public void Transform(Transform Tf)
      {
        List&lt;Floor&gt; Operated = new List&lt;Floor&gt;();
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          if (!Operated.Contains(Content[i]))
          {
            Content[i].Transform(Tf);
            Operated.Add(Content[i]);
          }
        }
      }

      public void Bake(RhinoDoc RhinoDocument, int TargetFloor)
      {
        Content[TargetFloor].Bake(RhinoDocument, this.Name + ":");

      }

      public Building Duplicate()
      {
        Building Result = new Building(this.Name);
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.Content.Add(this.Content[i].Duplicate());
        }
        return Result;
      }

      public Building(string Name)
      {
        this.Name = Name;
      }
    }

    public class Floor
    {
      public String Name;
      public double Height;
      public List&lt;Member&gt; Content = new List&lt;Member&gt;();


      public void Bake(RhinoDoc RhinoDocument, string LayerNameHead)
      {
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Content[i].Bake(RhinoDocument, LayerNameHead + this.Name + ".");
        }
      }

      public void Transform(Transform Tf)
      {
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Content[i].Transform(Tf);
        }
      }

      public Curve[] GetCurve()
      {
        List&lt;Curve&gt; Result = new List&lt;Curve&gt;();
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.AddRange(Content[i].GetCurve());
        }
        return Result.ToArray();
      }

      public Floor Duplicate()
      {
        Floor Result = new Floor(this.Name);
        Result.Height = this.Height;
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.Content.Add(this.Content[i].Duplicate());
        }
        return Result;
      }

      public Floor(string Name)
      {
        this.Name = Name;
      }
    }

    public class Member
    {
      public String Name;

      public Point2d Point;
      public List&lt;Curve&gt; Content = new List&lt;Curve&gt;();
      public RealObject.Color Color = new RealObject.Color();


      public Curve[] GetCurve()
      {
        Curve[] Result = new Curve[Content.Count()];
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result[i] = (this.Content[i].DuplicateCurve());
        }
        return Result;
      }

      public Member Duplicate()
      {
        Member Result = new Member(this.Name);
        Result.Point = this.Point;
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Result.Content.Add(this.Content[i].DuplicateCurve());
        }

        return Result;
      }

      public void Transform(Transform Tf)
      {
        for (int i = 0; i &lt; Content.Count(); i++)
        {
          Content[i].Transform(Tf);
        }
      }

      public void Bake(RhinoDoc RhinoDocument, String LayerNameHead)
      {
        string LayerName = LayerNameHead + this.Name;
        int layerIndex = RhinoDocument.Layers.Add(LayerName, System.Drawing.Color.Black);
        if (RhinoDocument.Layers.FindByFullPath(LayerName, true) &gt;= 0) { layerIndex = RhinoDocument.Layers.FindByFullPath(LayerName, true); }
        int GroupIndex = RhinoDocument.Groups.Add(this.ToString() + Guid.NewGuid().ToString());
        foreach (Curve cv in Content)
        {
          ObjectAttributes oba = new ObjectAttributes();
          oba.LayerIndex = layerIndex;

          oba.ColorSource = this.Color.IsUndefined ? ObjectColorSource.ColorFromLayer : ObjectColorSource.ColorFromObject;
          oba.ObjectColor = (System.Drawing.Color) this.Color;
          oba.AddToGroup(GroupIndex);
          RhinoDocument.Objects.AddCurve(cv, oba);
        }
      }

      public Member(string Name)
      {
        this.Name = Name;
      }
    }
  }
  #endregion

  #region ..\Providers.cs

  public static class Providers
  {
    public static Curve GetRectangle3d(Point3d p, double Width, double Height)
    {
      Polyline pl = new Polyline();
      pl.Add(p);
      pl.Add(p + Vector3d.XAxis * Width);
      pl.Add(p + Vector3d.XAxis * Width + Vector3d.YAxis * Height);
      pl.Add(p + Vector3d.YAxis * Height);
      pl.Add(p);
      return pl.ToNurbsCurve();
    }

    public static Brep GetPaperSizeA(int i, bool Landscape)
    {
      double width = 1189 * Math.Pow(2.0, -i / 2.0);
      double height = 841 * Math.Pow(2.0, -i / 2.0);
      if (!Landscape) { double temp; temp = height; height = width; width = height; }
      return Brep.CreatePlanarBreps(new Rectangle3d(Plane.WorldZX, height, width).ToNurbsCurve())[0];
    }

    public static RealObject.Building GetThumbtack()
    {
      RealObject.Building result = new RealObject.Building("Thumback");
      Polyline pl = new Polyline(3);
      pl.Add(5, 0, 0.5);
      pl.Add(-7.5, 0, 0.5);
      pl.Add(-10.0, 0, 0);
      result.Content.Add(new RealObject.Member("Needle")
        {
          Content = new Brep[]{
          Brep.CreateFromRevSurface(RevSurface.Create(pl.ToNurbsCurve(), new Line(0, 0, 0, 1, 0, 0)), true, true)},
          Material = new RealObject.Material("Silver"),
          DeatailLevel = -1
          });

      Curve[] cv = Curve.JoinCurves(new Curve[]{
        new Arc(new Point3d(0, 0, 4), new Point3d(1, 0, 2 + Math.Sqrt(2)), new Point3d(2, 0, 2)).ToNurbsCurve(),
        new Line(2, 0, 2, 7, 0, 1.5).ToNurbsCurve(),
        new Line(7, 0, 1.5, 7, 0, 2.5).ToNurbsCurve(),
        new Arc(new Point3d(7, 0, 2.5), new Point3d(7.3, 0, 2.2), new Point3d(7.5, 0, 0)).ToNurbsCurve()
        });

      result.Content.Add(new RealObject.Member("Body")
        {
          Content = new Brep[] { Brep.CreateFromRevSurface(RevSurface.Create(cv[0], new Line(0, 0, 0, 1, 0, 0)), true, true) },
          Material = new RealObject.Material("Plastic"),
          DeatailLevel = 0
          });
      return result;
    }

    public static Polyline GetKochCurve(double Angle, int Generation)
    {
      Polyline result = new Polyline();

      double crtangle = 0.0;
      Point3d crtpt = new Point3d(0, 0, 0);
      LSystem lsys = GetKochCurveLSystem();
      for (int i = 0; i &lt; Generation; i++)
      {
        lsys.ApplyRules();
      }
      foreach (LSystem.Body bd in lsys.Tree.Content)
      {
        if (bd.BodyType == lsys.BodyTypes["F"])
        {
          crtpt += new Vector3d(Math.Cos(crtangle), Math.Sin(crtangle), 0);
          result.Add(crtpt);
        }
        else if (bd.BodyType == lsys.BodyTypes["+"])
        {
          crtangle += Angle;
        }
        else if (bd.BodyType == lsys.BodyTypes["-"])
        {
          crtangle -= Angle;
        }
      }
      return result;
    }

    public static LSystem GetKochCurveLSystem()
    {
      LSystem.BodyType F = new LSystem.BodyType("F");
      LSystem.BodyType P = new LSystem.BodyType("+");
      LSystem.BodyType M = new LSystem.BodyType("-");

      LSystem.Sequence initseq = new LSystem.Sequence(F);

      LSystem.RuleSimple rs = new LSystem.RuleSimple()
        {
          Target = F,
          Result = new LSystem.Sequence(F, P, F, M, F, M, F, P, F) //F+F-F-F+F
          };

      LSystem treesys = new LSystem(initseq, new LSystem.Rule[] { rs });
      treesys.RegisterBodyType(F, P, M);
      return treesys;
    }
    public static LSystem GetTreeLSystem()
    {
      LSystem.BodyType B = new LSystem.BodyType("B");//branch
      //LSystem.BodyType F = new LSystem.BodyType("F");//flower
      LSystem.BodyType L = new LSystem.BodyType("L");//leaf
      LSystem.BodyType G = new LSystem.BodyType("G");//growth
      LSystem.BodyType TR = new LSystem.BodyType("-");//turn_right
      LSystem.BodyType TL = new LSystem.BodyType("+");//turn_left
      LSystem.BodyType D = new LSystem.BodyType("D");//Divergence


      LSystem.Sequence initseq = new LSystem.Sequence(B, G);

      LSystem.RuleProbability rp = new LSystem.RuleProbability(new Random());
      rp.Target = G;
      rp.AddSequence(new LSystem.Sequence()
        {
          Content = new List&lt;LSystem.Body&gt;(){
            new LSystem.Body(D){
              Child = new LSystem.Sequence[]{
              new LSystem.Sequence(B, G, L),
              new LSystem.Sequence(TL, B, TL, B, G)
              }
              }
            }
          }, 0.5);
      rp.AddSequence(new LSystem.Sequence()
        {
          Content = new List&lt;LSystem.Body&gt;(){
            new LSystem.Body(D){
              Child = new LSystem.Sequence[]{
              new LSystem.Sequence(TR, B, G, L),
              new LSystem.Sequence(TL, B, L, G)
              }
              }
            }
          }, 0.5);

      LSystem treesys = new LSystem(initseq, new LSystem.Rule[] { rp });
      //treesys.RegisterBodyType(B, F, L, G, TR, TL, D);
      treesys.RegisterBodyType(B, L, G, TR, TL, D);
      return treesys;

    }

    public static GraphObject.Graph GetTreeGraph(int Generation)
    {
      LSystem lsys = GetTreeLSystem();
      lsys.ApplyRules(Generation);
      GraphObject.Graph Result = new GraphObject.Graph(new GraphObject.Path() { ContentMember = new Brep[0], Length = 0 }, new Point3d(0, 0, 0));
      Result.RotationAngleY = -Math.PI / 2.0;
      GraphObject.Path EndPath = Result.RootPath;
      GetTreeGraphBranch(ref Result, EndPath, lsys.Tree, lsys.BodyTypes, Math.PI / 6.0, 1500, 0.8, 60, 0.7, 0, Math.PI / 24.0, Math.PI / 6.0);
      return Result;
    }

    private static void GetTreeGraphBranch(ref GraphObject.Graph Result, GraphObject.Path EndPath, LSystem.Sequence sq, Dictionary&lt;string, LSystem.BodyType&gt; bodyTypes, double Angle, double BaseLength, double LengthRate, double BaseRad, double RadRate, double TwistAngle, double TwistAngleRange, double TwistAngleTwisted)
    {
      Brep LeafBrep;
      //LeafBrep = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, 40), new Interval(-6, 6), new Interval(-1, 0)));
      {
        Curve LeafBaseCrv1 = Curve.CreateInterpolatedCurve(new Point3d[] { new Point3d(0, 0, 0), new Point3d(60, 50, 0), new Point3d(200, 0, 0) }, 3);
        Curve LeafBaseCrv2 = (Curve) LeafBaseCrv1.Duplicate();
        LeafBaseCrv2.Transform(Transform.Mirror(Plane.WorldZX));
        Curve LeafBaseCrv = Curve.JoinCurves(new Curve[] { LeafBaseCrv1, LeafBaseCrv2 })[0];
        LeafBrep = Brep.CreatePlanarBreps(new Curve[] { LeafBaseCrv })[0];
      }
      foreach (LSystem.Body bd in sq.Content)
      {
        if (bd.BodyType == bodyTypes["B"])
        {
          //GraphObject.Path TmpPath = GraphObject.Path.CreateFromPipeSimple(new double[] { 0, BaseLength * Math.Pow(LengthRate, bd.Generation) }, new double[] { BaseRad * Math.Pow(RadRate, bd.Generation), BaseRad * Math.Pow(RadRate, bd.Generation + 1) });
          GraphObject.Path TmpPath = GraphObject.Path.CreateFromRegularPolygonTower(5, BaseRad * Math.Pow(RadRate, bd.Generation), BaseLength * Math.Pow(LengthRate, bd.Generation));
          TmpPath.Name = "Branch";
          var TmpNode = Result.Add(EndPath, TmpPath);
          EndPath = TmpPath;

          TmpNode.RotationAngleX = 0;
          TmpNode.RotationAngleY = TwistAngle;
          TmpNode.RotationAngleYLimitation = new Interval(TwistAngle - (TwistAngleRange / 2.0), TwistAngle + (TwistAngleRange / 2.0));
          TmpNode.RotationAngleZ = 0;
          TmpNode.RotationAngleZLimitation = new Interval(0, 0);

          TwistAngle = 0;
        }
        else if (bd.BodyType == bodyTypes["+"])
        {
          TwistAngle = TwistAngleTwisted;
        }
        else if (bd.BodyType == bodyTypes["-"])
        {
          TwistAngle = -TwistAngleTwisted;
        }
        else if (bd.BodyType == bodyTypes["L"])
        {
          GraphObject.Path TmpPath = new GraphObject.Path() { ContentMember = new Brep[] { (Brep) LeafBrep.Duplicate() } };
          TmpPath.Name = "Leaf";
          var TmpNode = Result.Add(EndPath, TmpPath);
          EndPath = TmpPath;
        }
          //F�ȗ�
        else if (bd.BodyType == bodyTypes["D"])
        {
          foreach (LSystem.Sequence tmpsq in bd.Child)
          {
            GetTreeGraphBranch(ref Result, EndPath, tmpsq, bodyTypes, Angle, BaseLength, LengthRate, BaseRad, RadRate, TwistAngle, TwistAngleRange, TwistAngleTwisted);
          }

        }

      }
    }

    public static Polyline[] GetTree2D(int Generation)
    {
      double Angle = Math.PI / 6.0;
      LSystem lsys = GetTreeLSystem();
      lsys.ApplyRules(Generation);
      return GetTree2DBranch(lsys.Tree, lsys.BodyTypes, new Point3d(0, 0, 0), 0, Angle);
    }

    private static Polyline[] GetTree2DBranch(LSystem.Sequence sq, Dictionary&lt;string, LSystem.BodyType&gt; bodyTypes, Point3d CurrentPoint, double CurrentAngle, double Angle)
    {
      Polyline result = new Polyline();
      result.Add(CurrentPoint);
      List&lt;Polyline&gt; PLs = new List&lt;Polyline&gt;();
      foreach (LSystem.Body bd in sq.Content)
      {
        if (bd.BodyType == bodyTypes["B"])
        {
          CurrentPoint += new Vector3d(Math.Cos(CurrentAngle), Math.Sin(CurrentAngle), 0);
          result.Add(CurrentPoint);
        }
        else if (bd.BodyType == bodyTypes["-"])
        {
          CurrentAngle -= Angle;
        }
        else if (bd.BodyType == bodyTypes["+"])
        {
          CurrentAngle += Angle;
        }
        else if (bd.BodyType == bodyTypes["D"])
        {
          foreach (LSystem.Sequence seq in bd.Child)
          {
            PLs.AddRange(GetTree2DBranch(seq, bodyTypes, CurrentPoint, CurrentAngle, Angle));
          }
        }
      }
      PLs.Add(result);
      return PLs.ToArray();
    }

    public static Brep[] GetHumanRandom(double Height)
    {
      return GetHumanRandom(Height, new Random());
    }

    public static Brep[] GetHumanRandom(double Height, Random rd)
    {
      GraphObject.Graph human = GraphObject.Graph.GetHumanBody(Height);
      human.MoveRandom(rd);
      return human.GetBrep();
    }

    public static Brep GetRegularPolygonTower(int c, double Radius, double height, bool Cap)
    {
      Brep result = Brep.CreateFromSurface(Surface.CreateExtrusion(GetRegularPolygon(c, Radius), new Vector3d(0, 0, height)));
      if (Cap) { result = result.CapPlanarHoles(0); }
      return result;
    }

    public static Curve GetRegularPolygon(int c, double Radius)
    {
      Polyline pl = new Polyline(c + 1);
      for (int i = 0; i &lt;= c; i++)
      {
        pl.Add(Math.Cos(Math.PI * (double) i / (double) c * 2.0) * Radius, Math.Sin(Math.PI * (double) i / (double) c * 2.0) * Radius, 0);
      }
      return pl.ToNurbsCurve();
    }

    public static void GetGlassWindowLight(int CountX, int CountY, double Width, double Height, double FrameWidth, double GlassThickness, out Brep[] Glass, out Brep[] Frame)
    {
      {
        Polyline secPL = new Polyline(5);
        secPL.Add(0, 0, 0);
        secPL.Add(Width * CountX, 0, 0);
        secPL.Add(Width * CountX, 0, Height * CountY);
        secPL.Add(0, 0, Height * CountY);
        secPL.Add(0, 0, 0);

        List&lt;Brep&gt; GlassBrep = new List&lt;Brep&gt;();
        Curve secCv = secPL.ToNurbsCurve();
        GlassBrep.AddRange(Brep.CreatePlanarBreps(secCv));
        GlassBrep.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(secCv, new Vector3d(0, GlassThickness, 0))));
        secCv.Translate(0, GlassThickness, 0);
        GlassBrep.AddRange(Brep.CreatePlanarBreps(secCv));
        Glass = Brep.CreateSolid(GlassBrep, GlassThickness / 100.0);
      }
      Brep[] ResultFrame = GetFrame2d(CountX, CountY, Width, Height, FrameWidth, FrameWidth, FrameWidth, FrameWidth);
      for (int i = 0; i &lt; ResultFrame.GetLength(0); i++)
      {
        ResultFrame[i].Translate(0, -GlassThickness, 0);
      }
      Frame = ResultFrame;
    }

    public static Brep[] GetFrame2d(int CountX, int CountY, double Width, double Height, double FrameWidthTop, double FrameWidthLeft, double FrameWidthRight, double FrameWidthBottom)
    {
      Curve RecBase;
      {
        Polyline recPL = new Polyline(5);
        recPL.Add(FrameWidthRight, 0, FrameWidthBottom);
        recPL.Add(Width - FrameWidthLeft, 0, FrameWidthBottom);
        recPL.Add(Width - FrameWidthLeft, 0, Height - FrameWidthTop);
        recPL.Add(FrameWidthRight, 0, Height - FrameWidthTop);
        recPL.Add(FrameWidthRight, 0, FrameWidthBottom);
        RecBase = recPL.ToNurbsCurve();
      }
      List&lt;Curve&gt; ResultBase = new List&lt;Curve&gt;();
      {
        Polyline recPL = new Polyline(5);
        recPL.Add(0, 0, 0);
        recPL.Add(Width * CountX, 0, 0);
        recPL.Add(Width * CountX, 0, Height * CountY);
        recPL.Add(0, 0, Height * CountY);
        recPL.Add(0, 0, 0);
        ResultBase.Add(recPL.ToNurbsCurve());
      }

      for (int cntx = 0; cntx &lt; CountX; cntx++)
      {
        for (int cnty = 0; cnty &lt; CountY; cnty++)
        {
          Curve Rec = (Curve) RecBase.Duplicate();
          Rec.Translate(cntx * Width, 0, cnty * Height);
          ResultBase.Add(Rec);
        }
      }
      return Brep.CreatePlanarBreps(ResultBase);
    }

    public static void GetJapaneseRoof(double LengthTop, double LengthBottom, double Depth, double Pitch, double Height, double RafterSpace, double RafterWidth, double RafterHeight, out Brep[] Main, out Brep[] Rafter)
    {
      Main = GetJapaneseRoofMain(LengthTop, LengthBottom, Depth, Pitch, Height);
      Rafter = GetJapaneseRoofRafter(LengthTop, LengthBottom, Depth, Pitch, Height, RafterSpace, RafterWidth, RafterHeight);
    }

    public static Brep[] GetJapaneseRoofRafter(double LengthTop, double LengthBottom, double Depth, double Pitch, double Height, double RafterSpace, double RafterWidth, double RafterHeight)
    {
      List&lt;Brep&gt; Lafters = new List&lt;Brep&gt;();
      double RafterSpaceBottom = LengthBottom / Math.Floor(LengthBottom / RafterSpace);
      double RafterSpaceTop = LengthTop / Math.Floor(LengthBottom / RafterSpace);

      Curve SectionBase;
      {
        Polyline SectionPL = new Polyline(5);
        SectionPL.Add(RafterWidth / 2.0, 0, 0);
        SectionPL.Add(RafterWidth / 2.0, 0, -RafterHeight);
        SectionPL.Add(-RafterWidth / 2.0, 0, -RafterHeight);
        SectionPL.Add(-RafterWidth / 2.0, 0, 0);
        SectionPL.Add(RafterWidth / 2.0, 0, 0);

        SectionBase = SectionPL.ToNurbsCurve();
      }

      double CurrentPositonTop = -LengthTop / 2.0 + RafterSpaceTop;
      double CurrentPositonBottom = -LengthBottom / 2.0 + RafterSpaceBottom;
      for (; CurrentPositonBottom &lt;= LengthBottom / 2.0 - RafterSpaceBottom; CurrentPositonBottom += RafterSpaceBottom, CurrentPositonTop += RafterSpaceTop)
      {
        Point3d PointTop = new Point3d(CurrentPositonTop, 0, -Height);
        Point3d PointBottom = new Point3d(CurrentPositonBottom, -Depth, -Depth * Pitch - Height);

        Curve TempCurve1 = (Curve) SectionBase.Duplicate();
        TempCurve1.Translate((Vector3d) PointTop);
        Lafters.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(TempCurve1, PointBottom - PointTop)).CapPlanarHoles(Height / 100.0));
      }
      return Lafters.ToArray();
    }

    public static Brep[] GetJapaneseRoofMain(double LengthTop, double LengthBottom, double Depth, double Pitch, double Height)
    {
      List&lt;Brep&gt; ResultRoof = new List&lt;Brep&gt;();
      Polyline RoofPL = new Polyline(5);
      RoofPL.Add(LengthTop / 2.0, 0, 0);
      RoofPL.Add(LengthBottom / 2.0, -Depth, -Depth * Pitch);
      RoofPL.Add(-LengthBottom / 2.0, -Depth, -Depth * Pitch);
      RoofPL.Add(-LengthTop / 2.0, 0, 0);
      RoofPL.Add(LengthTop / 2.0, 0, 0);

      Curve RoofCurve = RoofPL.ToNurbsCurve();
      Brep RoofPlanar = (Brep.CreatePlanarBreps(RoofCurve))[0];
      ResultRoof.Add(RoofPlanar);
      RoofPlanar = (Brep) RoofPlanar.Duplicate();
      RoofPlanar.Translate(0, 0, -Height);
      ResultRoof.Add(RoofPlanar);

      ResultRoof.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(RoofCurve, new Vector3d(0, 0, -Height))));
      return Brep.CreateSolid(ResultRoof, Height / 100.0);
    }

    public static RealObject.Building GetHandrailGlass(Curve BaseCurve)
    {
      return GetHandrailGlass(BaseCurve, 700, 100, 600, 750, 50, 25, 37.5, 10, 100, 5.0);
    }

    public static RealObject.Building GetHandrailGlass(Curve BaseCurve, double Height, double Space)
    {
      return GetHandrailGlass(BaseCurve, Height, 100, Height - 100, Space, 50, 25, 37.5, 10, 100, 5.0);
    }

    public static RealObject.Building GetHandrailGlass(Curve BaseCurve, double Height, double GlassHeightBottom, double GlassHeightTop, double Space, double GlassMarginSide, double Radius1, double Radius2, double GlassThick, double EndSpace, double FrameWidth)
    {
      EndSpace = BaseCurve.IsClosed ? 0 : EndSpace;
      List&lt;Brep&gt; Handrail = new List&lt;Brep&gt;();
      List&lt;Brep&gt; Glass = new List&lt;Brep&gt;();
      List&lt;Brep&gt; Frame = new List&lt;Brep&gt;();
      {
        Curve TopRailCurve = (Curve) BaseCurve.Duplicate();
        TopRailCurve.Translate(0, 0, Height);
        Handrail.Add(Brep.CreateFromSweep(TopRailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius2)), TopRailCurve), true, Space / 1000)[0]);
      }
      double Length = BaseCurve.GetLength();
      double EndTreatment = 0.5;
      for (double CurrentLength = EndSpace; CurrentLength + Space * EndTreatment + EndSpace &lt; Length; CurrentLength += Space)
      {
        Point3d Point1 = BaseCurve.PointAtLength(CurrentLength);
        Point3d Point2 = BaseCurve.PointAtLength(CurrentLength + Space);
        if (CurrentLength + Space * (EndTreatment + 1) &gt; Length) { Point2 = BaseCurve.PointAtLength(Length - EndSpace); }

        Handrail.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(Point1, Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));

        double GlassLength = (Point2 - Point1).Length;
        if (GlassLength &gt; GlassMarginSide * 2)
        {
          Brep GlassTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(GlassMarginSide, GlassLength - GlassMarginSide), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom, GlassHeightTop)));
          GlassTemp = GeneralHelper.FitTwoPoint(GlassTemp, Point1, Point2);
          Glass.Add(GlassTemp);
          if (FrameWidth &gt; 0)
          {
            {
              Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, GlassLength), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom - FrameWidth, GlassHeightBottom)));
              FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
              Frame.Add(FrameTemp);
            }
            {
              Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(0, GlassLength), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightTop, GlassHeightTop + FrameWidth)));
              FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
              Frame.Add(FrameTemp);
            }
            {
              Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(GlassMarginSide - FrameWidth, GlassMarginSide), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom, GlassHeightTop)));
              FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
              Frame.Add(FrameTemp);
            }
            {
              Brep FrameTemp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(GlassLength - GlassMarginSide, GlassLength - GlassMarginSide + FrameWidth), new Interval(-GlassThick / 2.0, GlassThick / 2.0), new Interval(GlassHeightBottom, GlassHeightTop)));
              FrameTemp = GeneralHelper.FitTwoPoint(FrameTemp, Point1, Point2);
              Frame.Add(FrameTemp);
            }
          }
        }
      }
      if (!BaseCurve.IsClosed)
      {
        Handrail.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(BaseCurve.PointAtLength(Length - EndSpace), Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
        Handrail[0] = Handrail[0].CapPlanarHoles(0);
      }
      RealObject.Building result = new RealObject.Building("GlassHandrail");
      result.Add("Rail", Handrail.ToArray());
      result.Add("Glass", Glass.ToArray());
      result.Add("Frame", Frame.ToArray());
      return result;
    }

    public static RealObject.Building GetHandrailGlassSimple(Curve BaseCurve, double Height, double Space)
    {
      return GetHandrailGlassSimple(BaseCurve, Height, Space, 10, 10, 50);
    }

    public static RealObject.Building GetHandrailGlassSimple(Curve BaseCurve, double Height, double Space, double FrameSizeHorizontal, double FrameSizeBottom, double FrameSizeTop)
    {
      RealObject.Building Result = new RealObject.Building("HandrailGlassSimple");
      double CurveLen = BaseCurve.GetLength();
      double SpaceModified = (CurveLen - 0.01) / (int) (CurveLen / Space);

      List&lt;Brep&gt; Glass = new List&lt;Brep&gt;();
      List&lt;Brep&gt; Frame = new List&lt;Brep&gt;();

      for (int i = 0; i &lt; (int) (CurveLen / Space); i++)
      {
        Point3d Point1 = BaseCurve.PointAtLength(SpaceModified * i);
        Point3d Point2 = BaseCurve.PointAtLength(SpaceModified * (i + 1));
        double Dist = Point2.DistanceTo(Point1);
        if (FrameSizeHorizontal != 0)
        {
          Polyline PL1 = new Polyline(5);
          Polyline PL2 = new Polyline(5);
          PL1.Add(0, 0, 0);
          PL1.Add(Dist, 0, 0);
          PL1.Add(Dist, 0, Height);
          PL1.Add(0, 0, Height);
          PL1.Add(0, 0, 0);

          PL2.Add(FrameSizeHorizontal, 0, FrameSizeBottom);
          PL2.Add(Dist - FrameSizeHorizontal, 0, FrameSizeBottom);
          PL2.Add(Dist - FrameSizeHorizontal, 0, Height - FrameSizeTop);
          PL2.Add(FrameSizeHorizontal, 0, Height - FrameSizeTop);
          PL2.Add(FrameSizeHorizontal, 0, FrameSizeBottom);

          Brep Temp = Brep.CreatePlanarBreps(new Curve[] { PL1.ToNurbsCurve(), PL2.ToNurbsCurve() })[0];
          Temp = GeneralHelper.FitTwoPoint(Temp, Point1, Point2);
          Frame.Add(Temp);
        }
        {
          Brep Temp = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(FrameSizeHorizontal, Dist - FrameSizeHorizontal), new Interval(0, 5), new Interval(FrameSizeBottom, Height - FrameSizeTop)));
          Temp = GeneralHelper.FitTwoPoint(Temp, Point1, Point2);
          Glass.Add(Temp);
        }
      }
      Result.Add("Glass", Glass.ToArray());
      Result.Add("Frame", Frame.ToArray());

      return Result;
    }

    public static Brep GetPipeSimple(double[] Distance, double[] Radius)
    {
      return Brep.CreateFromRevSurface(RevSurface.Create(GetHeightMap(Distance, Radius), new Line(0, 0, 0, 1, 0, 0)), false, false);
    }

    public static Brep GetPipeHalf(double[] Distance, double[] Radius)
    {
      Curve RevBase = GetHeightMap(Distance, Radius);
      return Brep.CreateFromRevSurface(RevSurface.Create(RevBase, new Line(0, 0, 0, 1, 0, 0), Math.PI * 0, Math.PI), true, true);
    }

    public static Curve GetHeightMap(double[] Distance, double[] Radius)
    {
      List&lt;Point3d&gt; Points = new List&lt;Point3d&gt;();
      for (int i = 0; i &lt; Distance.GetLength(0); i++)
      {
        Points.Add(new Point3d(Distance[i], Radius[i], 0));
      }
      List&lt;Curve&gt; intcrv = new List&lt;Curve&gt;();
      intcrv.Add(Curve.CreateInterpolatedCurve(Points, 3));
      if (Radius[0] &gt; 0) intcrv.Add((new Line(Distance[0], Radius[0], 0, Distance[0], 0, 0)).ToNurbsCurve());
      if (Radius[Radius.GetLength(0) - 1] &gt; 0) intcrv.Add((new Line(Distance[Distance.GetLength(0) - 1], Radius[Radius.GetLength(0) - 1], 0, Distance[Distance.GetLength(0) - 1], 0, 0)).ToNurbsCurve());
      return Curve.JoinCurves(intcrv)[0];
    }

    public static Brep GetPipeHead(double[] Distance, double[] Radius)
    {
      List&lt;Point3d&gt; Points = new List&lt;Point3d&gt;();
      for (int i = 0; i &lt; Radius.GetLength(0); i++)
      {
        Points.Add(new Point3d(Distance[i], Radius[i], 0));
      }
      Points.Add(new Point3d(Distance[Distance.GetLength(0) - 1], 0, 0));
      for (int i = Radius.GetLength(0) - 1; i &gt;= 0; i--)
      {
        Points.Add(new Point3d(Distance[i], -Radius[i], 0));
      }
      Curve intcrv = Curve.CreateInterpolatedCurve(Points, 3, CurveKnotStyle.Chord);
      intcrv.Domain = new Interval(0, 1);
      intcrv = intcrv.Split(0.5)[0];
      return Brep.CreateFromRevSurface(RevSurface.Create(intcrv, new Line(0, 0, 0, 1, 0, 0), 0, Math.PI * 2.0), true, true);
    }

    public static Brep[][] GetClock(RhinoDoc rd, double r)
    {
      return GetClock(rd, System.DateTime.Now, r, "Cambria");
    }

    public static Brep[][] GetClock(RhinoDoc rd, System.DateTime dt, double r, string fontname)
    {
      return GetClock(rd, dt, r, fontname, new Interval(0.75, 0.85), new Interval(0.9, 1.0), 0.02, new Interval[] { new Interval(-0.0, 0.6), new Interval(-0.1, 0.7), new Interval(-0.2, 0.75) },
        new double[] { 0.03, 0.02, 0.01 }, 5, 2, 2, 2);
    }

    public static Brep[][] GetClock(RhinoDoc rd, System.DateTime time, double Radius, string TextFontName, Interval TextRad, Interval Frame, double CenterRad, Interval[] HandsRad, double[] HandsWidth, double BaseThick, double HandsThick, double TextThick, double GlassThick)
    {
      Brep[][] Result = new Brep[5][];

      List&lt;Brep&gt; Texts = new List&lt;Brep&gt;();
      for (int i = 1; i &lt;= 12; i++)
      {
        TextEntity TE = new TextEntity();
        TE.Plane = new Plane(new Point3d(0, 0, 0), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1));
        TE.Justification = TextJustification.MiddleCenter;
        TE.Text = "" + i;
        TE.FontIndex = rd.Fonts.FindOrCreate(TextFontName, false, false);
        TE.TextHeight = TextRad.Length * Radius;
        TE.Translate(Radius * TextRad.Mid * Math.Sin(Math.PI * i / 6.0), -BaseThick, Radius * TextRad.Mid * Math.Cos(Math.PI * i / 6.0));
        Texts.AddRange(GeneralHelper.CreateExtrusionCaped(TE.Explode(), new Vector3d(0, -TextThick, 0)));
      }
      Result[0] = Texts.ToArray();

      List&lt;Brep&gt; Hands = new List&lt;Brep&gt;();
      double[] Angles = new double[] { (time.Hour + time.Minute / 60.0) * Math.PI / 6.0, (time.Minute + time.Second / 60.0) * Math.PI / 30.0, time.Second * Math.PI / 30.0 };
      for (int i = 0; i &lt; 3; i++)
      {
        if (HandsRad[i].Length &gt; 0)
        {
          Box bx = new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(Math.Sin(Angles[i]), 0, Math.Cos(Angles[i])), new Vector3d(Math.Sin(Angles[i] + Math.PI / 2.0), 0, Math.Cos(Angles[i] + Math.PI / 2.0)))
            , new Interval(HandsRad[i].Min * Radius, HandsRad[i].Max * Radius), new Interval(-Radius * HandsWidth[i] / 2.0, Radius * HandsWidth[i] / 2.0), new Interval(-BaseThick - TextThick * 2.0 - HandsThick * (i + 1), -BaseThick - TextThick * 2.0 - HandsThick * i));
          Hands.Add(Brep.CreateFromBox(bx));
        }
      }
      Result[1] = Hands.ToArray();

      Curve RevCrv =
        (Curve.JoinCurves(new Curve[]{(new Arc(new Circle(new Plane(new Point3d(Frame.Min * Radius, -BaseThick, 0), new Vector3d(0, 0, 1)), Frame.Length * Radius), new Interval(-Math.PI / 2.0, 0))).ToNurbsCurve(),
        new Line(Frame.Min * Radius, -BaseThick, 0, Frame.Min * Radius, -BaseThick - Frame.Length * Radius, 0).ToNurbsCurve(),
        new Line(Frame.Min * Radius, -BaseThick, 0, Frame.Max * Radius, -BaseThick, 0).ToNurbsCurve()
        }))[0];
      Result[2] = new Brep[]{
        Brep.CreateFromCylinder(new Cylinder(new Circle(Plane.WorldZX, Radius), -BaseThick), true, true),
        Brep.CreateFromRevSurface(RevSurface.Create(RevCrv, new Line(0, 0, 0, 0, 1, 0)), false, false)
        };
      Result[3] = new Brep[]{
        Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Frame.Length * Radius - BaseThick, 0), new Vector3d(0, 1, 0)), Radius * Frame.Min), GlassThick), true, true)
        };
      Result[4] = new Brep[]{
        Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -BaseThick, 0), new Vector3d(0, 1, 0)), Radius * CenterRad), -TextThick * 2.0 - HandsThick * 4.0), true, true)
        };
      return Result;
    }

    public static Curve[] GetTextCurve(string TextContent, double Height, string FontName, bool Bold, bool Italic, RhinoDoc RhinoDocument)
    {
      Rhino.Geometry.TextEntity txt = new TextEntity();
      txt.Text = TextContent;
      txt.TextHeight = Height;



      txt.FontIndex = RhinoDocument.Fonts.FindOrCreate(FontName, Bold, Italic);
      return txt.Explode();
    }

    public static Curve[] GetTextCurve(string TextContent, double Height) { return (new TextEntity() { Text = TextContent, TextHeight = Height }).Explode(); }
    public static Brep[] GetTextBrep(string TextContent, double Height, double Thickness) { return GeneralHelper.CreateExtrusionCaped((new TextEntity() { Text = TextContent, TextHeight = Height }).Explode(), new Vector3d(0, 0, Thickness)); }
    public static Brep[] GetTextBrep(string TextContent, double Height, double Thickness, string FontName, bool Bold, bool Italic, RhinoDoc RhinoDocument) { return GeneralHelper.CreateExtrusionCaped(GetTextCurve(TextContent, Height, FontName, Bold, Italic, RhinoDocument), new Vector3d(0, 0, Thickness)); }

    public static Curve GetRailroadBallast(double BallastWidthTop, double BallastWidthBottom, double BallastHeight)
    {
      Polyline BallastBasePL = new Polyline(5);
      BallastBasePL.Add(BallastWidthBottom / 2.0, 0, 0);
      BallastBasePL.Add(BallastWidthTop / 2.0, 0, BallastHeight);
      BallastBasePL.Add(-BallastWidthTop / 2.0, 0, BallastHeight);
      BallastBasePL.Add(-BallastWidthBottom / 2.0, 0, 0);
      BallastBasePL.Add(BallastWidthBottom / 2.0, 0, 0);
      return BallastBasePL.ToNurbsCurve();
    }

    public static Curve GetRailroadTrackShape()
    {
      return GetRailroadTrackShape(145.0, 65.0, 49.0, 94.9, 30.1, 16.5);
    }

    public static Curve GetRailroadTrackShape(double b, double c, double d, double e, double f, double g)
    {
      Polyline BallastBasePL = new Polyline(11);
      BallastBasePL.Add(b / 2.0, 0, 0);
      BallastBasePL.Add(b / 2.0, 0, f / 2.0);
      BallastBasePL.Add(g / 2.0, 0, f);
      BallastBasePL.Add(g / 2.0, 0, f + e);
      BallastBasePL.Add(c / 2.0, 0, f + e);
      BallastBasePL.Add(c / 2.0, 0, f + e + d);

      BallastBasePL.Add(-c / 2.0, 0, f + e + d);
      BallastBasePL.Add(-c / 2.0, 0, f + e);
      BallastBasePL.Add(-g / 2.0, 0, f + e);
      BallastBasePL.Add(-g / 2.0, 0, f);
      BallastBasePL.Add(-b / 2.0, 0, f / 2.0);
      BallastBasePL.Add(-b / 2.0, 0, 0);

      BallastBasePL.Add(b / 2.0, 0, 0);
      return BallastBasePL.ToNurbsCurve();
    }

    public static RealObject.Building GetRailroad(Curve[] RailCurves)
    {
      Brep[] brep1, brep2, brep3;
      GetRailroad(RailCurves, out brep1, out brep2, out brep3);
      RealObject.Building result = new RealObject.Building("Railroad");
      RealObject.Member mem;
      mem = result.Add("Rail", brep1);
      mem.Material = new RealObject.Material("Silver");
      mem = result.Add("Tie", brep2);
      mem.Material = new RealObject.Material("Wood");
      mem = result.Add("Ballast", brep3);
      mem.Material = new RealObject.Material("Stone");
      return result;
    }

    public static void GetRailroad(Curve[] RailCurves, out Brep[] Railroad, out Brep[] RailroadTie, out Brep[] TrackBallast)
    {
      double TrackGauge = 1067.0;
      GetRailroad(RailCurves, GetRailroadTrackShape(), TrackGauge, out Railroad, out RailroadTie, out TrackBallast);
    }

    public static void GetRailroad(Curve[] RailCurves, Curve TrackShape, double TrackGauge, out Brep[] Railroad, out Brep[] RailroadTie, out Brep[] TrackBallast)
    {
      GetRailroad(RailCurves, TrackShape, TrackGauge, TrackGauge * 2.0, 200, 50, 700, TrackGauge * 2.5, TrackGauge * 3.0, 140, out Railroad, out RailroadTie, out TrackBallast);
    }

    public static void GetRailroad(Curve[] RailCurves, Curve TrackShape, double TrackGauge, double TieWidth, double TieLength, double TieHeight, double TieSpace, double BallastWidthTop, double BallastWidthBottom, double BallastHeight, out Brep[] Railroad, out Brep[] RailroadTie, out Brep[] TrackBallast)
    {
      TrackGauge = Math.Abs(TrackGauge);
      List&lt;Brep&gt; ResultRoad = new List&lt;Brep&gt;();
      List&lt;Brep&gt; ResultTie = new List&lt;Brep&gt;();
      List&lt;Brep&gt; ResultBallast = new List&lt;Brep&gt;();

      Brep TieBase = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-TieWidth / 2.0, TieWidth / 2.0), new Interval(-TieLength / 2.0, TieLength / 2.0), new Interval(0, TieHeight)));

      Curve BallastBase = GetRailroadBallast(BallastWidthTop, BallastWidthBottom, BallastHeight);

      foreach (Curve RailCurve in RailCurves)
      {
        RailCurve.Domain = new Interval(0, 1.0);
        double RailLength = RailCurve.GetLength();

        Curve[] OffsetedCurves = new Curve[]{
          (RailCurve.Offset(Plane.WorldXY, TrackGauge / 2.0, TrackGauge / 100.0, CurveOffsetCornerStyle.Smooth))[0],
          (RailCurve.Offset(Plane.WorldXY, -TrackGauge / 2.0, TrackGauge / 100.0, CurveOffsetCornerStyle.Smooth))[0]};
        OffsetedCurves[0].Translate(0, 0, BallastHeight + TieHeight);
        OffsetedCurves[1].Translate(0, 0, BallastHeight + TieHeight);

        for (int i = 0; i &lt;= 1; i++)
        {
          Curve TempTrackShape = (Curve) TrackShape.Duplicate();
          OffsetedCurves[i].Domain = new Interval(0, 1);
          TempTrackShape.Rotate(GeneralHelper.GetCurvatureAsAngle(OffsetedCurves[i], 0), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
          TempTrackShape.Translate((Vector3d) OffsetedCurves[i].PointAtStart);
          ResultRoad.Add(Brep.CreateFromSweep(OffsetedCurves[i], TempTrackShape, true, TrackGauge / 1e6)[0].CapPlanarHoles(TrackGauge / 1e6));
        }

        if (TieHeight &gt; 0 &amp;&amp; TieWidth &gt; 0)
        {
          for (double CurrentLength = TieSpace; CurrentLength &lt; RailLength; CurrentLength += TieSpace)
          {
            double TempT;
            RailCurve.LengthParameter(CurrentLength, out TempT);
            Brep TempTie = (Brep) TieBase.Duplicate();
            TempTie.Rotate(GeneralHelper.GetCurvatureAsAngle(RailCurve, TempT), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
            TempTie.Translate((Vector3d) (RailCurve.PointAt(TempT)) + new Vector3d(0, 0, BallastHeight));
            ResultTie.Add(TempTie);
          }
        }
        if (BallastHeight &gt; 0)
        {
          Curve TempBallaseBase = (Curve) BallastBase.Duplicate();
          TempBallaseBase.Rotate(GeneralHelper.GetCurvatureAsAngle(RailCurve, 0), new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
          TempBallaseBase.Translate((Vector3d) RailCurve.PointAtStart);
          ResultBallast.Add(Brep.CreateFromSweep(RailCurve, TempBallaseBase, true, TrackGauge / 1e6)[0].CapPlanarHoles(TrackGauge / 1e6));
        }
      }
      Railroad = ResultRoad.ToArray();
      RailroadTie = ResultTie.ToArray();
      TrackBallast = ResultBallast.ToArray();
    }

    public static void GetTowerClane(double AngleClane, double AngleHead, out Brep[] Basement, out Brep[] LadderBasement, out Brep[] LiftFrame, out Brep[] RotationUnit,
      out Brep[] HeadHouseWall, out Brep[] HeadHouseGlass, out Brep[] HeadBody, out Brep[] HeadHandrail, out Brep[] HeadClaneBodyRed, out Brep[] HeadClaneBodyWhite, out Brep[] HeadClaneLadderRed, out Brep[] HeadClaneLadderWhite,
      out Brep[] HeadPole, out Brep[] HeadPoleWorkSpace, out Brep[] HeadClaneWorkSpace, out Brep[] HeadClaneWire)
    {
      Basement = GetTowerClaneBasement(20);
      LadderBasement = GeneralHelper.TranslateBreps(GetLadderSimple(20 * 800), new Point3d(0, 400, 0));
      LiftFrame = GeneralHelper.TranslateBreps(GetTowerClaneLiftFrame(1200, 2200), new Vector3d(0, 0, 20 * 800));
      RotationUnit = GeneralHelper.TranslateBreps(GetTowerClaneRotationUnit(600, 2300, 150, 2500), new Vector3d(0, 0, 20 * 800));

      Brep[] RetWall;
      Brep[] RetGlass;
      Brep[] RetBody;
      Brep[] RetHandrail;
      Brep[] RetPole;
      Brep[] ClaneWorkSpace;

      Brep[] RedBody;
      Brep[] WhiteBody;
      Brep[] ClaneLadderRed;
      Brep[] ClaneLadderWhite;
      Brep[] ClaneClaneWorkSpace;
      Brep[] Wire;

      GetTowerClaneHead(out RetBody, out RetHandrail, out RetWall, out RetGlass, out RetPole, out ClaneWorkSpace, AngleClane, out RedBody, out WhiteBody, out ClaneLadderRed, out ClaneLadderWhite, out ClaneClaneWorkSpace, 20000, out Wire);

      HeadHouseWall = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetWall, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadHouseGlass = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetGlass, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadBody = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetBody, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadHandrail = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetHandrail, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadPole = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RetPole, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadPoleWorkSpace = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneWorkSpace, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));

      HeadClaneBodyRed = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(RedBody, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadClaneBodyWhite = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(WhiteBody, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadClaneLadderRed = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneLadderRed, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadClaneLadderWhite = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneLadderWhite, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadClaneWorkSpace = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(ClaneClaneWorkSpace, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
      HeadClaneWire = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(Wire, new Point3d(0, 0, 20 * 800 + 600)), AngleHead, new Vector3d(0, 0, 1));
    }

    public static void GetTowerClaneClane(int Count, double Angle, double Width1, double Width2, double Length, double Space, double Radius1, double Radius2, out Brep[] Body1, out Brep[] Body2, out Brep[] Ladder1, out Brep[] Ladder2, out Brep[] WorkSpace)
    {
      Angle = -Angle;
      Count = Math.Max(Count, 2);
      List&lt;List&lt;Brep&gt;&gt; ResultBody = new List&lt;List&lt;Brep&gt;&gt;();
      ResultBody.Add(new List&lt;Brep&gt;());
      ResultBody.Add(new List&lt;Brep&gt;());
      ResultBody.Add(new List&lt;Brep&gt;());
      ResultBody.Add(new List&lt;Brep&gt;());

      ResultBody[0].AddRange(GeneralHelper.RotateBreps(GetTowerClaneClaneUnit(Width1, Width2, Length, Space, Radius1, Radius2), Angle, new Vector3d(0, 1, 0)));
      for (int i = 1; i + 1 &lt; Count; i++)
      {
        ResultBody[i % 2].AddRange(GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GetTowerClaneClaneUnit(Width2, Width2, Length, Space, Radius1, Radius2), new Vector3d(i * Length, 0, 0)), Angle, new Vector3d(0, 1, 0)));
      }
      Brep[] LadderBase = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GeneralHelper.RotateBreps(GetLadderSimple(Length), Math.PI / 2.0, new Vector3d(0, 0, 1)), new Vector3d(Width1 / 2.0, 0, 0)), Math.PI / 2.0, new Vector3d(0, 1, 0));
      for (int i = 0; i &lt; Count; i++)
      {
        ResultBody[i % 2 + 2].AddRange(GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GeneralHelper.DuplicateBreps(LadderBase), new Vector3d(i * Length, 0, 0)), Angle, new Vector3d(0, 1, 0)));
      }
      {
        int i = Count - 1;
        ResultBody[i % 2].AddRange(GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GetTowerClaneClaneUnit(Width2, Width1, Length, Space, Radius1, Radius2), new Vector3d(i * Length, 0, 0)), Angle, new Vector3d(0, 1, 0)));
      }
      {
        Brep[] WorkSpaceTemp = GetWorkSpace(Width1 * 2, Width1 * 2, 100);
        double WSAngle = Math.PI / 4.0;
        WorkSpace = GeneralHelper.RotateBreps(GeneralHelper.TranslateBreps(GeneralHelper.RotateBreps(WorkSpaceTemp, WSAngle, new Vector3d(0, 1, 0)), new Vector3d(Length * Count + Width1 * Math.Sin(WSAngle), 0, -Width1)), Angle, new Vector3d(0, 1, 0));
      }

      Body1 = ResultBody[0].ToArray();
      Body2 = ResultBody[1].ToArray();
      Ladder1 = ResultBody[2].ToArray();
      Ladder2 = ResultBody[3].ToArray();
    }



    public static Brep[] GetTowerClaneClaneUnit(double Width1, double Width2, double Length, double Space, double Radius1, double Radius2)
    {
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
      Polyline PartsPL = new Polyline(2);
      PartsPL.Add(0, Width1 / 2.0, Width1 / 2.0);
      PartsPL.Add(Length, Width2 / 2.0, Width2 / 2.0);
      Brep BaseParts1 = (Brep.CreateFromSweep(PartsPL.ToNurbsCurve(), GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius1)), PartsPL.ToNurbsCurve()), true, 1.0)[0]);
      for (int i = 0; i &lt; 4; i++)
      {
        Brep TempParts1 = (Brep) BaseParts1.Duplicate();
        TempParts1.Rotate(Math.PI / 2.0 * i, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
        Result.Add(TempParts1);
      }
      for (double CurrentLength = 0; CurrentLength &lt; Length; CurrentLength += Space)
      {
        PartsPL = new Polyline(2);
        PartsPL.Add(CurrentLength, (Width1 + (Width2 - Width1) * (CurrentLength / Length)) / 2.0, (Width1 + (Width2 - Width1) * (CurrentLength / Length)) / 2.0);
        PartsPL.Add((CurrentLength + Space / 2.0), -(Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0, (Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0);
        Brep BaseParts2 = (Brep.CreateFromSweep(PartsPL.ToNurbsCurve(), GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius1)), PartsPL.ToNurbsCurve()), true, 1.0)[0]);

        PartsPL = new Polyline(2);
        PartsPL.Add((CurrentLength + Space / 2.0), -(Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0, (Width1 + (Width2 - Width1) * ((CurrentLength + Space / 2.0) / Length)) / 2.0);
        PartsPL.Add((CurrentLength + Space), (Width1 + (Width2 - Width1) * ((CurrentLength + Space) / Length)) / 2.0, (Width1 + (Width2 - Width1) * ((CurrentLength + Space) / Length)) / 2.0);
        Brep BaseParts3 = (Brep.CreateFromSweep(PartsPL.ToNurbsCurve(), GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius1)), PartsPL.ToNurbsCurve()), true, 1.0)[0]);
        for (int i = 0; i &lt; 4; i++)
        {
          Brep TempParts2 = (Brep) BaseParts2.Duplicate();
          TempParts2.Rotate(Math.PI / 2.0 * i, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
          Result.Add(TempParts2);

          Brep TempParts3 = (Brep) BaseParts3.Duplicate();
          TempParts3.Rotate(Math.PI / 2.0 * i, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
          Result.Add(TempParts3);
        }
      }
      return Result.ToArray();
    }

    public static void GetTowerClaneCableRoller(double Width, double CableRadius, double Radius1, double Radius2, double Thickness, out Brep[] Body, out Brep[] Cable, out Point3d CableTarget)
    {
      Body = new Brep[]{Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), Thickness), true, true),
        Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), -Thickness), true, true)};

      List&lt;Curve&gt; Arcs = new List&lt;Curve&gt;();
      Curve BaseArc = NurbsCurve.CreateFromArc(new Arc(new Circle(new Plane(new Point3d(0, 0, 0), new Vector3d(1, 0, 0)), CableRadius), new Interval(0, Math.PI)));
      for (double CurrentLength = -Width / 2.0 + Thickness + (Width / 2.0 - Thickness) % (CableRadius * 2); CurrentLength &lt; Width / 2.0 - Thickness; CurrentLength += CableRadius)
      {
        Curve TempArc = (Curve) BaseArc.Duplicate();
        TempArc.Translate(new Vector3d(0, CurrentLength, Radius1));
        Arcs.Add(TempArc);
      }
      Brep TempCable = Brep.CreateFromRevSurface(RevSurface.Create(Curve.JoinCurves(Arcs)[0], new Line(new Point3d(0, 0, 0), new Point3d(0, 1, 0))), false, false);
      TempCable.Translate(0, 0, Radius2);
      Cable = new Brep[] { TempCable };

      CableTarget = new Point3d(Radius1 * Math.Cos(Math.PI * 3.0 / 4.0), 0, Radius1 * Math.Sin(Math.PI * 3.0 / 4.0) + Radius2);
    }

    public static void GetTowerClaneCableRollerLight(double Width, double CableRadius, double Radius1, double Radius2, double Thickness, out Brep[] Body, out Brep[] Cable, out Point3d CableTarget)
    {
      Body = new Brep[]{Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), Thickness), true, true),
        Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, Width / 2.0, Radius2), new Vector3d(0, 1, 0)), Radius2), -Thickness), true, true)};
      Cable = new Brep[] { Brep.CreateFromCylinder(new Cylinder(new Circle(new Plane(new Point3d(0, -Width / 2.0 + Thickness, Radius2), new Vector3d(0, 1, 0)), Radius1), Width - Thickness * 2), false, false) };
      CableTarget = new Point3d(Radius1 * Math.Cos(Math.PI * 3.0 / 4.0), 0, Radius1 * Math.Sin(Math.PI * 3.0 / 4.0) + Radius2);
    }

    public static Brep[] GetWorkSpace(double Width, double Length, double Thickness)
    {
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
      Result.Add(Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-Length / 2.0, Length / 2.0), new Interval(-Width / 2.0, Width / 2.0), new Interval(-Thickness, 0))));

      Polyline HandrailBase = new Polyline();
      double HRRadius = 25;
      HandrailBase.Add(Length / 2.0 - HRRadius * 2, Width / 2.0 - HRRadius * 2, 0);
      HandrailBase.Add(Length / 2.0 - HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
      HandrailBase.Add(-Length / 2.0 + HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
      HandrailBase.Add(-Length / 2.0 + HRRadius * 2, Width / 2.0 - HRRadius * 2, 0);
      HandrailBase.Add(Length / 2.0 - HRRadius * 2, Width / 2.0 - HRRadius * 2, 0);
      Result.AddRange(GetHandrailSimple(HandrailBase.ToNurbsCurve(), 800, new double[] { 400, 600 }, 500, HRRadius, 15, 10));

      return Result.ToArray();
    }

    public static Brep[] GetTowerClanePole(double Width, double Length, double Height, double Size1, double Size2, double Radius, double Space)
    {
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
      {
        Polyline BasePoly = new Polyline(5);
        BasePoly.Add(0, -Width / 2.0, 0);
        BasePoly.Add(Size1, -Width / 2.0, 0);
        BasePoly.Add(Size1, -Width / 2.0 + Size1, 0);
        BasePoly.Add(0, -Width / 2.0 + Size1, 0);
        BasePoly.Add(0, -Width / 2.0, 0);
        Brep TempBrep = (Brep.CreateFromSurface(Surface.CreateExtrusion(BasePoly.ToNurbsCurve(), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
        Result.Add(TempBrep);
        TempBrep = (Brep) TempBrep.Duplicate();
        TempBrep.Translate(0, Width - Size1, 0);
        Result.Add(TempBrep);
      }
      {
        Polyline BasePoly = new Polyline(5);
        BasePoly.Add(Length, -Width / 2.0, 0);
        BasePoly.Add(Length - Size2, -Width / 2.0, 0);
        BasePoly.Add(Length - Size2, -Width / 2.0 + Size2, 0);
        BasePoly.Add(Length, -Width / 2.0 + Size2, 0);
        BasePoly.Add(Length, -Width / 2.0, 0);
        Brep TempBrep = (Brep.CreateFromSurface(Surface.CreateExtrusion(BasePoly.ToNurbsCurve(), new Vector3d(-Length + Size1, 0, Height))).CapPlanarHoles(0));
        Result.Add(TempBrep);
        TempBrep = (Brep) TempBrep.Duplicate();
        TempBrep.Translate(0, Width - Size2, 0);
        Result.Add(TempBrep);
      }
      for (double CrtLen = Space; CrtLen &lt; Height; CrtLen += Space)
      {
        Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Plane(new Point3d(Size1 / 2.0, -Width / 2.0 + Size1, CrtLen), new Vector3d(0, 1, 0)), Radius))
          , new Vector3d(0, Width - Size1 * 2, 0))));
      }

      return Result.ToArray();
    }

    public static void GetTowerClaneHead(out Brep[] Body, out Brep[] Handrail, out Brep[] Wall, out Brep[] Glass, out Brep[] Pole
      , out Brep[] WorkSpace, double Angle, out Brep[] RedBody, out Brep[] WhiteBody, out Brep[] ClaneLadderRed, out Brep[] ClaneLadderWhite, out Brep[] ClaneWorkSpace, double WireLength, out Brep[] Wire)
    {

      GetTowerClaneHeadBase(4.5e3, 9e3, 500, out Body, out Handrail, out Wall, out Glass);
      Pole = GeneralHelper.TranslateBreps(GetTowerClanePole(4.5e3 / 3.0 + 500, 9e3 * 2 / 3, 10e3, 400, 400, 80, 2000), new Vector3d(-9e3 / 2.0, 0, 500));
      WorkSpace = GeneralHelper.TranslateBreps(GetWorkSpace(4.5e3 / 3.0 + 1e3, 1e3, 100), new Vector3d(-9e3 / 2.0 - (1e3) / 2.0 + 400, 0, 500 + 10e3 + 100));
      {
        Brep[] ResultClane1;
        Brep[] ResultClane2;
        Brep[] ResultClane3;
        Brep[] ResultClane4;
        Brep[] ResultClane5;

        GetTowerClaneClane(5, Angle, 500, 1000, 5000, 1000, 25, 10, out ResultClane1, out ResultClane2, out ResultClane3, out ResultClane4, out ResultClane5);
        RedBody = GeneralHelper.TranslateBreps(ResultClane1, new Vector3d(0, 0, 500 + 500));
        WhiteBody = GeneralHelper.TranslateBreps(ResultClane2, new Vector3d(0, 0, 500 + 500));
        ClaneLadderRed = GeneralHelper.TranslateBreps(ResultClane3, new Vector3d(0, 0, 500 + 500));
        ClaneLadderWhite = GeneralHelper.TranslateBreps(ResultClane4, new Vector3d(0, 0, 500 + 500));
        ClaneWorkSpace = GeneralHelper.TranslateBreps(ResultClane5, new Vector3d(0, 0, 500 + 500));
      }
      {
        double WireRadius = 25;
        List&lt;Brep&gt; ResultWire = new List&lt;Brep&gt;();
        {
          Polyline WirePL = new Polyline();
          WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) + 1e3 / 2.0, 0, 500 + 10e3 + 100 + 400);
          WirePL.Add(5 * 5000 * Math.Cos(Angle), 0, 500 + 500 + 5 * 5000 * Math.Sin(Angle));

          Curve RailCurve = WirePL.ToNurbsCurve();
          RailCurve.Rotate(-Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
          Brep WireBase = (Brep.CreateFromSweep(RailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(WireRadius)), RailCurve), true, 0.1)[0]).CapPlanarHoles(0);
          WireBase.Rotate(Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));

          Brep WireTemp = (Brep) WireBase.Duplicate();
          WireTemp.Translate(0, (500 / 2.0), 0);
          ResultWire.Add(WireTemp);

          WireTemp = (Brep) WireBase.Duplicate();
          WireTemp.Translate(0, -(500 / 2.0), 0);
          ResultWire.Add(WireTemp);
        }
        {
          Polyline WirePL = new Polyline();
          WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) - 1e3 / 2.0 - 1e3, 0, 500);
          WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) - 1e3 / 2.0, 0, 500 + 10e3 + 100 + 400);
          WirePL.Add((-9e3 / 2.0 - 1e3 / 2.0 + 400) + 1e3 / 2.0, 0, 500 + 10e3 + 100 + 400);
          WirePL.Add(5 * 5000 * Math.Cos(Angle), 0, 500 + 500 + 5 * 5000 * Math.Sin(Angle));
          WirePL.Add(5 * 5000 * Math.Cos(Angle), 0, 500 + 500 + 5 * 5000 * Math.Sin(Angle) - WireLength);

          Curve RailCurve = WirePL.ToNurbsCurve();
          RailCurve.Rotate(-Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));
          Brep WireBase = (Brep.CreateFromSweep(RailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(WireRadius)), RailCurve), true, 0.1)[0]).CapPlanarHoles(0);
          WireBase.Rotate(Math.PI / 2.0, new Vector3d(1, 0, 0), new Point3d(0, 0, 0));

          Brep WireTemp = (Brep) WireBase.Duplicate();
          WireTemp.Translate(0, (500 / 2.0) / 3.0, 0);
          ResultWire.Add(WireTemp);

          WireTemp = (Brep) WireBase.Duplicate();
          WireTemp.Translate(0, -(500 / 2.0) / 3.0, 0);
          ResultWire.Add(WireTemp);
        }
        Wire = ResultWire.ToArray();
      }
    }


    public static void GetTowerClaneHeadBase(double Width, double Length, double Thickness, out Brep[] Body, out Brep[] Handrail, out Brep[] Wall, out Brep[] Glass)
    {
      GetTowerClaneControlUnit(Width / 3.0, Length / 2.0, Length / 2.0 + 500, 1.0e3, 2.5e3, 1.0e3, 150, out Wall, out Glass);
      Wall = GeneralHelper.TranslateBreps(Wall, new Point3d(-Length / 4.0, -Width / 2.0 - 500, Thickness));
      Glass = GeneralHelper.TranslateBreps(Glass, new Point3d(-Length / 4.0, -Width / 2.0 - 500, Thickness));
      Body = new Brep[] { Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-Length * 3.0 / 4.0, Length / 4.0), new Interval(-Width / 2.0, Width / 2.0), new Interval(0, Thickness))) };

      Polyline HandrailBase = new Polyline();
      double HRRadius = 25;
      HandrailBase.Add(-Length / 4.0 - HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
      HandrailBase.Add(-Length * 3.0 / 4.0 + HRRadius * 2, -Width / 2.0 + HRRadius * 2, 0);
      HandrailBase.Add(-Length * 3.0 / 4.0 + HRRadius * 2, +Width / 2.0 - HRRadius * 2, 0);
      HandrailBase.Add(Length / 4.0 - HRRadius * 2, +Width / 2.0 - HRRadius * 2, 0);
      Handrail = GeneralHelper.TranslateBreps(GetHandrailSimple(HandrailBase.ToNurbsCurve(), 800, new double[] { 400, 600 }, 500, HRRadius, 15, 10), new Vector3d(0, 0, Thickness));
    }

    public static void GetTowerClaneControlUnit(out Brep[] Wall, out Brep[] Glass)
    {
      GetTowerClaneControlUnit(1.5e3, 5e3, 5.5e3, 1.0e3, 2.5e3, 1.0e3, 150, out Wall, out Glass);
    }

    public static void GetTowerClaneControlUnit(double Width, double BottomLength, double TopLength, double SideWindowLength, double Height, double BarHeight, double FrameWidth, out Brep[] Wall, out Brep[] Glass)
    {
      double WallThickness = 50.0;
      List&lt;Brep&gt; RetWall = new List&lt;Brep&gt;();
      {
        Polyline Parts1PL = new Polyline(13);
        Parts1PL.Add(0, 0, 0);
        Parts1PL.Add(BottomLength, 0, 0);
        Parts1PL.Add(BottomLength, 0, FrameWidth);
        Parts1PL.Add(BottomLength - SideWindowLength, 0, FrameWidth);
        Parts1PL.Add(BottomLength - SideWindowLength, 0, BarHeight);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height, 0, BarHeight);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * (BarHeight + FrameWidth) / Height, 0, (BarHeight + FrameWidth));
        Parts1PL.Add(BottomLength - SideWindowLength, 0, (BarHeight + FrameWidth));
        Parts1PL.Add(BottomLength - SideWindowLength, 0, (Height - FrameWidth));
        Parts1PL.Add(TopLength - (TopLength - BottomLength) * FrameWidth / Height, 0, (Height - FrameWidth));
        Parts1PL.Add(TopLength, 0, Height);
        Parts1PL.Add(0, 0, Height);
        Parts1PL.Add(0, 0, 0);
        Curve Part1Curve = Parts1PL.ToNurbsCurve();
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, -WallThickness, 0))).CapPlanarHoles(0));
        Part1Curve.Translate(0, Width, 0);
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, WallThickness, 0))).CapPlanarHoles(0));
      }
      {
        Polyline Parts1PL = new Polyline(5);
        Parts1PL.Add(BottomLength, 0, 0);
        Parts1PL.Add(TopLength, 0, Height);
        Parts1PL.Add(TopLength - FrameWidth, 0, Height);
        Parts1PL.Add(BottomLength - FrameWidth, 0, 0);
        Parts1PL.Add(BottomLength, 0, 0);
        Curve Part1Curve = Parts1PL.ToNurbsCurve();
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, -WallThickness, 0))).CapPlanarHoles(0));
        Part1Curve.Translate(0, Width, 0);
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, WallThickness, 0))).CapPlanarHoles(0));
        Part1Curve.Translate(0, -Width / 2.0 - FrameWidth / 2.0, 0);
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, FrameWidth, 0))).CapPlanarHoles(0));
      }
      {
        Polyline Parts1PL = new Polyline(5);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height, 0, BarHeight);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * (BarHeight + FrameWidth) / Height, 0, (BarHeight + FrameWidth));
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * (BarHeight + FrameWidth) / Height - WallThickness, 0, (BarHeight + FrameWidth));
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height - WallThickness, 0, BarHeight);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * BarHeight / Height, 0, BarHeight);
        Curve Part1Curve = Parts1PL.ToNurbsCurve();
        Part1Curve.Translate(0, -WallThickness / 2.0, 0);
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, Width + WallThickness, 0))).CapPlanarHoles(0));
      }
      {
        Polyline Parts1PL = new Polyline(13);
        Parts1PL.Add(0, 0, 0);
        Parts1PL.Add(BottomLength, 0, 0);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * FrameWidth / Height, 0, FrameWidth);
        Parts1PL.Add(BottomLength + (TopLength - BottomLength) * FrameWidth / Height - WallThickness, 0, FrameWidth);
        Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
        Parts1PL.Add(WallThickness, 0, WallThickness);
        Parts1PL.Add(WallThickness, 0, Height - WallThickness);
        Parts1PL.Add(TopLength - WallThickness, 0, Height - WallThickness);
        Parts1PL.Add(TopLength - (TopLength - BottomLength) * FrameWidth / Height - WallThickness, 0, (Height - FrameWidth));
        Parts1PL.Add(TopLength - (TopLength - BottomLength) * FrameWidth / Height, 0, (Height - FrameWidth));
        Parts1PL.Add(TopLength, 0, Height);
        Parts1PL.Add(0, 0, Height);
        Parts1PL.Add(0, 0, 0);
        Curve Part1Curve = Parts1PL.ToNurbsCurve();
        Part1Curve.Translate(0, -WallThickness / 2.0, 0);
        RetWall.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, Width + WallThickness, 0))).CapPlanarHoles(0));
      }
      List&lt;Brep&gt; RetGlass = new List&lt;Brep&gt;();
      {
        Polyline Parts1PL = new Polyline(5);
        Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
        Parts1PL.Add(TopLength - WallThickness, 0, Height - WallThickness);
        Parts1PL.Add(TopLength - WallThickness * 2, 0, Height - WallThickness);
        Parts1PL.Add(BottomLength - WallThickness * 2, 0, WallThickness);
        Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
        Curve Part1Curve = Parts1PL.ToNurbsCurve();
        RetGlass.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, Width, 0))).CapPlanarHoles(0));
      }
      {
        Polyline Parts1PL = new Polyline(5);
        Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
        Parts1PL.Add(TopLength - WallThickness, 0, Height - WallThickness);
        Parts1PL.Add(BottomLength - WallThickness - SideWindowLength, 0, Height - WallThickness);
        Parts1PL.Add(BottomLength - WallThickness - SideWindowLength, 0, WallThickness);
        Parts1PL.Add(BottomLength - WallThickness, 0, WallThickness);
        Curve Part1Curve = Parts1PL.ToNurbsCurve();
        RetGlass.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, WallThickness, 0))).CapPlanarHoles(0));
        Part1Curve.Translate(0, Width, 0);
        RetGlass.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(Part1Curve, new Vector3d(0, -WallThickness, 0))).CapPlanarHoles(0));
      }
      Wall = RetWall.ToArray();
      Glass = RetGlass.ToArray();
    }

    public static Brep[] GetHandrailSimple(Curve BaseCurve, double Height, double[] RailHeight, double Space, double Radius1, double Radius2, double Radius3)
    {
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
      {
        Curve TopRailCurve = (Curve) BaseCurve.Duplicate();
        TopRailCurve.Translate(0, 0, Height);
        Result.Add(Brep.CreateFromSweep(TopRailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius2)), TopRailCurve), true, Space / 1000)[0]);
      }
      foreach (double TempHeight in RailHeight)
      {
        Curve TopRailCurve = (Curve) BaseCurve.Duplicate();
        TopRailCurve.Translate(0, 0, TempHeight);
        Result.Add(Brep.CreateFromSweep(TopRailCurve, GeneralHelper.GetCurveForSweep(NurbsCurve.CreateFromCircle(new Circle(Radius3)), TopRailCurve), true, Space / 1000)[0]);
      }
      double Length = BaseCurve.GetLength();
      for (double CurrentLength = 0; CurrentLength &lt; Length; CurrentLength += Space)
      {
        Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(BaseCurve.PointAtLength(CurrentLength), Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
      }
      if (!BaseCurve.IsClosed)
      {
        Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(BaseCurve.PointAtLength(Length), Radius1)), new Vector3d(0, 0, Height))).CapPlanarHoles(0));
        Result[0] = Result[0].CapPlanarHoles(0);
        for (int i = 0; i &lt; RailHeight.GetLength(0); i++)
        {
          Result[1 + i] = Result[1 + i].CapPlanarHoles(0);
        }
      }

      return Result.ToArray();
    }

    public static Brep[] GetTowerClaneRotationUnit(double Height1, double Radius1, double Height2, double Radius2)
    {
      Brep Cylinder2 = Brep.CreateFromCylinder(new Cylinder(new Circle(Radius2 / 2.0), Height2), true, true);
      Cylinder2.Translate(0, 0, Height1 - Height2);
      return new Brep[]{
        Brep.CreateFromCylinder(new Cylinder(new Circle(Radius1 / 2.0), Height1), true, false),Cylinder2
        };
    }

    public static Brep[] GetTowerClaneLiftFrame(double Size1, double Size2)
    {
      Brep[] Parts1;
      Brep[] Parts2;
      Brep[] Parts3;
      GetTowerClaneLiftFrame(Size1, Size2, out Parts1, out Parts2, out Parts3);
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
      Result.AddRange(Parts1);
      Result.AddRange(Parts2);
      Result.AddRange(Parts3);
      return Result.ToArray();
    }

    public static void GetTowerClaneLiftFrame(double Size1, double Size2, out Brep[] Parts1, out Brep[] Parts2, out Brep[] Parts3)
    {
      double UnitHeight = Size1 * 0.8;
      int UnitCount = 4;
      double TotalHeight = UnitHeight * UnitCount;
      double Elevation = 200;

      Parts1 = GeneralHelper.TranslateBreps(GetTowerClaneBasement(UnitCount, Size1, UnitHeight, 30, 150, 100), new Vector3d(0, 0, -TotalHeight - Elevation));
      double HandrailRadius = 25.0;
      Brep[] HandrailBase = GetHandrailSimple((new Rhino.Geometry.Rectangle3d(Plane.WorldXY, new Interval(-Size2 / 2.0 + HandrailRadius, Size2 / 2.0 - HandrailRadius), new Interval(-Size2 / 2.0 + HandrailRadius, Size2 / 2.0 - HandrailRadius))
        ).ToNurbsCurve(), 800, new double[] { 500 }, 500, HandrailRadius, 15, 10);
      List&lt;Brep&gt; RetParts2 = new List&lt;Brep&gt;();
      RetParts2.AddRange(GeneralHelper.TranslateBreps(HandrailBase, new Vector3d(0, 0, -TotalHeight - Elevation)));
      RetParts2.AddRange(GeneralHelper.TranslateBreps(HandrailBase, new Vector3d(0, 0, -TotalHeight / 2.0 - Elevation)));
      Parts2 = RetParts2.ToArray();

      List&lt;Brep&gt; RetParts3 = new List&lt;Brep&gt;();

      Brep[] FloorBase = new Brep[4];
      {
        double Size3 = Size1 + 30 * 2;
        double Parts3Width = 10.0;
        double Parts3Bending = 50.0;
        Polyline Parts3PL = new Polyline(9);
        Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0, 0);
        Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0, 0);
        Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0, -Parts3Bending);
        Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0 - Parts3Width, -Parts3Bending);
        Parts3PL.Add(-Size2 / 2.0, -Size3 / 2.0 - Parts3Width, -Parts3Width);
        Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0 + Parts3Width, -Parts3Width);
        Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0 + Parts3Width, -Parts3Bending);
        Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0, -Parts3Bending);
        Parts3PL.Add(-Size2 / 2.0, -Size2 / 2.0, 0);
        Brep FloorBasePart = Brep.CreateFromSurface(Surface.CreateExtrusion(Parts3PL.ToNurbsCurve(), new Vector3d(Size2 / 2.0 + Size3 / 2.0, 0, 0))).CapPlanarHoles(0);

        for (int i = 0; i &lt; 4; i++)
        {
          Brep TempFloor = (Brep) FloorBasePart.Duplicate();
          TempFloor.Rotate(Math.PI / 2.0 * i, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
          FloorBase[i] = TempFloor;
        }
      }
      RetParts3.AddRange(GeneralHelper.TranslateBreps(FloorBase, new Vector3d(0, 0, -TotalHeight - Elevation)));
      RetParts3.AddRange(GeneralHelper.TranslateBreps(FloorBase, new Vector3d(0, 0, -TotalHeight / 2.0 - Elevation)));
      Parts3 = RetParts3.ToArray();
    }

    public static Brep[] GetLadderSimple(double Length)
    {
      return GetLadderSimple(Length, 300, 400, 25, 15);
    }

    public static Brep[] GetLadderSimple(double Length, double Space, double Width, double Radius1, double Radius2)
    {
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();
      Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Point3d(-Width / 2.0, 0, 0), Radius1)), new Vector3d(0, 0, Length))).CapPlanarHoles(0));
      Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Point3d(+Width / 2.0, 0, 0), Radius1)), new Vector3d(0, 0, Length))).CapPlanarHoles(0));

      for (double CurrentLength = Space; CurrentLength &lt; Length; CurrentLength += Space)
      {
        Result.Add(Brep.CreateFromSurface(Surface.CreateExtrusion(NurbsCurve.CreateFromCircle(new Circle(new Plane(new Point3d(-Width / 2.0, 0, CurrentLength), new Vector3d(1, 0, 0)), Radius2)), new Vector3d(Width, 0, 0))).CapPlanarHoles(0));
      }
      return Result.ToArray();
    }


    public static Brep[] GetTowerClaneBasement(int Count)
    {
      return GetTowerClaneBasement(Count, 1000, 800, 30, 150, 100);
    }

    public static Brep[] GetTowerClaneBasement(int Count, double UnitWidth, double UnitHeight, double Thickness, double Width1, double Width2)
    {
      double Tr1 = UnitWidth / 2.0 - Width1 / 2.0;
      double Tr2 = UnitHeight - Width2;
      double Tr3 = Math.Sqrt(Tr1 * Tr1 + Tr2 * Tr2);

      Polyline BasePL1 = new Polyline(7);
      BasePL1.Add(0, 0, 0);
      BasePL1.Add(Width1, 0, 0);
      BasePL1.Add(Width1, -Thickness, 0);
      BasePL1.Add(-Thickness, -Thickness, 0);
      BasePL1.Add(-Thickness, Width1, 0);
      BasePL1.Add(0, Width1, 0);
      BasePL1.Add(0, 0, 0);
      Brep Parts1 = Brep.CreateFromSurface(Surface.CreateExtrusion((BasePL1.ToNurbsCurve()), new Vector3d(0, 0, UnitHeight * Count))).CapPlanarHoles(0);
      Parts1.Translate(-UnitWidth / 2.0, -UnitWidth / 2.0, 0);

      Polyline BasePL3 = new Polyline(12);
      BasePL3.Add(Width1 / 2.0, 0, 0);
      BasePL3.Add(UnitWidth / 2.0, 0, UnitHeight - Width2);
      BasePL3.Add(UnitWidth - Width1 / 2.0, 0, 0);
      BasePL3.Add(UnitWidth - Width1 / 2.0, 0, Width2 / Tr1 * Tr3);
      BasePL3.Add(UnitWidth / 2.0 + Width2 / Tr2 * Tr3, 0, UnitHeight - Width2);
      BasePL3.Add(UnitWidth - Width1 / 2.0, 0, UnitHeight - Width2);
      BasePL3.Add(UnitWidth - Width1 / 2.0, 0, UnitHeight);

      BasePL3.Add(Width1 / 2.0, 0, UnitHeight);
      BasePL3.Add(Width1 / 2.0, 0, UnitHeight - Width2);
      BasePL3.Add(UnitWidth / 2.0 - Width2 / Tr2 * Tr3, 0, UnitHeight - Width2);
      BasePL3.Add(Width1 / 2.0, 0, Width2 / Tr1 * Tr3);
      BasePL3.Add(Width1 / 2.0, 0, 0);
      Brep Parts3 = Brep.CreateFromSurface(Surface.CreateExtrusion((BasePL3.ToNurbsCurve()), new Vector3d(0, Thickness, 0))).CapPlanarHoles(0);
      Parts3.Translate(-UnitWidth / 2.0, -UnitWidth / 2.0, 0);

      Brep[] Result = new Brep[4 + Count * 4];
      for (int i = 0; i &lt; 4; i++)
      {
        Brep TempParts1 = (Brep) Parts1.Duplicate();
        TempParts1.Rotate(Math.PI / 2.0 * i, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
        Result[i] = TempParts1;

        for (int j = 0; j &lt; Count; j++)
        {
          Brep TempParts3 = (Brep) Parts3.Duplicate();
          TempParts3.Rotate(Math.PI / 2.0 * i, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
          TempParts3.Translate(0, 0, j * UnitHeight);
          Result[4 + j * 4 + i] = TempParts3;
        }
      }
      return Result;
    }


    public static void GetGlassWithSpandrel(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
    {
      double SpandrelSpace = FrameSize;
      double SpandrelSpaceZ = GlassThickness * 2;
      double SpandrelThickness = GlassThickness;

      GetGlassWithSpandrel(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, SpandrelHeight, SpandrelSpace, SpandrelSpaceZ, SpandrelThickness, out Frame, out Glass, out Spandrel);
    }

    public static void GetGlassWithSpandrel(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, double SpandrelSpace, double SpandrelSpaceZ, double SpandrelThickness, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
    {
      Brep BaseFrame;
      GetGlassSimple(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, out BaseFrame, out Glass);
      Spandrel = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(SpandrelSpace, SpandrelHeight - SpandrelSpace), new Interval(SpandrelSpace, WindowWidth - SpandrelSpace), new Interval(SpandrelSpaceZ, SpandrelSpaceZ + SpandrelThickness)));
      Brep SpandrelFrame = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(SpandrelHeight - FrameSize, SpandrelHeight), new Interval(FrameSize / 2.0, WindowWidth - FrameSize / 2.0), new Interval(-FrameThickness, GlassThickness)));
      Frame = new Brep[] { BaseFrame, SpandrelFrame };
    }

    public static void GetGlassWithSpandrelUpsidedown(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
    {
      double SpandrelSpace = FrameSize;
      double SpandrelSpaceZ = GlassThickness * 2;
      double SpandrelThickness = GlassThickness;

      GetGlassWithSpandrelUpsidedown(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, SpandrelHeight, SpandrelSpace, SpandrelSpaceZ, SpandrelThickness, out Frame, out Glass, out Spandrel);
    }

    public static void GetGlassWithSpandrelUpsidedown(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, double SpandrelHeight, double SpandrelSpace, double SpandrelSpaceZ, double SpandrelThickness, out Brep[] Frame, out Brep Glass, out Brep Spandrel)
    {
      Brep BaseFrame;
      GetGlassSimple(WindowWidth, WindowHeight, FrameSize, FrameThickness, GlassThickness, out BaseFrame, out Glass);
      Spandrel = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, WindowHeight - SpandrelHeight), new Vector3d(0, 1, 0)), new Interval(SpandrelSpace, SpandrelHeight - SpandrelSpace), new Interval(SpandrelSpace, WindowWidth - SpandrelSpace), new Interval(SpandrelSpaceZ, SpandrelSpaceZ + SpandrelThickness)));
      Brep SpandrelFrame = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(WindowHeight - SpandrelHeight, WindowHeight - SpandrelHeight + FrameSize), new Interval(FrameSize / 2.0, WindowWidth - FrameSize / 2.0), new Interval(-FrameThickness, GlassThickness)));
      Frame = new Brep[] { BaseFrame, SpandrelFrame };
    }

    public static void GetGlassSimple(double WindowWidth, double WindowHeight, double FrameSize, double FrameThickness, double GlassThickness, out Brep Frame, out Brep Glass)
    {
      GetGlassSimple(WindowWidth, WindowHeight, FrameSize, FrameSize, FrameThickness, GlassThickness, out Frame, out Glass);
    }

    public static void GetGlassSimple(double WindowWidth, double WindowHeight, double FrameSizeX, double FrameSizeY, double FrameThickness, double GlassThickness, out Brep Frame, out Brep Glass)
    {
      Brep FrameBase = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(0, WindowHeight), new Interval(0, WindowWidth), new Interval(-FrameThickness, GlassThickness)));
      Brep Splitter = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(FrameSizeY, WindowHeight - FrameSizeY), new Interval(FrameSizeX, WindowWidth - FrameSizeX), new Interval(-FrameThickness * 2, GlassThickness * 2)));
      var SplitResult = (FrameBase.Split(Splitter, 0.10));
      Frame = SplitResult[0];
      Glass = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, 0), new Vector3d(0, 1, 0)), new Interval(FrameSizeY, WindowHeight - FrameSizeY), new Interval(FrameSizeX, WindowWidth - FrameSizeX), new Interval(0, GlassThickness)));
    }

    public static void GetIsolatedWindow(double FrameSizeX, double FrameSizeY, double FrameThickness1, double FrameThickness2, double UnitSizeX, double UnitSizeY, double GlassThickness, int UnitCountX, int UnitCountY, out Brep[] Glass, out Brep[] Frame1, out Brep[] Frame2)
    {
      Frame1 = new Brep[UnitCountY * 2];
      for (int i = 0; i &lt; UnitCountY; i++)
      {
        Frame1[i * 2] = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, UnitSizeY * i), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(0, UnitSizeX * UnitCountX), new Interval(0, FrameSizeY), new Interval(-GlassThickness, FrameThickness1)));
        Frame1[i * 2 + 1] = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, 0, UnitSizeY * (i + 1)), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(0, UnitSizeX * UnitCountX), new Interval(-FrameSizeY, 0), new Interval(-GlassThickness, FrameThickness1)));
      }
      Frame2 = new Brep[UnitCountX * 2];
      for (int i = 0; i &lt; UnitCountX; i++)
      {
        Frame2[i * 2] = Brep.CreateFromBox(new Box(new Plane(new Point3d(UnitSizeX * i, 0, 0), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(0, FrameSizeX), new Interval(0, UnitSizeY * UnitCountY), new Interval(-GlassThickness, FrameThickness2)));
        Frame2[i * 2 + 1] = Brep.CreateFromBox(new Box(new Plane(new Point3d(UnitSizeX * (i + 1), 0, 0), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(-FrameSizeX, 0), new Interval(0, UnitSizeY * UnitCountY), new Interval(-GlassThickness, FrameThickness2)));
      }
      Glass = new Brep[UnitCountX * UnitCountY];
      for (int i = 0; i &lt; UnitCountX; i++)
      {
        for (int j = 0; j &lt; UnitCountY; j++)
        {
          Glass[i * UnitCountY + j] = Brep.CreateFromBox(new Box(new Plane(new Point3d(UnitSizeX * i, 0, UnitSizeY * j), new Vector3d(1, 0, 0), new Vector3d(0, 0, 1)), new Interval(FrameSizeX, UnitSizeX - FrameSizeX), new Interval(FrameSizeY, UnitSizeY - FrameSizeY), new Interval(-GlassThickness, 0)));
        }
      }
    }

    public static Brep GetStairsSolid(int Count, double StairWidth, double StairHeight, double StairLength, double StairThicknss)
    {
      StairThicknss = Math.Max(1, Math.Abs(StairThicknss));
      Rhino.Geometry.Polyline pl = new Polyline(4 + Count * 2);
      pl.Add(0, StairLength * (Count), StairHeight * (Count));
      pl.Add(0, StairLength * (Count), StairHeight * (Count) - StairThicknss);
      pl.Add(0, StairLength, StairHeight - StairThicknss);
      pl.Add(0, 0, StairHeight - StairThicknss);
      for (int i = 1; i &lt;= Count; i++)
      {
        pl.Add(0, StairLength * (i - 1), StairHeight * i);
        pl.Add(0, StairLength * (i), StairHeight * i);
      }
      return Brep.CreateFromSurface(Surface.CreateExtrusion((pl.ToNurbsCurve()), new Vector3d(StairWidth, 0, 0))).CapPlanarHoles(0);
    }

    public static Brep[] GetStairsSimple(int Count, double StairWidth, double StairHeight, double StairLength1, double StairLength2, double StairThickness)
    {
      Brep[] result = new Brep[Count];
      for (int i = 1; i &lt;= Count; i++)
      {
        result[i - 1] = Brep.CreateFromBox(new Box(new Plane(new Point3d(0, StairLength2 * (i - 1), StairHeight * i), new Vector3d(1, 0, 0), new Vector3d(0, 1, 0))
          , new Interval(0, StairWidth), new Interval(0, StairLength1), new Interval(-StairThickness, 0)));
      }
      return result;
    }

    public static void GetStairsBasic(int Count, double StairWidth, double StairHeight, double StairLength1, double StairLength2, double StairThickness, double OtherThickness, out Brep[] Stairs, out Brep[] Other)
    {
      Stairs = GetStairsSimple(Count, StairWidth, StairHeight, StairLength1, StairLength2, StairThickness);

      Rhino.Geometry.Polyline pl = new Polyline(7);
      pl.Add(0, 0, StairHeight - StairThickness);
      pl.Add(0, StairLength1, StairHeight - StairThickness);
      pl.Add(0, StairLength1 + StairLength2 * Count, StairHeight * (Count + 1) - StairThickness);
      pl.Add(0, StairLength1 + StairLength2 * Count, StairHeight * (Count + 1));
      pl.Add(0, StairLength2 * Count, StairHeight * (Count + 1));
      pl.Add(0, 0, StairHeight);
      pl.Add(0, 0, StairHeight - StairThickness);

      Curve plc = pl.ToNurbsCurve();
      Brep otherSrf1 = Brep.CreateFromSurface(Surface.CreateExtrusion(plc, new Vector3d(-OtherThickness, 0, 0))).CapPlanarHoles(0);
      Brep otherSrf2 = (Brep) otherSrf1.Duplicate();
      otherSrf2.Translate(StairWidth + OtherThickness, 0, 0);
      Other = new Brep[] { otherSrf1, otherSrf2 };
    }

    public static Brep[] GetTactilePavingAlongCurve(Curve[] Target)
    {
      double UnitSize = 302.5;
      List&lt;Brep&gt; Result = new List&lt;Brep&gt;();

      Brep TPP = GetTactilePavingPoint();
      Brep TPL = GetTactilePavingLine();

      foreach (Curve cv in Target)
      {
        double length = cv.GetLength();
        double t;
        Vector3d Normal;
        cv.Domain = new Interval(0, 1);
        if (length &lt; UnitSize * 3)
        {
          Normal = cv.CurvatureAt(0);
          cv.LengthParameter(length / 2.0, out t);
          Result.Add(GetTactilePavingAlongCurveHelper1(TPP, cv, t));
        }
        Result.AddRange(GetTactilePavingAlongCurveHelper2(TPP, cv, 0, UnitSize));
        double CurrentLen = 0;
        for (CurrentLen = UnitSize; CurrentLen + UnitSize &lt; length; CurrentLen += UnitSize)
        {
          cv.LengthParameter(CurrentLen, out t);
          Result.Add(GetTactilePavingAlongCurveHelper1(TPL, cv, t));
        }
        cv.LengthParameter(CurrentLen, out t);
        Result.AddRange(GetTactilePavingAlongCurveHelper2(TPP, cv, t, UnitSize));
      }
      return Result.ToArray();
    }

    private static Brep GetTactilePavingAlongCurveHelper1(Brep Origin, Curve cv, double t)
    {
      return GetTactilePavingAlongCurveHelper1(Origin, cv, t, GeneralHelper.GetCurvatureAsAngle(cv, t));
    }

    private static Brep GetTactilePavingAlongCurveHelper1(Brep Origin, Curve cv, double t, double angle)
    {
      return GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t), GeneralHelper.GetCurvatureAsAngle(cv, t));
    }

    private static Brep GetTactilePavingAlongCurveHelper1(Brep Origin, Point3d point, double angle)
    {
      Brep TempTP = (Brep) Origin.Duplicate();
      angle += Math.PI / 2.0;
      TempTP.Rotate(angle, new Vector3d(0, 0, 1), new Point3d(0, 0, 0));
      TempTP.Translate((Vector3d) point);
      return TempTP;
    }

    private static Brep[] GetTactilePavingAlongCurveHelper2(Brep Origin, Curve cv, double t, double UnitSize)
    {
      double angle = GeneralHelper.GetCurvatureAsAngle(cv, t);
      Vector3d Curvature = cv.CurvatureAt(t);
      Curvature /= Curvature.Length;
      return new Brep[]{ GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t), angle)
        ,GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t) + (Curvature * UnitSize), angle)
        ,GetTactilePavingAlongCurveHelper1(Origin, cv.PointAt(t) - (Curvature * UnitSize), angle)
        };
    }

        /*
        public static double GeneralHelper.GetCurvatureAsAngle(Curve cv, double t)
        {
            Vector3d Curvature = cv.CurvatureAt(t);
            double angle = 0;
            if (Curvature.X == 0) { angle = Math.PI / 2.0; }
            else
            {
                angle = Math.Atan(Curvature.Y / Curvature.X);
            }
            return angle;
        }
         */

    public static Brep GetTactilePavingPoint()
    {
      return GetTactilePavingPoint(300, 5, 12, 22, 5, 60, 5);
    }

    public static Brep GetTactilePavingPoint(double BlockSize, int PointCount, double PointSizeTop, double PointSizeBottom, double PointHeight, double PointSpace, double BlockThickness)
    {
      Brep[] Result = new Brep[1 + PointCount * PointCount];
      Result[0] = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(0, BlockThickness)));

      Brep BasicShape = (Brep.CreateFromLoft(
        new Curve[]{
        NurbsCurve.CreateFromCircle(new Circle(new Point3d(0, 0, BlockThickness / 2.0), PointSizeBottom))
        ,NurbsCurve.CreateFromCircle(new Circle(new Point3d(0, 0, BlockThickness), PointSizeBottom))
        ,NurbsCurve.CreateFromCircle(new Circle(new Point3d(0, 0, BlockThickness + PointHeight), PointSizeTop))}, new Point3d(0, 0, BlockThickness), new Point3d(0, 0, BlockThickness + PointHeight), LoftType.Straight, false))[0];
      BasicShape.CapPlanarHoles(PointSizeTop / 100.0);

      for (int i = 0; i &lt; PointCount; i++)
      {
        for (int j = 0; j &lt; PointCount; j++)
        {
          Brep TempShape = (Brep) BasicShape.Duplicate();
          TempShape.Translate((i - PointCount / 2.0 + 0.5) * PointSpace, (j - PointCount / 2.0 + 0.5) * PointSpace, 0);
          Result[i * PointCount + j + 1] = TempShape;
        }
      }
      return (Brep.CreateBooleanUnion(Result, PointSizeTop / 100.0))[0];
    }

    public static Brep GetTactilePavingLine()
    {
      return GetTactilePavingLine(300, 4, 17, 27, 270, 5, 75, 5);
    }

    public static Brep GetTactilePavingLine(double BlockSize, int LineCount, double LineWidthTop, double LineWidthBottom, double LineLength, double LineHeight, double LineSpace, double BlockThickness)
    {
      LineLength -= LineWidthTop;

      Brep[] Result = new Brep[1 + LineCount * LineCount];
      Result[0] = Brep.CreateFromBox(new Box(Plane.WorldXY, new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(-BlockSize / 2.0, BlockSize / 2.0), new Interval(0, BlockThickness)));

      Curve BottomCurve = Curve.JoinCurves(new Curve[]{
        NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(-LineLength / 2.0, 0, 0), LineWidthBottom / 2.0), new Interval(Math.PI / 2.0, Math.PI / 2.0 * 3.0))),
        NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(LineLength / 2.0, 0, 0), LineWidthBottom / 2.0), new Interval(-Math.PI / 2.0, Math.PI / 2.0))),
        NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, LineWidthBottom / 2.0, 0), new Point3d(LineLength / 2.0, LineWidthBottom / 2.0, 0))),
        NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, -LineWidthBottom / 2.0, 0), new Point3d(LineLength / 2.0, -LineWidthBottom / 2.0, 0)))})[0];
      Curve MiddleCurve = (Curve) BottomCurve.Duplicate();
      BottomCurve.Translate(0, 0, BlockThickness / 2.0);
      MiddleCurve.Translate(0, 0, BlockThickness);
      Curve TopCurve = Curve.JoinCurves(new Curve[]{
        NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(-LineLength / 2.0, 0, 0), LineWidthTop / 2.0), new Interval(Math.PI / 2.0, Math.PI / 2.0 * 3.0))),
        NurbsCurve.CreateFromArc(new Arc(new Circle(new Point3d(LineLength / 2.0, 0, 0), LineWidthTop / 2.0), new Interval(-Math.PI / 2.0, Math.PI / 2.0))),
        NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, LineWidthTop / 2.0, 0), new Point3d(LineLength / 2.0, LineWidthTop / 2.0, 0))),
        NurbsCurve.CreateFromLine(new Line(new Point3d(-LineLength / 2.0, -LineWidthTop / 2.0, 0), new Point3d(LineLength / 2.0, -LineWidthTop / 2.0, 0)))})[0];
      TopCurve.Translate(0, 0, BlockThickness + LineHeight);


      Brep BasicShape = (Brep.CreateFromLoft(
        new Curve[] { BottomCurve, MiddleCurve, TopCurve }, new Point3d(0, 0, BlockThickness), new Point3d(0, 0, BlockThickness + LineHeight), LoftType.Straight, false))[0];
      BasicShape.CapPlanarHoles(LineWidthTop / 100.0);

      for (int i = 0; i &lt; LineCount; i++)
      {
        Brep TempShape = (Brep) BasicShape.Duplicate();
        TempShape.Translate(0, (i - LineCount / 2.0 + 0.5) * LineSpace, 0);
        Result[i + 1] = TempShape;
      }
      return (Brep.CreateBooleanUnion(Result, LineWidthTop / 100.0))[0];
    }

    public static Curve[] TrimOutline(Curve[] Origin, double[] Width)
    {
      Curve[] OutlineCurve = new Curve[Origin.GetLength(0)];
      List&lt;List&lt;Curve&gt;&gt; Result = new List&lt;List&lt;Curve&gt;&gt;();
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        OutlineCurve[i] = GetCurveWithWidth(Origin[i], Width[Math.Min(i, Width.GetLength(0) - 1)]);
        Result.Add(new List&lt;Curve&gt;());
        //Result[i].Add((Curve) OutlineCurve[i].Duplicate());
        Result[i].Add((Curve) Origin[i].Duplicate());
      }
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        for (int j = 0; j &lt; Result.Count(); j++)
        {
          if (i == j) { continue; }
          for (int k = 0; k &lt; Result[j].Count(); k++)
          {
            Curve[] TempRet = TrimCurveByOutline(Result[j][k], OutlineCurve[i]);
            if (TempRet.GetLength(0) &gt; 1)
            {
              Result[j].Remove(Result[j][k]);
              Result[j].AddRange(TempRet);
              k--;
            }
          }
        }
      }
      List&lt;Curve&gt; TotalResult = new List&lt;Curve&gt;();
      for (int j = 0; j &lt; Result.Count(); j++)
      {
        TotalResult.AddRange(Result[j]);
      }
      return TotalResult.ToArray();
    }

    public static Curve[] TrimCurveByOutline(Curve Origin, Curve Cutter)
    {
      Origin.Domain = new Interval(0, 1);
      Cutter.Domain = new Interval(0, 1);
      Rhino.Geometry.Intersect.CurveIntersections CurveIntersectRet = Rhino.Geometry.Intersect.Intersection.CurveCurve(Origin, Cutter, 1.0, 1.0);
      double[] SumLength = new double[] { 0.0, 0.0 };
      int cnt = 0;
      double LastPara = 0.0;
      for (int i = 0; i &lt; CurveIntersectRet.Count(); i++)
      {
        if (CurveIntersectRet[i].ParameterA % 1.0 == 0.0) continue;
        if (CurveIntersectRet[i].IsOverlap) continue;
        SumLength[cnt % 2] += CurveIntersectRet[i].ParameterA - LastPara;
        LastPara = CurveIntersectRet[i].ParameterA;
        cnt++;
      }
      int Choice = SumLength[0] &lt; SumLength[1] ? 1 : 0;
      List&lt;Curve&gt; Result = new List&lt;Curve&gt;();
      cnt = 0;
      LastPara = 0.0;
      for (int i = 0; i &lt; CurveIntersectRet.Count(); i++)
      {
        if (CurveIntersectRet[i].ParameterA % 1.0 == 0.0) continue;
        if (CurveIntersectRet[i].IsOverlap) continue;
        if (cnt % 2 == Choice)
        {
          if (LastPara == 0)
          {
            Result.Add((Origin.Split(CurveIntersectRet[i].ParameterA))[0]);
          }
          else
          {
            Result.Add((Origin.Split(new double[] { LastPara, CurveIntersectRet[i].ParameterA }))[1]);
          }
        }
        LastPara = CurveIntersectRet[i].ParameterA;
        cnt++;
      }
      if (cnt % 2 == Choice)
      {
        if (LastPara == 0)
        {
          Result.Add((Curve) Origin.Duplicate());
        }
        else
        {
          Result.Add((Origin.Split(LastPara))[1]);
        }
      }
      return Result.ToArray();
    }

    public static Curve[] GetOutlineSimple(Curve[] Origin, double Width)
    {
      Curve[] OutlineCurveBase = new Curve[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        OutlineCurveBase[i] = GetCurveWithWidth(Origin[i], Width);
      }
      return Curve.CreateBooleanUnion(OutlineCurveBase);
    }

    public static Curve[] GetOutlineSimple(Curve[] Origin, double[] Width)
    {
      Curve[] OutlineCurveBase = new Curve[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        OutlineCurveBase[i] = GetCurveWithWidth(Origin[i], Width[Math.Min(i, Width.GetLength(0) - 1)]);
      }
      return Curve.CreateBooleanUnion(OutlineCurveBase);
    }

    public static Curve[] GetCurveWithWidth(Curve[] Origin, double Width)
    {
      Curve[] Result = new Curve[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        Result[i] = GetCurveWithWidth(Origin[i], Width);
      }
      return Result;
    }

    public static Curve GetCurveWithWidth(Curve Origin, double Width)
    {
      Width /= 2;
      Curve cv1 = (Origin.Offset(Plane.WorldXY, Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];
      Curve cv2 = (Origin.Offset(Plane.WorldXY, -Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];

      return (Curve.JoinCurves(new Curve[] { cv1, cv2, NurbsCurve.CreateFromLine(new Line(cv1.PointAtEnd, cv2.PointAtEnd)), NurbsCurve.CreateFromLine(new Line(cv1.PointAtStart, cv2.PointAtStart)) }))[0];
    }

    public static Curve[] GetCurveWithWidthRound(Curve[] Origin, double Width)
    {
      Curve[] Result = new Curve[Origin.GetLength(0)];
      for (int i = 0; i &lt; Origin.GetLength(0); i++)
      {
        Result[i] = GetCurveWithWidthRound(Origin[i], Width);
      }
      return Result;
    }

    public static Curve GetCurveWithWidthRound(Curve Origin, double Width)
    {
      Width /= 2;
      Curve cv1 = (Origin.Offset(Plane.WorldXY, Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];
      Curve cv2 = (Origin.Offset(Plane.WorldXY, -Width, Width / 100.0, Rhino.Geometry.CurveOffsetCornerStyle.Sharp))[0];
      cv1.Domain = new Interval(0, 1);
      cv2.Domain = new Interval(0, 1);

      return (Curve.JoinCurves(new Curve[] { cv1, cv2, NurbsCurve.CreateFromArc(new Arc(cv1.PointAtEnd, cv1.TangentAt(1.0), cv2.PointAtEnd)), NurbsCurve.CreateFromArc(new Arc(cv1.PointAtStart, cv1.TangentAt(0.0), cv2.PointAtStart)) }))[0];
    }


    public static Curve[] GetDashedLine(Curve Origin, double SegmentLength)
    {
      int Count = (int) Math.Floor(Origin.GetLength() / SegmentLength / 2.0);
      Curve[] result = new Curve[Count + 1];

      for (int i = 0; i &lt;= Count; i++)
      {
        Curve TempCurve = (Curve) Origin.Duplicate();
        Point3d a = TempCurve.PointAtLength(i * SegmentLength * 2.0);
        Point3d b = TempCurve.PointAtLength(i * SegmentLength * 2.0 + SegmentLength);
        double at, bt;
        TempCurve.ClosestPoint(a, out at);
        TempCurve.ClosestPoint(b, out bt);
        TempCurve = (TempCurve.Split(new double[] { at, bt }))[i == 0 ? 0 : 1];
        result[i] = TempCurve;
      }
      return result;
    }
  }
  #endregion

  #region ..\RealObject.cs

  public class RealObject
  {
    public class Material
    {
      public String[] Name { get; private set; }

      public Material(string name)
      {
        Name = name.Split('.');
      }

      public override string ToString()
      {
        return String.Join(".", Name);
      }
    }

    public class Color
    {
      public string Name = "";

      public bool IsRandom { get; set; }
      public bool IsUndefined { get { return !IsRandom &amp;&amp; _IsUndefined; } }
      private bool _IsUndefined;

      private double[] _ARGBValue;
      public double Alpha { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[0]; } } }
      public double Red { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[1]; } } }
      public double Green { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[2]; } } }
      public double Blue { get { if (IsRandom) { return rd.NextDouble(); } else { return _ARGBValue[3]; } } }

      public Color()
      {
        _IsUndefined = true;
        _ARGBValue = new double[] { 0.0, 0.0, 0.0, 0.0 };
      }

      public Color(string name) : this() { this.Name = name; }

      public void SetARGB(double A, double R, double G, double B)
      {
        _IsUndefined = false;
        IsRandom = true;
        if (Math.Max(Math.Max(A, R), Math.Max(G, B)) &gt; 1.0)
        {
          A /= 255.0; R /= 255.0; G /= 255.0; B /= 255.0;
        }
        _ARGBValue[0] = A;
        _ARGBValue[1] = R;
        _ARGBValue[2] = G;
        _ARGBValue[3] = B;
      }

      public void SetRGB(double R, double G, double B)
      {
        SetARGB(1.0, R, G, B);
        _ARGBValue[0] = 1.0;
      }

      public void SetRandomColor()
      {
        _IsUndefined = false;
        IsRandom = true;
        _ARGBValue[0] = rd.NextDouble();
        _ARGBValue[1] = rd.NextDouble();
        _ARGBValue[2] = rd.NextDouble();
        _ARGBValue[3] = rd.NextDouble();
      }

      private Random rd = new Random();

      public static explicit operator System.Drawing.Color(Color cl)
      {
        return System.Drawing.Color.FromArgb((int) (cl.Alpha * 256), (int) (cl.Red * 256), (int) (cl.Green * 256), (int) (cl.Blue * 256));
      }
      public static implicit operator Color(System.Drawing.Color cl)
      {
        Color ret = new Color();
        ret.SetARGB(cl.A / 255.0, cl.R / 255.0, cl.G / 255.0, cl.B / 255.0);
        if (cl.IsKnownColor) { ret.Name = cl.ToKnownColor().ToString(); }
        return ret;
      }

    }

    public class Member
    {
      public String[] Name { get; private set; }

      public Brep[] Content = new Brep[0];

      public Color Color = new Color();

      public Material Material = new Material("Undefined");

      public double DeatailLevel;

      public Member(string name)
      {
        SetName(name);
      }

      public Member(string name, params Brep[] content) : this(name)
      {
        this.Content = content;
      }

      public void SetName(string name)
      {
        Name = name.Split('.');
      }

      public static implicit operator Brep[] (Member origin)
      {
        return origin.Content;
      }

      public static implicit operator Member(Brep[] origin)
      {
        return new Member("BrepMember", origin);
      }

      public override string ToString()
      {
        return String.Join(".", Name);
      }

      public Member Duplicate()
      {
        return new Member(this.ToString(), GeneralHelper.DuplicateBreps(this.Content)) { Color = this.Color, Material = this.Material, DeatailLevel = this.DeatailLevel };
      }

      public void Transform(Transform tf)
      {
        if (Content == null) { return; }
        foreach (Brep bp in Content)
        {
          bp.Transform(tf);
        }
      }

      public void Bake(RhinoDoc doc, string LayerName)
      {
        if (Content == null) { return; }
        int layerIndex = doc.Layers.Add(LayerName, System.Drawing.Color.Black);
        if (doc.Layers.FindByFullPath(LayerName, true) &gt;= 0) { layerIndex = doc.Layers.FindByFullPath(LayerName, true); }
        int GroupIndex = doc.Groups.Add(this.ToString() + Guid.NewGuid().ToString());
        foreach (Brep bp in Content)
        {
          ObjectAttributes oba = new ObjectAttributes();
          oba.LayerIndex = layerIndex;

          oba.ColorSource = this.Color.IsUndefined ? ObjectColorSource.ColorFromLayer : ObjectColorSource.ColorFromObject;
          oba.ObjectColor = (System.Drawing.Color) this.Color;
          oba.AddToGroup(GroupIndex);
          doc.Objects.AddBrep(bp, oba);
        }
      }
    }

    public class Building
    {
      public String[] Name { get; private set; }
      public List&lt;Member&gt; Content;

      public Building(string name)
      {
        Name = name.Split('.');
        Content = new List&lt;Member&gt;();
      }

      public override string ToString()
      {
        return String.Join(".", Name);
      }

      public void Bake(RhinoDoc rd)
      {
        foreach (Member mb in Content)
        {
          mb.Bake(rd, this.ToString() + ":" + mb.ToString());
        }
      }

      public void Add(params Member[] item)
      {
        Content.AddRange(item);
      }

      public Member Add(string name, params Brep[] brep)
      {
        Member result = new Member(name, brep);
        this.Add(result);
        return result;
      }

      public void Transform(Transform tf)
      {
        foreach (Member m in Content)
        {
          m.Transform(tf);
        }
      }

      public void Add(params Building[] item)
      {
        foreach (Building bd in item)
        {
          foreach (Member mb in bd.Content)
          {
            mb.SetName(bd.ToString() + "." + mb.ToString());
            Content.Add(mb);
          }
        }
      }
    }

    public static class Helper
    {
      public static System.Drawing.Color GetRandomColor(Random rd)
      {
        return System.Drawing.Color.FromArgb(rd.Next(256), rd.Next(256), rd.Next(256));
      }

      public static void Bake(Brep[] Content, RhinoDoc doc, string LayerName, System.Drawing.Color color)
      {
        int LayerIndex = doc.Layers.Add(LayerName, color);
        foreach (Brep bp in Content)
        {
          ObjectAttributes oba = new ObjectAttributes();
          oba.LayerIndex = LayerIndex;
          doc.Objects.AddBrep(bp, oba);
        }
      }
    }
  }
  #endregion

  #region ..\Command.cs

  public class Command
  {
    public interface ICommand
    {
      int ArgumentCount { get; }

      double Execute(params double[] arg);

      ICommand Duplicate();
    }

    public class CommandGeneral : ICommand
    {
      public Func&lt;double[], double&gt; Content { get; private set; }

      public CommandGeneral(Func&lt;double[], double&gt; arg, int argCount)
      {
        this.Content = arg;
        this.ArgumentCount = argCount;
      }

      public int ArgumentCount { get; private set; }

      public double Execute(params double[] arg)
      {
        return Content(arg);
      }

      public ICommand Duplicate()
      {
        return new CommandGeneral(Content, ArgumentCount);
      }
    }

    public class Commands
    {
      public class Mathematics
      {
        public class Add : ICommand
        {
          public int ArgumentCount { get { return 2; } }

          public ICommand Duplicate()
          {
            return new Add();
          }

          public double Execute(params double[] arg)
          {
            double result = 0;
            foreach (var item in arg)
            {
              result += item;
            }
            return result;
          }
        }

        public class Subtract : ICommand
        {
          public int ArgumentCount { get { return 2; } }

          public ICommand Duplicate()
          {
            return new Subtract();
          }

          public double Execute(params double[] arg)
          {
            return arg[0] - arg[1];

          }
        }

        public class Multiply : ICommand
        {
          public int ArgumentCount { get { return 2; } }

          public ICommand Duplicate()
          {
            return new Multiply();
          }

          public double Execute(params double[] arg)
          {
            double result = 1;
            foreach (var item in arg)
            {
              result *= item;
            }
            return result;
          }
        }

        public class Divide : ICommand
        {
          public int ArgumentCount { get { return 2; } }

          public ICommand Duplicate()
          {
            return new Divide();
          }

          public double Execute(params double[] arg) { return arg[0] / arg[1]; }
        }

        public class Minus : ICommand
        {
          public int ArgumentCount { get { return 1; } }

          public ICommand Duplicate()
          {
            return new Minus();
          }

          public double Execute(params double[] arg) { return -arg[0]; }
        }
        public class Sin : ICommand
        {
          public int ArgumentCount { get { return 1; } }

          public ICommand Duplicate()
          {
            return new Sin();
          }

          public double Execute(params double[] arg) { return Math.Sin(arg[0]); }
        }

        public class Cos : ICommand
        {
          public int ArgumentCount { get { return 1; } }

          public ICommand Duplicate()
          {
            return new Cos();
          }

          public double Execute(params double[] arg) { return Math.Cos(arg[0]); }
        }

        public class Tan : ICommand
        {
          public int ArgumentCount { get { return 1; } }

          public ICommand Duplicate()
          {
            return new Tan();
          }

          public double Execute(params double[] arg) { return Math.Tan(arg[0]); }
        }

        public class Power : ICommand
        {
          public int ArgumentCount { get { return 2; } }

          public ICommand Duplicate()
          {
            return new Power();
          }

          public double Execute(params double[] arg) { return Math.Pow(arg[0], arg[1]); }
        }

      }

      public class Combined : ICommand
      {

        public ICommand MainCommand { get; private set; }
        public ICommand[] Arguments { get; private set; }

        public Combined(ICommand Main, params ICommand[] Args)
        {
          if (Args.Count() != Main.ArgumentCount)
          {
            throw new Exception("Argument count does not match.");
          }
          this.MainCommand = Main;
          this.Arguments = Args;
        }


        public int ArgumentCount
        {
          get
          {
            int result = 0;
            foreach (var item in Arguments)
            {
              result += item.ArgumentCount;
            }
            return result;
          }
        }

        public double Execute(params double[] arg)
        {
          int currentArgCount = 0;
          double[] argumentsResult = new double[Arguments.Count()];
          for (int i = 0; i &lt; Arguments.Count(); i++)
          {
            int argCnt = Arguments[i].ArgumentCount;
            double[] tempArg = new double[argCnt];
            Array.Copy(arg, currentArgCount, tempArg, 0, argCnt);
            argumentsResult[i] = Arguments[i].Execute(tempArg);

            currentArgCount += argCnt;
          }
          return MainCommand.Execute(argumentsResult);
        }

        public ICommand Duplicate()
        {
          var args = new ICommand[Arguments.Count()];
          for (int i = 0; i &lt; Arguments.Count(); i++)
          {
            args[i] = Arguments[i].Duplicate();
          }
          return new Combined(this.MainCommand.Duplicate(), args);
        }
      }

      public class Argument : ICommand
      {
        public int ArgumentCount
        {
          get { return 1; }
        }

        public ICommand Duplicate()
        {
          return new Argument();
        }

        public double Execute(params double[] arg)
        {
          return arg[0];
        }
      }

      public class ImmediateValue : ICommand
      {
        public double Value { get; set; }

        public int ArgumentCount
        {
          get { return 0; }
        }

        public ImmediateValue(double Value)
        {
          this.Value = Value;
        }

        public double Execute(params double[] arg)
        {
          return Value;
        }

        public ICommand Duplicate()
        {
          return new ImmediateValue(this.Value);
        }
      }
    }

    public static class Operation
    {
      public static double ExecuteCommandWithUnmatchedArgs(ICommand cmd, params double[] args)
      {
        var cnt = cmd.ArgumentCount;
        if (cnt == args.Count()) { return cmd.Execute(args); }
        if (cnt &lt; args.Count())
        {
          double[] newArg = new double[cnt];
          Array.Copy(args, newArg, cnt);
          return cmd.Execute(newArg);
        }
        var targ = new double[cnt];
        for (int i = args.Count(); i &lt; cnt; i++)
        {
          targ[i] = args[i % args.Count()];
        }
        return cmd.Execute(targ);
      }


      public static String GetLispLikeText(ICommand command)
      {
        if (command is Commands.Combined)
        {
          var cm = (Commands.Combined) command;
          string result = "(" + cm.MainCommand.GetType().Name;
          foreach (var item in cm.Arguments)
          {
            result += " " + GetLispLikeText(item);
          }
          return result + ")";
        }
        else if (command is Commands.ImmediateValue)
        {
          var cm = (Commands.ImmediateValue) command;
          return cm.Value.ToString();
        }
        else if (command is Commands.Argument)
        {
          return "*";
        }
        else
        {
          var temporary = "";
          for (int i = 0; i &lt; command.ArgumentCount; i++)
          {
            temporary += " *";
          }
          return "(" + command.GetType().Name + temporary.ToString() + ")";
        }
      }

      public static int CountContainingCommand(ICommand command, bool CountImmediateValue = true, bool CountArgument = true)
      {
        if (command is Commands.Combined)
        {
          var commandComb = (Commands.Combined) command;
          int result = 1;
          for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
          {
            result += CountContainingCommand(commandComb.Arguments[i]);
          }
          return result;
        }
        else if (command is Commands.ImmediateValue)
        {
          return CountImmediateValue ? 1 : 0;
        }
        else if (command is Commands.Argument)
        {
          return CountArgument ? 1 : 0;
        }
        else
        {
          return 1;
        }
      }

      public static int CountContainingArgument(ICommand command)
      {
        if (command is Commands.Combined)
        {
          int result = 0;
          var commandComb = (Commands.Combined) command;
          for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
          {
            result += (CountContainingArgument(commandComb.Arguments[i]));
          }
          return result;
        }
        else if (command is Commands.Argument)
        {
          return 1;
        }
        else
        {
          return command.ArgumentCount;
        }
      }

      public static int CountContainingImmediateValue(ICommand command)
      {
        return GetFixedNumbers(command).Count();
      }

      public static double[] GetFixedNumbers(ICommand command)
      {
        if (command is Commands.Combined)
        {
          List&lt;double&gt; result = new List&lt;double&gt;();
          var commandComb = (Commands.Combined) command;
          for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
          {
            result.AddRange(GetFixedNumbers(commandComb.Arguments[i]));
          }
          return result.ToArray();
        }
        else if (command is Commands.ImmediateValue)
        {
          return new double[] { (command as Commands.ImmediateValue).Value };
        }
        else
        {
          return new double[0];
        }
      }

      public static ICommand SetFixedNumbers(ICommand arg, params double[] numbers)
      {
        int temp = 0;
        return SetFixedNumbers(arg, ref temp, numbers);
      }

      public static ICommand SetFixedNumbers(ICommand arg, ref int offset, params double[] numbers)
      {
        var command = arg.Duplicate();
        if (command is Commands.Combined)
        {
          List&lt;double&gt; result = new List&lt;double&gt;();
          var commandComb = (Commands.Combined) command;
          for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
          {
            commandComb.Arguments[i] = SetFixedNumbers(commandComb.Arguments[i], ref offset, numbers);
          }
          return command;
        }
        else if (command is Commands.ImmediateValue)
        {
          if (offset &lt; numbers.Count())
          {
            (command as Commands.ImmediateValue).Value = numbers[offset];
            offset++;
          }
          else
          {
          }
          return command;
        }
        else
        {
          return command;
        }
      }

      public static ICommand SwapCommand(ICommand arg, int target, ICommand newCommand, bool CountImmediateValue = true, bool CountArgument = true)
      {
        var command = arg.Duplicate();

        if (target &lt; 0) { return command; }
        if (command is Commands.Combined)
        {
          if (target == 0)
          {
            return newCommand;
          }
          var commandComb = (Commands.Combined) command;
          for (int i = 0; i &lt; commandComb.Arguments.Count(); i++)
          {
            var count = CountContainingCommand(commandComb.Arguments[i], CountImmediateValue, CountArgument);
            if (target &lt; count)
            {
              commandComb.Arguments[i] = SwapCommand(commandComb.Arguments[i], target, newCommand, CountImmediateValue, CountArgument);
            }
            target -= count;
          }
          return command;
        }
        else if (command is Commands.ImmediateValue)
        {
          if (CountImmediateValue &amp;&amp; target == 0)
          {
            return newCommand;
          }
          return command;
        }
        else if (command is Commands.Argument)
        {
          if (CountArgument &amp;&amp; target == 0)
          {
            return newCommand;
          }
          return command;
        }
        else
        {
          if (target == 0)
          {
            return newCommand;
          }
          return command;
        }
      }

      public static ICommand SwapCommandRandom(ICommand arg, ICommand newCommand, Random rd, bool CountImmediateValue = true, bool CountArgument = true)
      {
        var count = CountContainingCommand(arg, CountImmediateValue, CountArgument);
        return SwapCommand(arg, rd.Next(count), newCommand, CountImmediateValue, CountArgument);
      }
    }
  }
  #endregion

</item>
                    <item name="Description" type_name="gh_string" type_code="10">A C#.NET scriptable component</item>
                    <item name="EditorPosition" type_name="gh_drawing_point" type_code="30">
                      <X>2</X>
                      <Y>2651</Y>
                    </item>
                    <item name="InstanceGuid" type_name="gh_guid" type_code="9">71d86f42-d665-448a-a24d-324dd3f9dee0</item>
                    <item name="Name" type_name="gh_string" type_code="10">C# Script</item>
                    <item name="NickName" type_name="gh_string" type_code="10">C#</item>
                    <item name="OutParameter" type_name="gh_bool" type_code="1">true</item>
                    <item name="ReferenceCount" type_name="gh_int32" type_code="3">0</item>
                  </items>
                  <chunks count="2">
                    <chunk name="Attributes">
                      <items count="2">
                        <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                          <X>37</X>
                          <Y>26</Y>
                          <W>75</W>
                          <H>44</H>
                        </item>
                        <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                          <X>67</X>
                          <Y>48</Y>
                        </item>
                      </items>
                    </chunk>
                    <chunk name="ParameterData">
                      <items count="6">
                        <item name="InputCount" type_name="gh_int32" type_code="3">2</item>
                        <item name="InputId" index="0" type_name="gh_guid" type_code="9">84fa917c-1ed8-4db3-8be1-7bdc4a6495a2</item>
                        <item name="InputId" index="1" type_name="gh_guid" type_code="9">84fa917c-1ed8-4db3-8be1-7bdc4a6495a2</item>
                        <item name="OutputCount" type_name="gh_int32" type_code="3">2</item>
                        <item name="OutputId" index="0" type_name="gh_guid" type_code="9">3ede854e-c753-40eb-84cb-b48008f14fd4</item>
                        <item name="OutputId" index="1" type_name="gh_guid" type_code="9">8ec86459-bf01-4409-baee-174d0d2b13d0</item>
                      </items>
                      <chunks count="4">
                        <chunk name="InputParam" index="0">
                          <items count="9">
                            <item name="AllowTreeAccess" type_name="gh_bool" type_code="1">true</item>
                            <item name="Description" type_name="gh_string" type_code="10">Script Variable x</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">13dbe4fc-cdee-42c7-a9ab-7b0781a1fe83</item>
                            <item name="Name" type_name="gh_string" type_code="10">x</item>
                            <item name="NickName" type_name="gh_string" type_code="10">x</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">true</item>
                            <item name="ScriptParamAccess" type_name="gh_int32" type_code="3">0</item>
                            <item name="ShowTypeHints" type_name="gh_bool" type_code="1">true</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="2">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>39</X>
                                  <Y>28</Y>
                                  <W>13</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>47</X>
                                  <Y>38</Y>
                                </item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                        <chunk name="InputParam" index="1">
                          <items count="9">
                            <item name="AllowTreeAccess" type_name="gh_bool" type_code="1">true</item>
                            <item name="Description" type_name="gh_string" type_code="10">Script Variable y</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">903d88e9-ef74-48ec-95be-afc04d545bac</item>
                            <item name="Name" type_name="gh_string" type_code="10">y</item>
                            <item name="NickName" type_name="gh_string" type_code="10">y</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">true</item>
                            <item name="ScriptParamAccess" type_name="gh_int32" type_code="3">0</item>
                            <item name="ShowTypeHints" type_name="gh_bool" type_code="1">true</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="2">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>39</X>
                                  <Y>48</Y>
                                  <W>13</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>47</X>
                                  <Y>58</Y>
                                </item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                        <chunk name="OutputParam" index="0">
                          <items count="7">
                            <item name="Access" type_name="gh_int32" type_code="3">1</item>
                            <item name="Description" type_name="gh_string" type_code="10">Print, Reflect and Error streams</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">f45c0d2f-f8dd-4486-984d-995c0fec83c6</item>
                            <item name="Name" type_name="gh_string" type_code="10">out</item>
                            <item name="NickName" type_name="gh_string" type_code="10">out</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">false</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="2">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>82</X>
                                  <Y>28</Y>
                                  <W>28</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>96</X>
                                  <Y>38</Y>
                                </item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                        <chunk name="OutputParam" index="1">
                          <items count="6">
                            <item name="Description" type_name="gh_string" type_code="10">Output parameter A</item>
                            <item name="InstanceGuid" type_name="gh_guid" type_code="9">3985a8c4-2924-4892-892f-b3c149887270</item>
                            <item name="Name" type_name="gh_string" type_code="10">A</item>
                            <item name="NickName" type_name="gh_string" type_code="10">A</item>
                            <item name="Optional" type_name="gh_bool" type_code="1">false</item>
                            <item name="SourceCount" type_name="gh_int32" type_code="3">0</item>
                          </items>
                          <chunks count="1">
                            <chunk name="Attributes">
                              <items count="2">
                                <item name="Bounds" type_name="gh_drawing_rectanglef" type_code="35">
                                  <X>82</X>
                                  <Y>48</Y>
                                  <W>28</W>
                                  <H>20</H>
                                </item>
                                <item name="Pivot" type_name="gh_drawing_pointf" type_code="31">
                                  <X>96</X>
                                  <Y>58</Y>
                                </item>
                              </items>
                            </chunk>
                          </chunks>
                        </chunk>
                      </chunks>
                    </chunk>
                  </chunks>
                </chunk>
              </chunks>
            </chunk>
          </chunks>
        </chunk>
      </chunks>
    </chunk>
    <chunk name="Thumbnail">
      <items count="1">
        <item name="Thumbnail" type_name="gh_drawing_bitmap" type_code="37">
          <bitmap length="2944">iVBORw0KGgoAAAANSUhEUgAAAJYAAABkCAIAAADrOV6nAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAsVSURBVHhe7Zp5UM/dHsf9aRhj/MOY8Q9DDdm37Ou1XDtljxSRNWuECSWUQn6SmKFMJUqJ0fNTKUtyVbbsl5Bre272LVue53U739t97lN99fOPc5457z9+c37n9z3ne3xe57M1qmn9FfSblrL6H8J/aSkojVB5aYTKSyNUXhqh8tIIlZdGqLw0QuWlESovjVB5aYTKSyNUXhqh8tIIlZdGqLw0QuWlESovjVB5aYTKSyNUXhqh8tIIlZdGqLw0QuWlESovjVB5aYTKSyNUXhqh8tIIlZdGqLw0QuUlL8KHDx8+ffr0Vzn05MkT41jySUaEDx48AN6jR4+ysrJOnDhx0lSnqibj6R9SZmZmfn7+8+fPjfNJJhkRcuVv3ry5ZMmSNWvWbNy4MagiBQYGbtq0KSIiIiQkJDg4mM/KxK+hoaE7duwwVv6QFi5cGBkZKSdFGRG+fPly3bp1SUlJHMlEX79+5TGMO99UPODl5ZWQkGAs+yF9/Phx0aJF2dnZhAfjlNKI40mHkNyzatWqx48fY7h3laikpAQ8K1asuHz58rlz5/5RuXJycvLy8pycnOLj4799+2ast0Vv377FOLt27WKHZ8+eGaeURjIiJF4FBATcu3fv/fv3rysSZsUbJkyYAL+UlJRfTMUDZ86ciYuLwx35Nxpb2CgWEoqPHDkiYSyVDiH2opwhEd6/f5/rT1Atrzdv3vCkq6vr8ePHo6Oj931PiYmJu3fvXrp0Kf9GY4uK9OLFiw8fPvBSBsbUf8XCsLCwPXv28ABBghOK08oguRDCj6qhTp06Dg4O/y4V4ZTSFJty/SlzeIBPjHjnzh28cNu2bbNnzxY5z0Te3t7+/v5ci+LiYjZEXAJgEBXZ7dWrV7yCMb+SgM+fP8+AGfGk0KdPn3bu3ImVBg8efPfuXQ5gnFgCSYQQTunp6ZzExcWFJEdRymUnnGJB3IjKHqJRUVG3b9/m4evXr48ZM4YSo3v37n8zVd++fQcOHDhnzhwexp/YEGx79+719fUlUxYUFBw8eJAZ9j979uzo0aPHjh2bnJzMDE8KwQzMIPTx8alRo8aAAQPYh7ZVHPunSyKEZL7x48c3bNiQkxC1Ll26VIbQarW6ubnRSNBmkAWZByHmXrx4cZ8+ff5eqkGDBjEGGGPI8RUxht/QoUNBSC7E9EVFRfCbNGkSUZHPjIwMd3d3Xk33YrFYwMyep0+fhpDgh0DIQjoTJkmH2Ar27GOc+2dLLoSYu2PHjpyEnu/ixYuFhYWYj5hJZAOevb093oBNmb927Zqzs/OCBQsEQjyjXbt2AED9+vWDDVuhMoSenp4gxNHR3Llzjx49ylvwKkIx88TJ8PBw8iWcgEQ6xDt5tRBjVm3ZsoXBlStXsBXg5alrJEJIfqLq4yTU7lu3bsULqWiwGsDIT7gRjoihCXHMg3DUqFHz5s3r3bs3njdu3LgDBw4Qe2NiYniMRsLR0VGE0P79+5PAPDw84I3d8R4cDmy0IqxKS0tjH0IoxRGhkp+WL1/O5lwUXi3EHWIhgYHitkePHg0aNBCZ0jj3z5ZECAlTWAoAHKZ9+/Zwwo6YD3vhH3BlTAIjF/LT1atXR4wYQS3Tq1cv3A5v4yd6DB4mxpI1g4KCcFMo8isRlWhJXUPNIqisXLmSF8XGxuJeXBd8lOyLa3JvYEkLyD68Tog38lhERAQHq1WrVmpqKnHVOLQEkggh4mpjrISEBKpNXAFb/7NUInjylWf4yiA/P3/YsGGYvmfPnsTSkSNHEhXxEgw9c+ZMkuWhQ4eY6datG3kRwJMnT/by8gIty6GCKwOJS3Pr1i0GiBRLzORFDLgipa81xDP47ubNm3H6GzduEMx1U2EmzErm27BhQ15eHrbGfEjYsWzAPAjJcNOmTQMhjghOCkuWY1wWwoBQyaQIs4RT7gQAaAbK9vnjnmX6009CxGcWkp5pQ0mTUvFD0iFE+ArFCySIYJivvJgnZpLhCIYkJyBBsUmTJpSa+/fvpwXE0KdOnSI2durUCYqkQ1oFqhg8zNjCFuF5LAQhnq3/wFYlCYS5ubl4A+YrL+ZJWiI8EiqBRCxt27Yt2VGIwtLOzg66zEOXWOrk5ARC4qexhS0iubIwJCREI6yqQLh69WoqRoIY5isv5kFII0F4BCGQOnfuTCVJkUJPgudRatIDMC/CLG4KV2pacq2xhS0iK5Msg4ODNcKqCjP5+fnRPhPEMF95MU/XSKlJeOzatatwRKoMWgK6Q3AOHz6cLpMSlMpW1DtDhgyhfIWEsYUtovolQ7M5LaNG+B1RKVCRAgN/olcjiGG+8mL+woULIjwCDM+bOHEieADZpUsXmDVr1ozSgz6vZcuWhFPmqWhmzZoFCbEDYHgdV4FWXcyYiGd4ODAwMDEx8cuXL7iyrkgrFnYBntVqbd68eYsWLbAyQQzzUXyS/PgqBtiUeZp9fIvwKBAyoIRxcXFp3Lgx/Fq3bk17QPYCIT4KVFyWZoO3CGZ8Llu2jJKH28DYXLyXhexWs2ZN7gGlDamx9MhSSCKE9F45OTnVq1cnNmIpxgIbRuT6wwxzk42YFwhJcoRHMh+eB7OsrCwoWiyWgIAAwuznz5/5tUOHDuwmHFH0i2xITxIXF1e/fv21a9cyQ3HLpIl4gC6FEonUi6GooV6/fm0cWgJJhJDs5e7uXrduXU6yffv2zMxM3AXz0XGTxsLDw6lRSX7YFLS0HIChKHV0dAQSqICUnp5eUlLCclxwxowZrVq14icAdy+Vp6dnYWEhdRAb0ubTgfA64WS8xVxsuH79ekJoZGQktuICUXMZ5/7Zkgjhu3fvCHcYnZOQeECIfbE4zpeUlIRfMokdAcA8OImQNHwgBBKrqFxgJv6cRmhlzLwQ/PgEKs7EWrIsX7kTrIqNjRX1rbkKCgpwbvHHNmzFXdF/5q5AhEEgcRJq0bCwsIyMDPyDkIgwnKurKzGTKPqf0JafD0Iw0C2ILgKRFPkEJEUpk+KrEKiYmT59Os4EDN5C7qRVnzJlioeHB3dCvMVEwBN/MKJdqV27NldBnnQoEULCFJUCbsRh8BuCFRGMyhNhZZp94h624yvzsIQNdQohFEc0F7DbtGkjaOHTFDLHjh2jgoUN/T5g8DPxosoEeJBTznC2mJgYnQsrFpXFr6X/b5raj2CYnZ2NZQGJBUmKbm5u1DIMmMH0NP6wIZaCEA8zFx5JaQpCSAhgXAIG7CMG7GkuwgC1j7Oz88mTJ6XihyRCiKCIL1JMknhSU1MxsbAvwOAHS74iBgRb0cXzSfA0FxQdHBy4BMRDsaHYB/1xbCI6SD8/P9JzcXExhzSOK4fkQihEsefr65uWlgYqcp4Q7mKMcnOxKekQfk2bNiXPMTAXtWu9evXmz59PW2lsYaMIv/7+/snJyfqvM1USxZ6Pj8/hw4e5+5CrUEQ2cpK9vb2dnV2T76lRo0YUPrgy3Yix3kaRRL29vVNSUjTCKgkzcd+nTp0aFRVF98ZnedGfxcfHi//5gnstqFziPyGyz759+1hlrLdF0dHRBHa2IoRSBBmnlEYyIkQ4otVqxXA0glTz5cU8Cg4O3loFhYaGBgUFVbbVd8UxLBYLeZSC2TifTJIUISoqKqL2eyWNZPvrdpnkRahVRWmEyksjVF4aofLSCJWXRqi8NELlpREqL41QeWmEyksjVF4aofLSCJWXRqi8NELlpREqL41QeWmEyksjVF4aofLSCJWXRqi8NELlpREqL41QeWmEyksjVF4aofLSCJWXRqi8NELl9X8ItRSVgVBLYVWr9jvUVrkYOJRsPwAAAABJRU5ErkJggg==</bitmap>
        </item>
      </items>
    </chunk>
  </chunks>
</Archive>